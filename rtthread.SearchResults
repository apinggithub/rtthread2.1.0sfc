---- size Matches (4427 in 822 files) ----
00readme.txt (components\dfs\filesystems\elmfat):                       Added a capability of extending the file size to f_lseek.
00readme.txt (components\dfs\filesystems\elmfat):                       Added auto cluster size selection to f_mkfs().
00readme.txt (components\dfs\filesystems\elmfat):                       Added multiple sector size support.
00readme.txt (components\dfs\filesystems\elmfat):                       f_lseek() reports required table size on creating CLMP.
120x68.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
160x120.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
160x90.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
200x150.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
240x136.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
240x180.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
320x180.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
320x240.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
480x272.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
80x45.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
80x60.bat (components\emwin1\software\jpeg2moviescripts):*              Note: The file name of this file needs to match the size
A00036.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00037.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00038.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00039.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00040.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00041.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00042.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00043.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00044.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00045.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00046.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00047.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00048.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00049.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00050.html (components\net\uip\doc\html):<a name="l00103"></a>00103 <span class="comment"> * uIP buffer size.</span>
A00050.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00051.html (components\net\uip\doc\html):<a name="l00037"></a>00037 <span class="comment"> * keyword. This keeps the size of the symbol table down.</span>
A00051.html (components\net\uip\doc\html):</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00077.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00078.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00079.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00080.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00081.html (components\net\uip\doc\html):<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b42c7af6114fde5d21206a2e18a7d3ee"></a><!-- doxytag: member="memb_blocks::size" ref="b42c7af6114fde5d21206a2e18a7d3ee" args="" -->
A00081.html (components\net\uip\doc\html):unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html#b42c7af6114fde5d21206a2e18a7d3ee">size</a></td></tr>
A00081.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00082.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00083.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00084.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00085.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00086.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00087.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00088.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current maximum segment size for the connection. <br></td></tr>
A00088.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initial maximum segment size for the connection. <br></td></tr>
A00088.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00089.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00090.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00091.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00092.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00093.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00094.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00095.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00096.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00097.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00100.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00101.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00102.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00103.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00104.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00105.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00107.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00110.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00111.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00112.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00113.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00114.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00120.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00121.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00123.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00124.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00125.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00127.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00128.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00129.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00130.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00131.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00132.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00134.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00135.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00136.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the initial maxium segment size (MSS) of the current connection. <br></td></tr>
A00136.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current maxium segment size that can be sent on the current connection.  <a href="a00147.html#gb5fecbc62edd128012cea0f47b57ab9f"></a><br></td></tr>
A00136.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The buffer size available for user data in the <a class="el" href="a00150.html#gb81e78f890dbbee50c533a9734b74fd9">uip_buf</a> buffer.  <a href="a00150.html#ge0825474feee11b4e038bfe71757875f"></a><br></td></tr>
A00136.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00137.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00138.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00139.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00140.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The TCP maximum segment size.  <a href="a00153.html#g4910467b83a639f06739c82cd362037e"></a><br></td></tr>
A00140.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of the advertised receiver's window.  <a href="a00153.html#g5b9dba2123705bce1ce95c3deca0bdad"></a><br></td></tr>
A00140.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of the ARP table.  <a href="a00153.html#gb1455b27c06532a399cf06d2c1d6d08d"></a><br></td></tr>
A00140.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of the uIP packet buffer.  <a href="a00153.html#g3589822ecb9d9c4145209756396b8a6b"></a><br></td></tr>
A00140.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00141.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">uIP buffer size. <br></td></tr>
A00141.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00142.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00143.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00144.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00145.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00146.html (components\net\uip\doc\html):The uip_buf array is used to hold incoming and outgoing packets. The device driver should place incoming data into this buffer. When sending data, the device driver should read the link level headers and the TCP/IP headers from this buffer. The size of the link level headers is configured by the UIP_LLH_LEN define.<p>
A00146.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00147.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the initial maxium segment size (MSS) of the current connection. <br></td></tr>
A00147.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current maxium segment size that can be sent on the current connection.  <a href="#gb5fecbc62edd128012cea0f47b57ab9f"></a><br></td></tr>
A00147.html (components\net\uip\doc\html):Get the current maxium segment size that can be sent on the current connection. 
A00147.html (components\net\uip\doc\html):The current maxiumum segment size that can be sent on the connection is computed from the receiver's window and the MSS of the connection (which also is available by calling <a class="el" href="a00147.html#ga87feebc7cffd4d8300e776cf64e4fec">uip_initialmss()</a>). <dl compact><dt><b>Examples: </b></dt><dd>
A00147.html (components\net\uip\doc\html):Will reduce to non-zero if there is new data for the application present at the uip_appdata pointer. The size of the data is avaliable through the uip_len variable. <dl compact><dt><b>Examples: </b></dt><dd>
A00147.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00148.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00149.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00150.html (components\net\uip\doc\html):uIP provides the necessary protocols for Internet communication, with a very small code footprint and RAM requirements - the uIP code size is on the order of a few kilobytes and RAM usage is on the order of a few hundred bytes. 
A00150.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The buffer size available for user data in the <a class="el" href="a00150.html#gb81e78f890dbbee50c533a9734b74fd9">uip_buf</a> buffer.  <a href="#ge0825474feee11b4e038bfe71757875f"></a><br></td></tr>
A00150.html (components\net\uip\doc\html):The buffer size available for user data in the <a class="el" href="a00150.html#gb81e78f890dbbee50c533a9734b74fd9">uip_buf</a> buffer. 
A00150.html (components\net\uip\doc\html):This macro holds the available size for user data in the <a class="el" href="a00150.html#gb81e78f890dbbee50c533a9734b74fd9">uip_buf</a> buffer. The macro is intended to be used for checking bounds of available user data.<p>
A00150.html (components\net\uip\doc\html):The uip_buf array is used to hold incoming and outgoing packets. The device driver should place incoming data into this buffer. When sending data, the device driver should read the link level headers and the TCP/IP headers from this buffer. The size of the link level headers is configured by the UIP_LLH_LEN define.<p>
A00150.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00151.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00152.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00153.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">uIP buffer size. <br></td></tr>
A00153.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The TCP maximum segment size.  <a href="#g4910467b83a639f06739c82cd362037e"></a><br></td></tr>
A00153.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of the advertised receiver's window.  <a href="#g5b9dba2123705bce1ce95c3deca0bdad"></a><br></td></tr>
A00153.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of the ARP table.  <a href="#gb1455b27c06532a399cf06d2c1d6d08d"></a><br></td></tr>
A00153.html (components\net\uip\doc\html):<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size of the uIP packet buffer.  <a href="#g3589822ecb9d9c4145209756396b8a6b"></a><br></td></tr>
A00153.html (components\net\uip\doc\html):If the applications that are running on top of uIP for this project do not need to open outgoing TCP connections, this configration option can be turned off to reduce the code size of uIP. 
A00153.html (components\net\uip\doc\html):The size of the ARP table. 
A00153.html (components\net\uip\doc\html):The size of the uIP packet buffer. 
A00153.html (components\net\uip\doc\html):The uIP packet buffer should not be smaller than 60 bytes, and does not need to be larger than 1500 bytes. Lower size results in lower TCP throughput, larger size results in higher TCP throughput. 
A00153.html (components\net\uip\doc\html):uIP supports reassembly of fragmented IP packets. This features requires an additonal amount of RAM to hold the reassembly buffer and the reassembly code size is approximately 700 bytes. The reassembly buffer is of the same size as the uip_buf buffer (configured by UIP_BUFSIZE).<p>
A00153.html (components\net\uip\doc\html):The size of the advertised receiver's window. 
A00153.html (components\net\uip\doc\html):Should be set low (i.e., to the size of the uip_buf buffer) is the application is slow to process incoming data, or high (32768 bytes) if the application processes data quickly. 
A00153.html (components\net\uip\doc\html):The TCP maximum segment size. 
A00153.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00154.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00155.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00156.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00157.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00158.html (components\net\uip\doc\html):    <tr><td valign="top"></td><td valign="top"><em>buffersize</em>&nbsp;</td><td>(unsigned int) The size of the input buffer. </td></tr>
A00158.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00159.html (components\net\uip\doc\html):The memory block allocation routines provide a simple yet powerful set of functions for managing a set of memory blocks of fixed size. 
A00159.html (components\net\uip\doc\html):This macro is used to staticall declare a block of memory that can be used by the block allocation functions. The macro statically declares a C array with a size that matches the specified number of blocks and their individual sizes.<p>
A00159.html (components\net\uip\doc\html):    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of each memory chunk, in bytes.</td></tr>
A00159.html (components\net\uip\doc\html):References <a class="el" href="a00187.html#l00108">memb_blocks::count</a>, <a class="el" href="a00187.html#l00109">memb_blocks::mem</a>, <a class="el" href="a00187.html#l00107">memb_blocks::num</a>, and <a class="el" href="a00187.html#l00106">memb_blocks::size</a>.    </td>
A00159.html (components\net\uip\doc\html):References <a class="el" href="a00187.html#l00108">memb_blocks::count</a>, <a class="el" href="a00187.html#l00109">memb_blocks::mem</a>, and <a class="el" href="a00187.html#l00106">memb_blocks::size</a>.    </td>
A00159.html (components\net\uip\doc\html):References <a class="el" href="a00187.html#l00108">memb_blocks::count</a>, <a class="el" href="a00187.html#l00109">memb_blocks::mem</a>, <a class="el" href="a00187.html#l00107">memb_blocks::num</a>, and <a class="el" href="a00187.html#l00106">memb_blocks::size</a>.    </td>
A00159.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00160.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00161.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00162.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00163.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00164.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
A00168.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00169.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00170.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00171.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00172.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00173.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00174.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00175.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00176.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00177.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00178.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00179.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00180.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00181.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00182.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00183.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00184.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00185.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00186.html (components\net\uip\doc\html):<a name="l00055"></a>00055   memset(m-&gt;<a class="code" href="a00081.html#b5801722740492e69bcc73687476009f">mem</a>, 0, m-&gt;<a class="code" href="a00081.html#b42c7af6114fde5d21206a2e18a7d3ee">size</a> * m-&gt;<a class="code" href="a00081.html#164124d48fe85bc98d9a300382a5245d">num</a>);
A00186.html (components\net\uip\doc\html):<a name="l00069"></a>00069       return (<span class="keywordtype">void</span> *)((<span class="keywordtype">char</span> *)m-&gt;<a class="code" href="a00081.html#b5801722740492e69bcc73687476009f">mem</a> + (i * m-&gt;<a class="code" href="a00081.html#b42c7af6114fde5d21206a2e18a7d3ee">size</a>));
A00186.html (components\net\uip\doc\html):<a name="l00098"></a>00098     ptr2 += m-&gt;<a class="code" href="a00081.html#b42c7af6114fde5d21206a2e18a7d3ee">size</a>;
A00186.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00187.html (components\net\uip\doc\html):<a name="l00041"></a>00041 <span class="comment"> * size. A set of memory blocks is statically declared with the</span>
A00187.html (components\net\uip\doc\html):<a name="l00082"></a>00082 <span class="comment"> * declares a C array with a size that matches the specified number of</span>
A00187.html (components\net\uip\doc\html):<a name="l00093"></a>00093 <span class="comment"> * \param size The size of each memory chunk, in bytes.</span>
A00187.html (components\net\uip\doc\html):<a name="l00106"></a><a class="code" href="a00081.html#b42c7af6114fde5d21206a2e18a7d3ee">00106</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="a00081.html#b42c7af6114fde5d21206a2e18a7d3ee">size</a>;
A00187.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00188.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00189.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00190.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00191.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00192.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00193.html (components\net\uip\doc\html):<a name="l00121"></a><a class="code" href="a00082.html#a6bfaf327ce839ba70accd71014398d0">00121</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="a00082.html#a6bfaf327ce839ba70accd71014398d0">bufsize</a>;  <span class="comment">/* The size of the input buffer. */</span>
A00193.html (components\net\uip\doc\html):<a name="l00140"></a>00140 <span class="comment"> * \param buffersize (unsigned int) The size of the input buffer.</span>
A00193.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00194.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00195.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00196.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00197.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00198.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00199.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00200.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00201.html (components\net\uip\doc\html):<a name="l00012"></a>00012 <span class="comment"> * code size is on the order of a few kilobytes and RAM usage is on</span>
A00201.html (components\net\uip\doc\html):<a name="l00059"></a>00059 <span class="comment"> * UDP, TCP and the application layers very tightly. To keep the size</span>
A00201.html (components\net\uip\doc\html):<a name="l00063"></a>00063 <span class="comment"> * size because of the overhead of parameter passing and the fact that</span>
A00201.html (components\net\uip\doc\html):<a name="l00158"></a>00158 <span class="comment">                                size. */</span>
A00201.html (components\net\uip\doc\html):<a name="l00207"></a><a class="code" href="a00150.html#g691688604655ea8943d15f14c60027d8">00207</a> <span class="preprocessor">#define TCP_OPT_MSS     2   </span><span class="comment">/* Maximum segment size TCP option */</span>
A00201.html (components\net\uip\doc\html):<a name="l00621"></a>00621 <span class="comment">       size of the entire packet. We also set the</span>
A00201.html (components\net\uip\doc\html):<a name="l00849"></a>00849   <span class="comment">/* Check the size of the packet. If the size reported to us in</span>
A00201.html (components\net\uip\doc\html):<a name="l00850"></a>00850 <span class="comment">     uip_len is smaller the size reported in the IP header, we assume</span>
A00201.html (components\net\uip\doc\html):<a name="l00851"></a>00851 <span class="comment">     that the packet has been corrupted in transit. If the size of</span>
A00201.html (components\net\uip\doc\html):<a name="l00852"></a>00852 <span class="comment">     uip_len is larger than the size reported in the IP packet header,</span>
A00201.html (components\net\uip\doc\html):<a name="l00862"></a>00862 <span class="comment">                      for holding the size of the entire packet,</span>
A00201.html (components\net\uip\doc\html):<a name="l00866"></a>00866 <span class="comment">                      for IPv6 we need to add the size of the IPv6</span>
A00201.html (components\net\uip\doc\html):<a name="l01611"></a>01611 <span class="comment">       set the current MSS to the window size to ensure that the</span>
A00201.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00202.html (components\net\uip\doc\html):<a name="l00402"></a>00402 <span class="comment"> * level headers and the TCP/IP headers from this buffer. The size of</span>
A00202.html (components\net\uip\doc\html):<a name="l00632"></a>00632 <span class="comment"> * present at the uip_appdata pointer. The size of the data is</span>
A00202.html (components\net\uip\doc\html):<a name="l00719"></a>00719 <span class="comment"> * Get the initial maxium segment size (MSS) of the current</span>
A00202.html (components\net\uip\doc\html):<a name="l00727"></a>00727 <span class="comment"> * Get the current maxium segment size that can be sent on the current</span>
A00202.html (components\net\uip\doc\html):<a name="l00730"></a>00730 <span class="comment"> * The current maxiumum segment size that can be sent on the</span>
A00202.html (components\net\uip\doc\html):<a name="l01165"></a><a class="code" href="a00088.html#3347ef1b6e8581402445d1a0280c7a14">01165</a>   <a class="code" href="a00153.html#g77570ac4fcab86864fa1916e55676da2">u16_t</a> <a class="code" href="a00088.html#3347ef1b6e8581402445d1a0280c7a14">mss</a>;          <span class="comment">/**&lt; Current maximum segment size for the</span>
A00202.html (components\net\uip\doc\html):<a name="l01167"></a><a class="code" href="a00088.html#db7a3fadb68df5fdd37e8b91a2c751ea">01167</a>   <a class="code" href="a00153.html#g77570ac4fcab86864fa1916e55676da2">u16_t</a> <a class="code" href="a00088.html#db7a3fadb68df5fdd37e8b91a2c751ea">initialmss</a>;   <span class="comment">/**&lt; Initial maximum segment size for the</span>
A00202.html (components\net\uip\doc\html):<a name="l01493"></a>01493 <span class="comment"> * The buffer size available for user data in the \ref uip_buf buffer.</span>
A00202.html (components\net\uip\doc\html):<a name="l01495"></a>01495 <span class="comment"> * This macro holds the available size for user data in the \ref</span>
A00202.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00203.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00204.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00205.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00206.html (components\net\uip\doc\html):<a name="l00148"></a>00148 <span class="comment"> * and the reassembly code size is approximately 700 bytes.  The</span>
A00206.html (components\net\uip\doc\html):<a name="l00149"></a>00149 <span class="comment"> * reassembly buffer is of the same size as the uip_buf buffer</span>
A00206.html (components\net\uip\doc\html):<a name="l00229"></a>00229 <span class="comment"> * option can be turned off to reduce the code size of uIP.</span>
A00206.html (components\net\uip\doc\html):<a name="l00300"></a>00300 <span class="comment"> * The TCP maximum segment size.</span>
A00206.html (components\net\uip\doc\html):<a name="l00308"></a>00308 <span class="comment"> * The size of the advertised receiver's window.</span>
A00206.html (components\net\uip\doc\html):<a name="l00310"></a>00310 <span class="comment"> * Should be set low (i.e., to the size of the uip_buf buffer) is the</span>
A00206.html (components\net\uip\doc\html):<a name="l00339"></a>00339 <span class="comment"> * The size of the ARP table.</span>
A00206.html (components\net\uip\doc\html):<a name="l00370"></a>00370 <span class="comment"> * The size of the uIP packet buffer.</span>
A00206.html (components\net\uip\doc\html):<a name="l00373"></a>00373 <span class="comment"> * not need to be larger than 1500 bytes. Lower size results in lower</span>
A00206.html (components\net\uip\doc\html):<a name="l00374"></a>00374 <span class="comment"> * TCP throughput, larger size results in higher TCP throughput.</span>
A00206.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
A00207.html (components\net\uip\doc\html):<a name="l00103"></a>00103 <span class="comment"> * uIP buffer size.</span>
A00207.html (components\net\uip\doc\html):</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
Adk.c (components\drivers\usb\usbhost\class):    rt_size_t size)
Adk.c (components\drivers\usb\usbhost\class):        buffer, size, 300);
Adk.c (components\drivers\usb\usbhost\class):    rt_size_t size)
Adk.c (components\drivers\usb\usbhost\class):        (void*)buffer, size, 300);
Afblue.pl (components\external\freetype\src\tools):my $curr_elem_size;    # The size of the current string or block.
Afcjk.c (components\external\freetype\src\autofit):        /*      Example: the `c' in cour.pfa at size 13     */
Afcjk.c (components\external\freetype\src\autofit):    /* compute the initial threshold as a fraction of the EM size */
Afcjk.c (components\external\freetype\src\autofit):    /* size < 3/4 pixels                                           */
Afcjk.c (components\external\freetype\src\autofit):          /* approach: we strengthen small stems, round stems whose size */
Aflatin.c (components\external\freetype\src\autofit):        ppem      = metrics->root.scaler.face->size->metrics.x_ppem;
Aflatin.c (components\external\freetype\src\autofit):            /* compute segment size */
Aflatin.c (components\external\freetype\src\autofit):        /*      Example: the `c' in cour.pfa at size 13     */
Aflatin.c (components\external\freetype\src\autofit):    /* size < 3/4 pixels                                           */
Aflatin.c (components\external\freetype\src\autofit):      /* compute the initial threshold as a fraction of the EM size */
Aflatin.c (components\external\freetype\src\autofit):          /* approach: we strengthen small stems, round stems whose size */
Aflatin2.c (components\external\freetype\src\autofit):        ppem      = metrics->root.scaler.face->size->metrics.x_ppem;
Aflatin2.c (components\external\freetype\src\autofit):     *  those that are less than a given size in pixels
Aflatin2.c (components\external\freetype\src\autofit):        /*      Example: the `c' in cour.pfa at size 13     */
Aflatin2.c (components\external\freetype\src\autofit):    /* compute the initial threshold as a fraction of the EM size */
Aflatin2.c (components\external\freetype\src\autofit):    /* size < 3/4 pixels                                           */
Aflatin2.c (components\external\freetype\src\autofit):          /* approach: we strengthen small stems, round stems whose size */
Afloader.c (components\external\freetype\src\autofit):    FT_Size       size   = face->size;
Afloader.c (components\external\freetype\src\autofit):    if ( !size )
Afloader.c (components\external\freetype\src\autofit):    scaler.x_scale = size->metrics.x_scale;
Afloader.c (components\external\freetype\src\autofit):    scaler.y_scale = size->metrics.y_scale;
Afmodule.c (components\external\freetype\src\autofit):                            FT_Size       size,
Afmodule.c (components\external\freetype\src\autofit):    FT_UNUSED( size );
Algorithm.txt (components\dfs\filesystems\jffs2\cyg\compress\src):size (except that the compressed data for one block must fit in
Algorithm.txt (components\dfs\filesystems\jffs2\cyg\compress\src):For inflate, which has 286 possible codes for the literal/length tree, the size
Algorithm.txt (components\dfs\filesystems\jffs2\cyg\compress\src):values, and the size of the first table is six bits.  Note that for each of
Algorithm.txt (components\dfs\filesystems\jffs2\cyg\compress\src):bits to gobble implicit in the size of the table.
Am33xx.h (libcpu\arm\am335x):/** Cache Line size in ARM Cortex-A8.                                         */
Analyze.c (components\external\sqlite-3.8.1\src):** the size of the blob is sizeof(void*) bytes). 
Annotated.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
Ansi2knr.c (components\external\jpeg):#define bufsize 5000			/* arbitrary size */
Api.h (components\net\lwip-1.3.2\src\include\lwip):                                   const void *dataptr, size_t size,
Api.h (components\net\lwip-1.4.1\src\include\lwip):err_t   netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
Api.h (components\net\lwip-1.4.1\src\include\lwip):#define netconn_write(conn, dataptr, size, apiflags) \
Api.h (components\net\lwip-1.4.1\src\include\lwip):          netconn_write_partly(conn, dataptr, size, apiflags, NULL)
Api.h (components\net\lwip-head\src\include\lwip):err_t   netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
Api.h (components\net\lwip-head\src\include\lwip):#define netconn_write(conn, dataptr, size, apiflags) \
Api.h (components\net\lwip-head\src\include\lwip):          netconn_write_partly(conn, dataptr, size, apiflags, NULL)
Api.h (components\net\lwip\src\include\lwip):err_t   netconn_write(struct netconn *conn, const void *dataptr, size_t size,
Api_lib.c (components\net\lwip-1.3.2\src\api): * @param size size of the application data to send
Api_lib.c (components\net\lwip-1.3.2\src\api):netconn_write(struct netconn *conn, const void *dataptr, size_t size, u8_t apiflags)
Api_lib.c (components\net\lwip-1.3.2\src\api):  msg.msg.msg.w.len = size;
Api_lib.c (components\net\lwip-1.4.1\src\api): * @param size size of the application data to send
Api_lib.c (components\net\lwip-1.4.1\src\api):netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
Api_lib.c (components\net\lwip-1.4.1\src\api):  if (size == 0) {
Api_lib.c (components\net\lwip-1.4.1\src\api):  msg.msg.msg.w.len = size;
Api_lib.c (components\net\lwip-1.4.1\src\api):      *bytes_written = size;
Api_lib.c (components\net\lwip-head\src\api): * @param size size of the application data to send
Api_lib.c (components\net\lwip-head\src\api):netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
Api_lib.c (components\net\lwip-head\src\api):  if (size == 0) {
Api_lib.c (components\net\lwip-head\src\api):  API_MSG_VAR_REF(msg).msg.msg.w.len = size;
Api_lib.c (components\net\lwip-head\src\api):      *bytes_written = size;
Api_lib.c (components\net\lwip\src\api): * @param size size of the application data to send
Api_lib.c (components\net\lwip\src\api):netconn_write(struct netconn *conn, const void *dataptr, size_t size, u8_t apiflags)
Api_lib.c (components\net\lwip\src\api):  if (size == 0) {
Api_lib.c (components\net\lwip\src\api):  /* @todo: for non-blocking write, check if 'size' would ever fit into
Api_lib.c (components\net\lwip\src\api):  msg.msg.msg.w.len = size;
Api_msg.c (components\net\lwip-1.3.2\src\api):  int size;
Api_msg.c (components\net\lwip-1.3.2\src\api):  size = DEFAULT_RAW_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.3.2\src\api):  size = 0; /* skip warning */
Api_msg.c (components\net\lwip-1.3.2\src\api):    size = DEFAULT_RAW_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.3.2\src\api):    size = DEFAULT_UDP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.3.2\src\api):    size = DEFAULT_TCP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.3.2\src\api):  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
Api_msg.c (components\net\lwip-1.4.1\src\api):  int size;
Api_msg.c (components\net\lwip-1.4.1\src\api):  size = DEFAULT_RAW_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.4.1\src\api):    size = DEFAULT_RAW_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.4.1\src\api):    size = DEFAULT_UDP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.4.1\src\api):    size = DEFAULT_TCP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-1.4.1\src\api):  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
Api_msg.c (components\net\lwip-head\src\api):  int size;
Api_msg.c (components\net\lwip-head\src\api):    size = DEFAULT_RAW_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-head\src\api):    size = DEFAULT_UDP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-head\src\api):    size = DEFAULT_TCP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip-head\src\api):  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
Api_msg.c (components\net\lwip\src\api):  int size;
Api_msg.c (components\net\lwip\src\api):  size = DEFAULT_RAW_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip\src\api):    size = DEFAULT_RAW_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip\src\api):    size = DEFAULT_UDP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip\src\api):    size = DEFAULT_TCP_RECVMBOX_SIZE;
Api_msg.c (components\net\lwip\src\api):  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
App_DispPic.c (components\emwin\emwintask):	uint32_t	size = (sizex*sizey)*3;//-- 由于是24为BMP位图，一个像素占3个字节,所以要乘以3
App_DispPic.c (components\emwin\emwintask):	BmpFileHeader.bfSize 	  = size + Header_num;//--文件大小,占四个字节
App_DispPic.c (components\emwin\emwintask):	BmpInfoHeader.biSizeImage = size; //--说明图象的大小(必须是4的倍数)，以字节为单位。
Arm_math.h (components\cmsis\include): * The structure specifies the size of the matrix and then points to
Arm_math.h (components\cmsis\include): * an array of data.  The array is of size <code>numRows X numCols</code>
Arm_math.h (components\cmsis\include): * By default all of the matrix functions perform size checking on the input and
Arm_math.h (components\cmsis\include): * columns.  If the size check fails the functions return:
Arm_math.h (components\cmsis\include): * There is some overhead associated with this matrix size checking.
Arm_math.h (components\cmsis\include): * The matrix size checking is enabled via the \#define
Arm_math.h (components\cmsis\include): * and size checking is enabled.  By changing the project settings and
Arm_math.h (components\cmsis\include): * undefining this macro size checking is eliminated and the functions
Arm_math.h (components\cmsis\include): * run a bit faster.  With size checking disabled the functions always
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
Arm_math.h (components\cmsis\include):    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
Arm_math.h (components\cmsis\include):    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
Arm_math.h (components\cmsis\include):    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
Arm_math.h (components\cmsis\include):    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
Arm_math.h (components\cmsis\include):    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
Arm_math.h (components\cmsis\include):    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
Arm_math.h (components\cmsis\include):    uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):    uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
Arm_math.h (components\cmsis\include):   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
Arm_math.h (components\cmsis\include):   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
Arm_math.h (components\cmsis\include):    float32_t mu;        /**< step size that controls filter coefficient updates. */
Arm_math.h (components\cmsis\include):   * @param[in] mu step size that controls filter coefficient updates.
Arm_math.h (components\cmsis\include):    q15_t mu;            /**< step size that controls filter coefficient updates. */
Arm_math.h (components\cmsis\include):   * @param[in] mu step size that controls filter coefficient updates.
Arm_math.h (components\cmsis\include):    q31_t mu;            /**< step size that controls filter coefficient updates. */
Arm_math.h (components\cmsis\include):   * @param[in] mu step size that controls filter coefficient updates.
Arm_math.h (components\cmsis\include):    float32_t mu;        /**< step size that control filter coefficient updates. */
Arm_math.h (components\cmsis\include):   * @param[in] mu step size that controls filter coefficient updates.
Arm_math.h (components\cmsis\include):    q31_t mu;             /**< step size that controls filter coefficient updates. */
Arm_math.h (components\cmsis\include):   * @param[in] mu step size that controls filter coefficient updates.
Arm_math.h (components\cmsis\include):    q15_t mu;            /**< step size that controls filter coefficient updates. */
Arm_math.h (components\cmsis\include):   * @param[in] mu step size that controls filter coefficient updates.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
Arm_math.h (components\cmsis\include):   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
Arm_math.h (components\cmsis\include):   * This function can support maximum of table size 2^12.
Arm_math.h (components\cmsis\include):   * This function can support maximum of table size 2^12.
Arm_math.h (components\cmsis\include):   * This function can support maximum of table size 2^12.
Arm_math.h (components\cmsis\include):   * and <code>pData</code> points to an array of size <code>numRows*numCols</code> values.
Asc12font.c (components\gui\src):   size: 224
Asm.h (libcpu\mips\common):		.size	function,.-function
Asm.h (libcpu\mips\common): * Global data declaration with size.
Asm.h (libcpu\mips\common):  	.size name,sz; 				\
Asm.h (libcpu\mips\common): * Weak data declaration with size.
Asm.h (libcpu\mips\common):  	.size name,sz; 				\
Asm.h (libcpu\mips\common): * Global data reference with size.
Asm.h (libcpu\mips\common):#define	IMPORT(name, size) 		\
Asm.h (libcpu\mips\common):	.extern	name,size
Asm.h (libcpu\mips\common):#define BSS(name,size) 			\
Asm.h (libcpu\mips\common):	.comm	name,size
Asm.h (libcpu\mips\common):#define LBSS(name,size) 		\
Asm.h (libcpu\mips\common):  	.lcomm	name,size
Asn1_dec.c (components\net\lwip-1.3.2\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Asn1_dec.c (components\net\lwip-1.4.1\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Asn1_dec.c (components\net\lwip-head\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Asn1_dec.c (components\net\lwip\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Asn1_enc.c (components\net\lwip-1.3.2\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Asn1_enc.c (components\net\lwip-1.4.1\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Asn1_enc.c (components\net\lwip-head\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Asn1_enc.c (components\net\lwip\src\core\snmp): * @todo not optimised (yet), favor correctness over speed, favor speed over size
Autohint.h (components\external\freetype\include\internal):  /*                 very slow to compute (even if the size of global      */
Autohint.h (components\external\freetype\include\internal):  /*    global_len   :: The size in bytes of the global hints.             */
Autohint.h (components\external\freetype\include\internal):                                  FT_Size        size,
Backup.c (components\external\sqlite-3.8.1\src):** Attempt to set the page size of the destination to match the page size
Backup.c (components\external\sqlite-3.8.1\src):  /* Backup is not possible if the page size of the destination is changing
Backup.c (components\external\sqlite-3.8.1\src):  int pgszSrc = 0;    /* Source page size */
Backup.c (components\external\sqlite-3.8.1\src):  int pgszDest = 0;   /* Destination page size */
Backup.c (components\external\sqlite-3.8.1\src):        ** size may be different to the source page size. 
Backup.c (components\external\sqlite-3.8.1\src):        ** If the source page size is smaller than the destination page size, 
Backup.c (components\external\sqlite-3.8.1\src):        ** fix the size of the file. However it is important to call
Backup.c (components\external\sqlite-3.8.1\src):          /* If the source page-size is smaller than the destination page-size,
Backup.c (components\external\sqlite-3.8.1\src):** The size of file pTo may be reduced by this operation. If anything 
Bdf.h (components\external\freetype\src\bdf):    int        size;
Bdf.h (components\external\freetype\src\bdf):    long             point_size;     /* Point size of the font.             */
Bdf.h (components\external\freetype\src\bdf):    /* The size of the next two arrays must be in sync with the */
Bdf.h (components\external\freetype\src\bdf):    /* size of the `have' array in the `bdf_parse_t' structure. */
Bdfdrivr.c (components\external\freetype\src\bdf):    FT_ULong          num_encodings; /* ftobjs.h: FT_CMap->clazz->size */
Bdfdrivr.c (components\external\freetype\src\bdf):          bsize->size =
Bdfdrivr.c (components\external\freetype\src\bdf):          bsize->size = bsize->width << 6;
Bdfdrivr.c (components\external\freetype\src\bdf):          bsize->y_ppem = bsize->size;
Bdfdrivr.c (components\external\freetype\src\bdf):  BDF_Size_Select( FT_Size   size,
Bdfdrivr.c (components\external\freetype\src\bdf):    bdf_font_t*  bdffont = ( (BDF_Face)size->face )->bdffont;
Bdfdrivr.c (components\external\freetype\src\bdf):    FT_Select_Metrics( size->face, strike_index );
Bdfdrivr.c (components\external\freetype\src\bdf):    size->metrics.ascender    = bdffont->font_ascent << 6;
Bdfdrivr.c (components\external\freetype\src\bdf):    size->metrics.descender   = -bdffont->font_descent << 6;
Bdfdrivr.c (components\external\freetype\src\bdf):    size->metrics.max_advance = bdffont->bbx.width << 6;
Bdfdrivr.c (components\external\freetype\src\bdf):  BDF_Size_Request( FT_Size          size,
Bdfdrivr.c (components\external\freetype\src\bdf):    FT_Face          face    = size->face;
Bdfdrivr.c (components\external\freetype\src\bdf):      return BDF_Size_Select( size, 0 );
Bdfdrivr.c (components\external\freetype\src\bdf):                  FT_Size       size,
Bdfdrivr.c (components\external\freetype\src\bdf):    BDF_Face     bdf    = (BDF_Face)FT_SIZE_FACE( size );
Bdflib.c (components\external\freetype\src\bdf):    ndp = bp + ( res % ht->size );
Bdflib.c (components\external\freetype\src\bdf):        ndp = bp + ( ht->size - 1 );
Bdflib.c (components\external\freetype\src\bdf):    int        i, sz = ht->size;
Bdflib.c (components\external\freetype\src\bdf):    ht->size <<= 1;
Bdflib.c (components\external\freetype\src\bdf):    ht->limit  = ht->size / 3;
Bdflib.c (components\external\freetype\src\bdf):    if ( FT_NEW_ARRAY( ht->table, ht->size ) )
Bdflib.c (components\external\freetype\src\bdf):    ht->size  = sz;
Bdflib.c (components\external\freetype\src\bdf):      int        i, sz = ht->size;
Bdflib.c (components\external\freetype\src\bdf):    unsigned long  size;
Bdflib.c (components\external\freetype\src\bdf):    if ( num_items > list->size )
Bdflib.c (components\external\freetype\src\bdf):      unsigned long  oldsize = list->size; /* same as _bdf_list_t.size */
Bdflib.c (components\external\freetype\src\bdf):      list->size = newsize;
Bdflib.c (components\external\freetype\src\bdf):    if ( list->size )
Bdflib.c (components\external\freetype\src\bdf):      if ( list->used == list->size )
Bdflib.c (components\external\freetype\src\bdf):    if ( list->used + final_empty >= list->size )
Bdflib.c (components\external\freetype\src\bdf):    /* initial size and allocation of the input buffer */
Bdflib.c (components\external\freetype\src\bdf):      /* otherwise p->have (a bitmap with static size) overflows. */
Bdflib.c (components\external\freetype\src\bdf):        /* Determine the point size of the glyph. */
Bitvec.c (components\external\sqlite-3.8.1\src):** The size of the bitmap is fixed when the object is created.
Bitvec.c (components\external\sqlite-3.8.1\src):** sometimes grow into tens of thousands or larger.  The size of the
Bitvec.c (components\external\sqlite-3.8.1\src):/* Round the union size down to the nearest pointer boundary, since that's how 
Bitvec.c (components\external\sqlite-3.8.1\src):** Setting this to the "natural word" size of your CPU may improve
Block_dev.c (components\drivers\sdio):                               rt_size_t   size)
Block_dev.c (components\drivers\sdio):    err = rt_mmcsd_req_blk(blk_dev->card, part->offset + pos, buffer, size, 0);
Block_dev.c (components\drivers\sdio):    return size;
Block_dev.c (components\drivers\sdio):                                rt_size_t   size)
Block_dev.c (components\drivers\sdio):    err = rt_mmcsd_req_blk(blk_dev->card, part->offset + pos, (void *)buffer, size, 1);
Block_dev.c (components\drivers\sdio):    return size;
Block_dev.c (components\drivers\sdio):        rt_kprintf("MMCSD: unable to set block size to %d: %d\n", cmd.arg, err);
Block_dev.c (components\drivers\sdio):                blk_dev->geometry.sector_count = blk_dev->part.size;
Block_dev.c (components\drivers\sdio):                    blk_dev->part.size   = 0;
Bmi055_sensor.cpp (components\drivers\sensors):int BMI055::read_buffer(rt_uint8_t reg, rt_uint8_t* value, rt_size_t size)
Bmi055_sensor.cpp (components\drivers\sensors):    msgs[1].len   = size;
Bmi055_sensor.h (components\drivers\sensors):    int read_buffer(rt_uint8_t reg, rt_uint8_t* value, rt_size_t size);
Board.h (bsp\stm32f407vgt6\drivers):// <o> Internal SRAM memory size[Kbytes] <8-96>
Btree.c (components\external\sqlite-3.8.1\src):** from the header of a btree page.  If the page size is 65536 and the page
Btree.c (components\external\sqlite-3.8.1\src):  /* The minimum size of any cell is 4 bytes. */
Btree.c (components\external\sqlite-3.8.1\src):  int size;                  /* Size of a cell */
Btree.c (components\external\sqlite-3.8.1\src):    size = cellSizePtr(pPage, &temp[pc]);
Btree.c (components\external\sqlite-3.8.1\src):    cbrk -= size;
Btree.c (components\external\sqlite-3.8.1\src):    if( cbrk<iCellFirst || pc+size>usableSize ){
Btree.c (components\external\sqlite-3.8.1\src):    assert( cbrk+size<=usableSize && cbrk>=iCellFirst );
Btree.c (components\external\sqlite-3.8.1\src):    testcase( cbrk+size==usableSize );
Btree.c (components\external\sqlite-3.8.1\src):    testcase( pc+size==usableSize );
Btree.c (components\external\sqlite-3.8.1\src):    memcpy(&data[cbrk], &temp[pc], size);
Btree.c (components\external\sqlite-3.8.1\src):  int usableSize; /* Usable size of the page */
Btree.c (components\external\sqlite-3.8.1\src):  assert( nByte>=0 );  /* Minimum cell size is 4 */
Btree.c (components\external\sqlite-3.8.1\src):      int size;            /* Size of the free slot */
Btree.c (components\external\sqlite-3.8.1\src):      size = get2byte(&data[pc+2]);
Btree.c (components\external\sqlite-3.8.1\src):      if( size>=nByte ){
Btree.c (components\external\sqlite-3.8.1\src):        int x = size - nByte;
Btree.c (components\external\sqlite-3.8.1\src):        }else if( size+pc > usableSize ){
Btree.c (components\external\sqlite-3.8.1\src):          /* The slot remains on the free-list. Reduce its size to account
Btree.c (components\external\sqlite-3.8.1\src):** and the size of the block is "size" bytes.
Btree.c (components\external\sqlite-3.8.1\src):static int freeSpace(MemPage *pPage, int start, int size){
Btree.c (components\external\sqlite-3.8.1\src):  assert( (start + size) <= (int)pPage->pBt->usableSize );
Btree.c (components\external\sqlite-3.8.1\src):  assert( size>=0 );   /* Minimum cell size is 4 */
Btree.c (components\external\sqlite-3.8.1\src):    memset(&data[start], 0, size);
Btree.c (components\external\sqlite-3.8.1\src):  put2byte(&data[start+2], size);
Btree.c (components\external\sqlite-3.8.1\src):  pPage->nFree = pPage->nFree + (u16)size;
Btree.c (components\external\sqlite-3.8.1\src):      u16 next, size;
Btree.c (components\external\sqlite-3.8.1\src):      size = get2byte(&data[pc+2]);
Btree.c (components\external\sqlite-3.8.1\src):      if( (next>0 && next<=pc+size+3) || pc+size>usableSize ){
Btree.c (components\external\sqlite-3.8.1\src):      nFree = nFree + size;
Btree.c (components\external\sqlite-3.8.1\src):    ** the cell-content area. If this is greater than the usable-size
Btree.c (components\external\sqlite-3.8.1\src):** Return the size of the database file in pages. If there is any kind of
Btree.c (components\external\sqlite-3.8.1\src):    ** the right size.  This is to guard against size changes that result
Btree.c (components\external\sqlite-3.8.1\src):    /* If the B-Tree was successfully opened, set the pager-cache size to the
Btree.c (components\external\sqlite-3.8.1\src):    ** do not change the pager-cache size.
Btree.c (components\external\sqlite-3.8.1\src):    ** a cell is less than 4 bytes in size, it is rounded up to 4 bytes
Btree.c (components\external\sqlite-3.8.1\src):** Change the default pages size and the number of reserved bytes per page.
Btree.c (components\external\sqlite-3.8.1\src):** Or, if the page size has already been fixed, return SQLITE_READONLY 
Btree.c (components\external\sqlite-3.8.1\src):** The page size must be a power of 2 between 512 and 65536.  If the page
Btree.c (components\external\sqlite-3.8.1\src):** size supplied does not meet this constraint then the page size is not
Btree.c (components\external\sqlite-3.8.1\src):** If the iFix!=0 then the BTS_PAGESIZE_FIXED flag is set so that the page size
Btree.c (components\external\sqlite-3.8.1\src):** Return the currently defined page size
Btree.c (components\external\sqlite-3.8.1\src):      /* After reading the first page of the database assuming a page size
Btree.c (components\external\sqlite-3.8.1\src):      ** of BtShared.pageSize, we have discovered that the page-size is
Btree.c (components\external\sqlite-3.8.1\src):      ** again with the correct page-size.
Btree.c (components\external\sqlite-3.8.1\src):    ** reading page 1 it discovers that the page-size of the database 
Btree.c (components\external\sqlite-3.8.1\src):    ** pBt->pageSize to the page-size of the file on disk.
Btree.c (components\external\sqlite-3.8.1\src):      /* If the db-size header field is incorrect (as it may be if an old
Btree.c (components\external\sqlite-3.8.1\src):      ** this sooner rather than later means the database size can safely 
Btree.c (components\external\sqlite-3.8.1\src):      ** re-read the database size from page 1 if a savepoint or transaction
Btree.c (components\external\sqlite-3.8.1\src):** nOrig pages in size containing nFree free pages. Return the expected 
Btree.c (components\external\sqlite-3.8.1\src):** size of the database in pages following an auto-vacuum operation.
Btree.c (components\external\sqlite-3.8.1\src):    Pgno nOrig;        /* Database size before freeing */
Btree.c (components\external\sqlite-3.8.1\src):      /* The database size was written into the offset 28 of the header
Btree.c (components\external\sqlite-3.8.1\src):** Return the size of a BtCursor object in bytes.
Btree.c (components\external\sqlite-3.8.1\src):** Set *pSize to the size of the buffer needed to hold the value of
Btree.c (components\external\sqlite-3.8.1\src):        /* The maximum supported page-size is 65536 bytes. This means that
Btree.c (components\external\sqlite-3.8.1\src):          /* This branch runs if the record-size field of the cell is a
Btree.c (components\external\sqlite-3.8.1\src):          /* The record-size field is a 2 byte varint and the record 
Btree.c (components\external\sqlite-3.8.1\src):  Pgno mxPage;     /* Total size of the database file */
Btree.c (components\external\sqlite-3.8.1\src):  int *pnSize                    /* Write cell size here */
Btree.c (components\external\sqlite-3.8.1\src):  ** malformed cell from a leaf page to an interior page, if the cell size
Btree.c (components\external\sqlite-3.8.1\src):  ** wanted to be less than 4 but got rounded up to 4 on the leaf, then size
Btree.c (components\external\sqlite-3.8.1\src):  ** might be less than 8 (leaf-size + pointer) on the interior node.  Hence
Btree.c (components\external\sqlite-3.8.1\src):  const int nUsable = pPage->pBt->usableSize; /* Usable size of page */
Btree.c (components\external\sqlite-3.8.1\src):** least 13 bytes in size.
Btree.c (components\external\sqlite-3.8.1\src):    ** record-length (a variable length integer at most 32-bits in size)
Btree.c (components\external\sqlite-3.8.1\src):** size of a cell stored within an internal node is always less than 1/4
Btree.c (components\external\sqlite-3.8.1\src):** of the page-size, the aOvflSpace[] buffer is guaranteed to be large
Btree.c (components\external\sqlite-3.8.1\src):  u8 *aOvflSpace,                 /* page-size bytes of space for parent ovfl */
Btree.c (components\external\sqlite-3.8.1\src):  int nMaxCells = 0;           /* Allocated size of apCell, szCell, aFrom. */
Btree.c (components\external\sqlite-3.8.1\src):  int szNew[NB+2];             /* Combined size of cells place on i-th page */
Btree.c (components\external\sqlite-3.8.1\src):  u16 *szCell;                 /* Local size of all cells in apCell[] */
Btree.c (components\external\sqlite-3.8.1\src):  ** size of all cells on the i-th page and cntNew[] which is the index
Btree.c (components\external\sqlite-3.8.1\src):        ** previously stored on a leaf node, and its reported size was 4
Btree.c (components\external\sqlite-3.8.1\src):        ** (see btreeParseCellPtr(), 4 bytes is the minimum size of
Btree.c (components\external\sqlite-3.8.1\src):        ** any cell). But it is important to pass the correct size to 
Btree.c (components\external\sqlite-3.8.1\src):      u32 size = 65536;
Btree.c (components\external\sqlite-3.8.1\src):        size = cellSizePtr(pPage, &data[pc]);
Btree.c (components\external\sqlite-3.8.1\src):      if( (int)(pc+size-1)>=usableSize ){
Btree.c (components\external\sqlite-3.8.1\src):        for(j=pc+size-1; j>=pc; j--) hit[j]++;
Btree.c (components\external\sqlite-3.8.1\src):      int size, j;
Btree.c (components\external\sqlite-3.8.1\src):      size = get2byte(&data[i+2]);
Btree.c (components\external\sqlite-3.8.1\src):      assert( i+size<=usableSize );  /* Enforced by btreeInitPage() */
Btree.c (components\external\sqlite-3.8.1\src):      for(j=i+size-1; j>=i; j--) hit[j]++;
Btree.c (components\external\sqlite-3.8.1\src):      assert( j==0 || j>i+size );  /* Enforced by btreeInitPage() */
btreeInt.h (components\external\sqlite-3.8.1\src):** information such as the size of key and data.
btreeInt.h (components\external\sqlite-3.8.1\src):** "no such page".  The page size can be any power of 2 between 512 and 65536.
btreeInt.h (components\external\sqlite-3.8.1\src):**     16       2     Page size in bytes.  (1 means 65536)
btreeInt.h (components\external\sqlite-3.8.1\src):** is to limit the maximum cell size so that at least 4 cells will fit
btreeInt.h (components\external\sqlite-3.8.1\src):** the cell size drop below the min embedded payload fraction.
btreeInt.h (components\external\sqlite-3.8.1\src):** which is stored in the key size entry of the cell header rather than in
btreeInt.h (components\external\sqlite-3.8.1\src):** freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
btreeInt.h (components\external\sqlite-3.8.1\src):** increasing order.  Because a freeblock must be at least 4 bytes in size,
btreeInt.h (components\external\sqlite-3.8.1\src):/* The following value is the maximum cell size assuming a maximum page
btreeInt.h (components\external\sqlite-3.8.1\src):** size give above.
btreeInt.h (components\external\sqlite-3.8.1\src):** assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
btreeInt.h (components\external\sqlite-3.8.1\src):#define BTS_PAGESIZE_FIXED   0x0002   /* Page size can no longer be changed */
btreeInt.h (components\external\sqlite-3.8.1\src):** maximum database size of 2^31 pages a minimum fanout of 2 for a
Build.c (components\dfs\filesystems\jffs2\src):	uint32_t size;
Build.c (components\dfs\filesystems\jffs2\src):	size = c->flash_size / 50; /* 2% of flash size */
Build.c (components\dfs\filesystems\jffs2\src):	size += c->nr_blocks * 100; /* And 100 bytes per eraseblock */
Build.c (components\dfs\filesystems\jffs2\src):	size += c->sector_size - 1; /* ... and round up */
Build.c (components\dfs\filesystems\jffs2\src):	c->resv_blocks_write = c->resv_blocks_deletion + (size / c->sector_size);
Build.c (components\dfs\filesystems\jffs2\src):	D1(printk(KERN_DEBUG "JFFS2 trigger levels (size %d KiB, block size %d KiB, %d blocks)\n",
Build.c (components\external\sqlite-3.8.1\src):** db->aDb[] structure to a smaller size, if possible.
Build.c (components\external\sqlite-3.8.1\src):  /* If pszEst is not NULL, store an estimate of the field size.  The
Build.c (components\external\sqlite-3.8.1\src):  ** estimate is scaled so that the size of an integer is 1.  */
Build.c (components\external\sqlite-3.8.1\src):    *pszEst = 1;   /* default size is approx 4 bytes */
Build.c (components\external\sqlite-3.8.1\src):** Estimate the average size of a row for an index.
Build.c (components\external\sqlite-3.8.1\src):  /* Estimate the average row size for the table and for all implied indices */
Build.c (components\external\sqlite-3.8.1\src):** array is szEntry bytes in size. This routine uses sqlite3DbRealloc()
Build.c (components\external\sqlite-3.8.1\src):** When this function is called, *pnEntry contains the current size of
Build.c (components\external\sqlite-3.8.1\src):** reflect the new size of the array and a pointer to the new allocation
Cache.c (libcpu\mips\common):void r4k_icache_flush_range(rt_ubase_t addr, rt_ubase_t size)
Cache.c (libcpu\mips\common):    if (size > icache_size)
Cache.c (libcpu\mips\common):        end = ((addr + size) - 1) & ~(ic_lsize - 1);
Cache.c (libcpu\mips\common):void r4k_icache_lock_range(rt_ubase_t addr, rt_ubase_t size)
Cache.c (libcpu\mips\common):    end = ((addr + size) - 1) & ~(ic_lsize - 1);
Cache.c (libcpu\mips\common):void r4k_dcache_inv(rt_ubase_t addr, rt_ubase_t size)
Cache.c (libcpu\mips\common):    end = ((addr + size) - 1) & ~(dc_lsize - 1);
Cache.c (libcpu\mips\common):void r4k_dcache_wback_inv(rt_ubase_t addr, rt_ubase_t size)
Cache.c (libcpu\mips\common):    if (size >= dcache_size)
Cache.c (libcpu\mips\common):        end = ((addr + size) - 1) & ~(dc_lsize - 1);
Cache.c (libcpu\mips\loongson_1b):void invalidate_writeback_dcache(unsigned long addr, int size)
Cache.c (libcpu\mips\loongson_1b):	end = (end + size + pcacheinfo->dcacheline_size -1) & ( -pcacheinfo->dcacheline_size);
Cache.c (libcpu\mips\loongson_1c):void invalidate_writeback_dcache(unsigned long addr, int size)
Cache.c (libcpu\mips\loongson_1c):	end = (end + size + pcacheinfo->dcacheline_size -1) & ( -pcacheinfo->dcacheline_size);
Cache.h (libcpu\mips\common):void r4k_icache_flush_range(rt_ubase_t addr, rt_ubase_t size);
Cache.h (libcpu\mips\common):void r4k_icache_lock_range(rt_ubase_t addr, rt_ubase_t size);
Cache.h (libcpu\mips\common):void r4k_dcache_inv(rt_ubase_t addr, rt_ubase_t size);
Cache.h (libcpu\mips\common):void r4k_dcache_wback_inv(rt_ubase_t addr, rt_ubase_t size);
Can.c (components\drivers\can):    int size;
Can.c (components\drivers\can):    size = msgs;
Can.c (components\drivers\can):    return (size - msgs);
Can.c (components\drivers\can):    int size;
Can.c (components\drivers\can):    size = msgs;
Can.c (components\drivers\can):    return (size - msgs);
Can.c (components\drivers\can):    int size;
Can.c (components\drivers\can):    size = msgs;
Can.c (components\drivers\can):    return (size - msgs);
Can.c (components\drivers\can):                             rt_size_t         size)
Can.c (components\drivers\can):    if (size == 0) return 0;
Can.c (components\drivers\can):        return _can_int_rx(can, buffer, size);
Can.c (components\drivers\can):                              rt_size_t         size)
Can.c (components\drivers\can):    if (size == 0) return 0;
Can.c (components\drivers\can):            return _can_int_tx_priv(can, buffer, size);
Can.c (components\drivers\can):            return _can_int_tx(can, buffer, size);
Can.h (components\drivers\include\drivers):    rt_err_t (*ind)(rt_device_t dev, void *args , rt_int32_t hdr, rt_size_t size);
Ccp.c (components\net\lwip-head\src\netif\ppp): * size of 8 (window size = 256) for Deflate compression will cause
Ccp.c (components\net\lwip-head\src\netif\ppp):	 * Peer wants us to use a different code size or something.
Ccp.c (components\net\lwip-head\src\netif\ppp):		 * size they want.  If the window is too big, reduce
Ccp.c (components\net\lwip-head\src\netif\ppp):		 * size they want.  If the code size is too big, reduce
Ccp.h (components\net\lwip-head\src\include\netif\ppp):    u_short deflate_size;	/* lg(window size) for Deflate */
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    rt_size_t size;
Cdc_vcom.c (components\drivers\usb\usbdevice\class): * @param size request size.
Cdc_vcom.c (components\drivers\usb\usbdevice\class):static rt_err_t _ep_in_handler(ufunction_t func, rt_size_t size)
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    RT_DEBUG_LOG(RT_DEBUG_USB, ("_ep_in_handler %d\n", size));
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    if ((size != 0) && (size % CDC_MAX_PACKET_SIZE == 0))
Cdc_vcom.c (components\drivers\usb\usbdevice\class):        data->ep_in->request.size = 0;
Cdc_vcom.c (components\drivers\usb\usbdevice\class): * @param size request size.
Cdc_vcom.c (components\drivers\usb\usbdevice\class):static rt_err_t _ep_out_handler(ufunction_t func, rt_size_t size)
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    RT_DEBUG_LOG(RT_DEBUG_USB, ("_ep_out_handler %d\n", size));
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    rt_ringbuffer_put(&data->rx_ringbuffer, data->ep_out->buffer, size);
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    data->ep_out->request.size = EP_MAXPACKET(data->ep_out);
Cdc_vcom.c (components\drivers\usb\usbdevice\class): * @param size request size.
Cdc_vcom.c (components\drivers\usb\usbdevice\class):static rt_err_t _ep_cmd_handler(ufunction_t func, rt_size_t size)
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    rt_uint16_t size;
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    size = setup->length > 7 ? 7 : setup->length;
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    rt_usbd_ep0_write(device, (void*)&data, size);
Cdc_vcom.c (components\drivers\usb\usbdevice\class):static rt_err_t _cdc_set_line_coding_callback(udevice_t device, rt_size_t size)
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    data->ep_out->request.size = EP_MAXPACKET(data->ep_out);
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    const char *buf, rt_size_t size)
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    msg.size = size;
Cdc_vcom.c (components\drivers\usb\usbdevice\class):    return size;
Cdc_vcom.c (components\drivers\usb\usbdevice\class):            data->ep_in->request.size = msg.size;
Cf2arrst.c (components\external\freetype\src\cff):  /* allocate or reallocate the buffer size; */
Cf2arrst.c (components\external\freetype\src\cff):      FT_ASSERT( newSize > 0 );   /* avoid realloc with zero size */
Cf2font.c (components\external\freetype\src\cff):      /* TODO: testing size-dependent darkening here;                    */
Cf2ft.c (components\external\freetype\src\cff):   * at EM size, scaling it and filling it as a graphics operation.
Cf2ft.c (components\external\freetype\src\cff):               decoder->builder.face->root.size );
Cf2ft.c (components\external\freetype\src\cff):             decoder->builder.face->root.size->metrics.y_ppem );
Cffdrivr.c (components\external\freetype\src\cff):  /*    size        :: A handle to the source face size at which the glyph */
Cffdrivr.c (components\external\freetype\src\cff):    CFF_Size       size = (CFF_Size)cffsize;
Cffdrivr.c (components\external\freetype\src\cff):    if ( !size )
Cffdrivr.c (components\external\freetype\src\cff):    /* reset the size object if necessary */
Cffdrivr.c (components\external\freetype\src\cff):      size = NULL;
Cffdrivr.c (components\external\freetype\src\cff):    if ( size )
Cffdrivr.c (components\external\freetype\src\cff):    error = cff_slot_load( slot, size, glyph_index, load_flags );
Cffdrivr.c (components\external\freetype\src\cff):      error = cff_glyph_load( slot, face->size, start + nn, flags );
Cffgload.c (components\external\freetype\src\cff):  /*    size    :: The current size object.                                */
Cffgload.c (components\external\freetype\src\cff):                    CFF_Size       size,
Cffgload.c (components\external\freetype\src\cff):      if ( hinting && size )
Cffgload.c (components\external\freetype\src\cff):        CFF_Internal  internal = (CFF_Internal)size->root.internal;
Cffgload.c (components\external\freetype\src\cff):  /*    size      :: The current size object.                              */
Cffgload.c (components\external\freetype\src\cff):                    CFF_Size        size,
Cffgload.c (components\external\freetype\src\cff):    cff_builder_init( &decoder->builder, face, size, slot, hinting );
Cffgload.c (components\external\freetype\src\cff):                       CFF_Size      size,
Cffgload.c (components\external\freetype\src\cff):      if ( builder->hints_funcs && size )
Cffgload.c (components\external\freetype\src\cff):        CFF_Internal  internal = (CFF_Internal)size->root.internal;
Cffgload.c (components\external\freetype\src\cff):        error = cff_decoder_prepare( &decoder, size, glyph_index );
Cffgload.c (components\external\freetype\src\cff):                 CFF_Size       size,
Cffgload.c (components\external\freetype\src\cff):    if ( size )
Cffgload.c (components\external\freetype\src\cff):      glyph->x_scale = size->root.metrics.x_scale;
Cffgload.c (components\external\freetype\src\cff):      glyph->y_scale = size->root.metrics.y_scale;
Cffgload.c (components\external\freetype\src\cff):    if ( size )
Cffgload.c (components\external\freetype\src\cff):      CFF_Face      cff_face = (CFF_Face)size->root.face;
Cffgload.c (components\external\freetype\src\cff):      if ( size->strike_index != 0xFFFFFFFFUL      &&
Cffgload.c (components\external\freetype\src\cff):                                       size->strike_index,
Cffgload.c (components\external\freetype\src\cff):      cff_decoder_init( &decoder, face, size, glyph, hinting,
Cffgload.c (components\external\freetype\src\cff):      error = cff_decoder_prepare( &decoder, size, glyph_index );
Cffgload.c (components\external\freetype\src\cff):        if ( size && size->root.metrics.y_ppem < 24 )
Cffgload.h (components\external\freetype\src\cff):                    CFF_Size        size,
Cffgload.h (components\external\freetype\src\cff):                       CFF_Size      size,
Cffgload.h (components\external\freetype\src\cff):                 CFF_Size       size,
Cffload.c (components\external\freetype\src\cff):      FT_ULong  size;
Cffload.c (components\external\freetype\src\cff):      /* there is at least one element; read the offset size,           */
Cffload.c (components\external\freetype\src\cff):      /* then access the offset table to compute the index's total size */
Cffload.c (components\external\freetype\src\cff):      size          = (FT_ULong)( count + 1 ) * offsize;
Cffload.c (components\external\freetype\src\cff):      idx->data_offset = idx->start + 3 + size;
Cffload.c (components\external\freetype\src\cff):      if ( FT_STREAM_SKIP( size - offsize ) )
Cffload.c (components\external\freetype\src\cff):      size = cff_index_read_offset( idx, &error );
Cffload.c (components\external\freetype\src\cff):      if ( size == 0 )
Cffload.c (components\external\freetype\src\cff):      idx->data_size = --size;
Cffload.c (components\external\freetype\src\cff):        if ( FT_FRAME_EXTRACT( size, idx->bytes ) )
Cffload.c (components\external\freetype\src\cff):        if ( FT_STREAM_SKIP( size ) )
Cffload.c (components\external\freetype\src\cff):      if ( off2 > stream->size + 1                    ||
Cffload.c (components\external\freetype\src\cff):           idx->data_offset > stream->size - off2 + 1 )
Cffload.c (components\external\freetype\src\cff):                   off2, stream->size - idx->data_offset + 1 ));
Cffload.c (components\external\freetype\src\cff):        off2 = stream->size - idx->data_offset + 1;
Cffload.c (components\external\freetype\src\cff):      /* we need to parse the table to determine its size */
Cffobjs.c (components\external\freetype\src\cff):  /*  Note that we store the global hints in the size's `internal' root    */
Cffobjs.c (components\external\freetype\src\cff):  cff_size_get_globals_funcs( CFF_Size  size )
Cffobjs.c (components\external\freetype\src\cff):    CFF_Face          face     = (CFF_Face)size->root.face;
Cffobjs.c (components\external\freetype\src\cff):    module = FT_Get_Module( size->root.face->driver->root.library,
Cffobjs.c (components\external\freetype\src\cff):    CFF_Size      size     = (CFF_Size)cffsize;
Cffobjs.c (components\external\freetype\src\cff):    CFF_Face      face     = (CFF_Face)size->root.face;
Cffobjs.c (components\external\freetype\src\cff):      funcs = cff_size_get_globals_funcs( size );
Cffobjs.c (components\external\freetype\src\cff):    CFF_Size           size  = (CFF_Size)cffsize;
Cffobjs.c (components\external\freetype\src\cff):    PSH_Globals_Funcs  funcs = cff_size_get_globals_funcs( size );
Cffobjs.c (components\external\freetype\src\cff):    size->strike_index = 0xFFFFFFFFUL;
Cffobjs.c (components\external\freetype\src\cff):  cff_size_select( FT_Size   size,
Cffobjs.c (components\external\freetype\src\cff):    CFF_Size           cffsize = (CFF_Size)size;
Cffobjs.c (components\external\freetype\src\cff):    FT_Select_Metrics( size->face, strike_index );
Cffobjs.c (components\external\freetype\src\cff):      CFF_Face      face     = (CFF_Face)size->face;
Cffobjs.c (components\external\freetype\src\cff):      CFF_Internal  internal = (CFF_Internal)size->internal;
Cffobjs.c (components\external\freetype\src\cff):                        size->metrics.x_scale, size->metrics.y_scale,
Cffobjs.c (components\external\freetype\src\cff):          x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
Cffobjs.c (components\external\freetype\src\cff):          y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
Cffobjs.c (components\external\freetype\src\cff):          x_scale = size->metrics.x_scale;
Cffobjs.c (components\external\freetype\src\cff):          y_scale = size->metrics.y_scale;
Cffobjs.c (components\external\freetype\src\cff):  cff_size_request( FT_Size          size,
Cffobjs.c (components\external\freetype\src\cff):    CFF_Size           cffsize = (CFF_Size)size;
Cffobjs.c (components\external\freetype\src\cff):    if ( FT_HAS_FIXED_SIZES( size->face ) )
Cffobjs.c (components\external\freetype\src\cff):      CFF_Face      cffface = (CFF_Face)size->face;
Cffobjs.c (components\external\freetype\src\cff):        return cff_size_select( size, strike_index );
Cffobjs.c (components\external\freetype\src\cff):    FT_Request_Metrics( size->face, req );
Cffobjs.c (components\external\freetype\src\cff):      CFF_Face      cffface  = (CFF_Face)size->face;
Cffobjs.c (components\external\freetype\src\cff):      CFF_Internal  internal = (CFF_Internal)size->internal;
Cffobjs.c (components\external\freetype\src\cff):                        size->metrics.x_scale, size->metrics.y_scale,
Cffobjs.c (components\external\freetype\src\cff):          x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
Cffobjs.c (components\external\freetype\src\cff):          y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
Cffobjs.c (components\external\freetype\src\cff):          x_scale = size->metrics.x_scale;
Cffobjs.c (components\external\freetype\src\cff):          y_scale = size->metrics.y_scale;
Cffobjs.c (components\external\freetype\src\cff):        /* set global bbox, as well as EM size */
Cffobjs.h (components\external\freetype\src\cff):  /*    A handle to an OpenType size object.                               */
Cffobjs.h (components\external\freetype\src\cff):  cff_size_init( FT_Size  size );           /* CFF_Size */
Cffobjs.h (components\external\freetype\src\cff):  cff_size_done( FT_Size  size );           /* CFF_Size */
Cffobjs.h (components\external\freetype\src\cff):  cff_size_request( FT_Size          size,
Cffobjs.h (components\external\freetype\src\cff):  cff_size_select( FT_Size   size,
Cffparse.c (components\external\freetype\src\cff):          clazz[i].size         = 0;                   \
Cffparse.c (components\external\freetype\src\cff):          clazz[i].size         = FT_FIELD_SIZE( name_ );   \
Cffparse.c (components\external\freetype\src\cff):          clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \
Cffparse.c (components\external\freetype\src\cff):    clazz[i].size         = 0;
Cffparse.c (components\external\freetype\src\cff):          clazz[i].size         = 0;                   \
Cffparse.c (components\external\freetype\src\cff):          clazz[i].size         = FT_FIELD_SIZE( name_ );   \
Cffparse.c (components\external\freetype\src\cff):          clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \
Cffparse.c (components\external\freetype\src\cff):    clazz[i].size         = 0;
Cffparse.c (components\external\freetype\src\cff):              switch ( field->size )
Cffparse.c (components\external\freetype\src\cff):                  switch ( field->size )
Cffparse.c (components\external\freetype\src\cff):                  q += field->size;
Cffparse.h (components\external\freetype\src\cff):    FT_Byte           size;
Cfftypes.h (components\external\freetype\src\cff):  /*    off_size    :: The size in bytes of object offsets in index.       */
Cfftypes.h (components\external\freetype\src\cff):  /*    data_size   :: The size of the data table in this index.           */
CHANGELOG.txt (components\external\nanopb): Add #defines for maximum encoded message size (issue 89)
CHANGELOG.txt (components\external\nanopb): Add buffer size check in example (issue 34)
Changelog.txt (components\net\freemodbus):       porting layer which allows specifing the stack size.
Cidgload.c (components\external\freetype\src\cid):                                           0, /* size       */
Cidgload.h (components\external\freetype\src\cid):                       FT_Size       size,          /* CID_Size       */
Cidload.c (components\external\freetype\src\cid):                  FT_Long      size )
Cidload.c (components\external\freetype\src\cid):    parser->root.limit  = base + size;
Cidload.c (components\external\freetype\src\cid):      FT_Byte*  limit = cur + size;
Cidload.c (components\external\freetype\src\cid):      /* now, compute the size of subrs charstrings, */
Cidload.c (components\external\freetype\src\cid):        FT_ULong  size   = stream->size - oldpos;
Cidload.c (components\external\freetype\src\cid):        if ( size == 0 )
Cidload.c (components\external\freetype\src\cid):        if ( FT_STREAM_READ( buffer, 256 > size ? size : 256 ) )
Cidobjs.c (components\external\freetype\src\cid):  cid_size_get_globals_funcs( CID_Size  size )
Cidobjs.c (components\external\freetype\src\cid):    CID_Face          face     = (CID_Face)size->root.face;
Cidobjs.c (components\external\freetype\src\cid):    module = FT_Get_Module( size->root.face->driver->root.library,
Cidobjs.c (components\external\freetype\src\cid):    CID_Size  size = (CID_Size)cidsize;
Cidobjs.c (components\external\freetype\src\cid):      funcs = cid_size_get_globals_funcs( size );
Cidobjs.c (components\external\freetype\src\cid):    CID_Size           size  = (CID_Size)cidsize;
Cidobjs.c (components\external\freetype\src\cid):    PSH_Globals_Funcs  funcs = cid_size_get_globals_funcs( size );
Cidobjs.c (components\external\freetype\src\cid):  cid_size_request( FT_Size          size,
Cidobjs.c (components\external\freetype\src\cid):    FT_Request_Metrics( size->face, req );
Cidobjs.c (components\external\freetype\src\cid):    funcs = cid_size_get_globals_funcs( (CID_Size)size );
Cidobjs.c (components\external\freetype\src\cid):      funcs->set_scale( (PSH_Globals)size->internal,
Cidobjs.c (components\external\freetype\src\cid):                        size->metrics.x_scale,
Cidobjs.c (components\external\freetype\src\cid):                        size->metrics.y_scale,
Cidobjs.h (components\external\freetype\src\cid):  /*    A handle to a Type 1 size object.                                  */
Cidobjs.h (components\external\freetype\src\cid):  cid_size_done( FT_Size  size );       /* CID_Size */
Cidobjs.h (components\external\freetype\src\cid):  cid_size_init( FT_Size  size );       /* CID_Size */
Cidobjs.h (components\external\freetype\src\cid):  cid_size_request( FT_Size          size,      /* CID_Size */
Cidparse.c (components\external\freetype\src\cid):      FT_Long   read_len = 256 + 10; /* same as signed FT_Stream->size */
Cidparse.c (components\external\freetype\src\cid):        FT_Long  stream_len; /* same as signed FT_Stream->size */
Cidparse.c (components\external\freetype\src\cid):        stream_len = stream->size - FT_STREAM_POS();
Cjpeg.c (components\external\jpeg):  /* Read the input file header to obtain file size & colorspace. */
Classes.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
Clnt.h (components\dfs\filesystems\nfs\rpc):#define UDPMSGSIZE	8800	/* rpc imposed limit on udp msg size */
Clnt.h (components\dfs\filesystems\nfs\rpc):#define RPCSMALLMSGSIZE	400	/* a more reasonable packet size */
Cmd.c (components\finsh):    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
Cmd.c (components\finsh):    rt_kprintf("mailbox  entry size suspend thread\n");
Cmd.c (components\finsh):                       m->size,
Cmd.c (components\finsh):                       m->size,
Cmd.c (components\finsh):    rt_kprintf("memheap  pool size  max used size available size\n");
Cmd.c (components\finsh):                rt_kprintf("main thread  pri  status      sp     stack size max used   left tick  error\n");
Cmsis_os.h (components\cmsis\rtos):  os_status_reserved      =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
Cmsis_os.h (components\cmsis\rtos):	rt_size_t size;
Cmsis_os.h (components\cmsis\rtos):/// \param         stacksz      stack size (in bytes) requirements for the thread function.
Cmsis_rtthread.c (components\cmsis\rtos):    int size;
Cmsis_rtthread.c (components\cmsis\rtos):    size = thread_def->stack_size;
Cmsis_rtthread.c (components\cmsis\rtos):    if (size == 0)
Cmsis_rtthread.c (components\cmsis\rtos):        size = 4096;
Cmsis_rtthread.c (components\cmsis\rtos):    thread = rt_thread_create(thread_def->name, thread_def->entry, argument, size, thread_def->priority, thread_def->tick);
Compr.c (components\dfs\filesystems\jffs2\src): *	data. On exit, expected to hold the actual size of the compressed
Compr.c (components\dfs\filesystems\jffs2\src):                return "size";
Compr.c (components\dfs\filesystems\jffs2\src):        if (!strcmp("size",name)) {
Compr.c (components\dfs\filesystems\jffs2\src):        D1(printk(KERN_INFO "JFFS2: default compression mode: size\n");)
Compr.h (components\dfs\filesystems\jffs2\src):        unsigned char *compr_buf;  /* used by size compr. mode */
Compr.h (components\dfs\filesystems\jffs2\src):        uint32_t compr_buf_size;   /* used by size compr. mode */
Compress.c (components\dfs\filesystems\jffs2\cyg\compress\src):   length of the source buffer. Upon entry, destLen is the total size of the
Compress.c (components\dfs\filesystems\jffs2\cyg\compress\src):   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
Compress.c (components\external\libz):   length of the source buffer. Upon entry, destLen is the total size of the
Compress.c (components\external\libz):   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
Compr_rtime.c (components\dfs\filesystems\jffs2\src):/* _compress returns the compressed size, -1 if bigger */
Compr_rubin.c (components\dfs\filesystems\jffs2\src):/* _compress returns the compressed size, -1 if bigger */
Console.c (components\dfs\filesystems\devfs):static rt_size_t console_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size)
Console.c (components\dfs\filesystems\devfs):	return rt_device_read(device->device, pos, buffer, size);
Console.c (components\dfs\filesystems\devfs):static rt_size_t console_write(rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size)
Console.c (components\dfs\filesystems\devfs):	return rt_device_write(device->device, pos, buffer, size);
Const.c (components\external\espruino\libs\math): * also some needed size parameters of the computer arithmetic.
Const.c (components\external\espruino\libs\math): * The default size parameters are as follows.
Core.c (components\drivers\usb\usbdevice\core):static rt_size_t rt_usbd_ep_write(udevice_t device, uep_t ep, void *buffer, rt_size_t size);
Core.c (components\drivers\usb\usbdevice\core):static rt_size_t rt_usbd_ep_read_prepare(udevice_t device, uep_t ep, void *buffer, rt_size_t size);
Core.c (components\drivers\usb\usbdevice\core):    rt_size_t size;
Core.c (components\drivers\usb\usbdevice\core):    size = (setup->length > USB_DESC_LENGTH_DEVICE) ?
Core.c (components\drivers\usb\usbdevice\core):                 size);
Core.c (components\drivers\usb\usbdevice\core):    rt_size_t size;
Core.c (components\drivers\usb\usbdevice\core):    size = (setup->length > cfg_desc->wTotalLength) ?
Core.c (components\drivers\usb\usbdevice\core):    rt_usbd_ep0_write(device, (rt_uint8_t*)cfg_desc, size);
Core.c (components\drivers\usb\usbdevice\core):    rt_size_t size = 0;
Core.c (components\drivers\usb\usbdevice\core):            EP_HANDLER(ep, func, size);
Core.c (components\drivers\usb\usbdevice\core):        size = ep_msg->size;
Core.c (components\drivers\usb\usbdevice\core):        if(size == 0)
Core.c (components\drivers\usb\usbdevice\core):            size = dcd_ep_read(device->dcd, EP_ADDRESS(ep),
Core.c (components\drivers\usb\usbdevice\core):        if(size > ep->request.remain_size)
Core.c (components\drivers\usb\usbdevice\core):            ep->request.remain_size -= size;
Core.c (components\drivers\usb\usbdevice\core):            ep->request.buffer += size;
Core.c (components\drivers\usb\usbdevice\core):            EP_HANDLER(ep, func, size);
Core.c (components\drivers\usb\usbdevice\core):            EP_HANDLER(ep, func, ep->request.size);
Core.c (components\drivers\usb\usbdevice\core):    rt_size_t size;
Core.c (components\drivers\usb\usbdevice\core):    size = ep_msg->size;
Core.c (components\drivers\usb\usbdevice\core):    if(size == 0)
Core.c (components\drivers\usb\usbdevice\core):        size = dcd_ep_read(device->dcd, EP0_OUT_ADDR, ep0->request.buffer);
Core.c (components\drivers\usb\usbdevice\core):        if(size == 0)
Core.c (components\drivers\usb\usbdevice\core):    ep0->request.remain_size -= size; 
Core.c (components\drivers\usb\usbdevice\core):    ep0->request.buffer += size;
Core.c (components\drivers\usb\usbdevice\core):            ep0->rx_indicate(device, size);
Core.c (components\drivers\usb\usbdevice\core):static rt_size_t rt_usbd_ep_write(udevice_t device, uep_t ep, void *buffer, rt_size_t size)
Core.c (components\drivers\usb\usbdevice\core):static rt_size_t rt_usbd_ep_read_prepare(udevice_t device, uep_t ep, void *buffer, rt_size_t size)
Core.c (components\drivers\usb\usbdevice\core):    return dcd_ep_read_prepare(device->dcd, EP_ADDRESS(ep), buffer, size);
Core.c (components\drivers\usb\usbdevice\core): * @desc_size the size of the interface descriptor.
Core.c (components\drivers\usb\usbdevice\core):    rt_size_t size = 0;
Core.c (components\drivers\usb\usbdevice\core):            ep->request.remain_size = ep->request.size;
Core.c (components\drivers\usb\usbdevice\core):            size = rt_usbd_ep_read_prepare(device, ep, req->buffer, req->size);
Core.c (components\drivers\usb\usbdevice\core):            ep->request.remain_size = ep->request.size;
Core.c (components\drivers\usb\usbdevice\core):            size = rt_usbd_ep_write(device, ep, req->buffer, req->size);
Core.c (components\drivers\usb\usbdevice\core):    return size;
Core.c (components\drivers\usb\usbdevice\core):    rt_size_t size;
Core.c (components\drivers\usb\usbdevice\core):        size = dcd_ep_read(dcd, EP0_OUT_ADDR, (void*)&msg.content.setup);
Core.c (components\drivers\usb\usbdevice\core):        if(size != sizeof(struct urequest))
Core.c (components\drivers\usb\usbdevice\core):rt_err_t rt_usbd_ep0_out_handler(udcd_t dcd, rt_size_t size)
Core.c (components\drivers\usb\usbdevice\core):    msg.content.ep_msg.size = size;
Core.c (components\drivers\usb\usbdevice\core):    msg.content.ep_msg.size = 0;
Core.c (components\drivers\usb\usbdevice\core):rt_err_t rt_usbd_ep_out_handler(udcd_t dcd, rt_uint8_t address, rt_size_t size)
Core.c (components\drivers\usb\usbdevice\core):    msg.content.ep_msg.size = size;
Core.c (components\drivers\usb\usbdevice\core):rt_size_t rt_usbd_ep0_write(udevice_t device, void *buffer, rt_size_t size)
Core.c (components\drivers\usb\usbdevice\core):    RT_ASSERT(size > 0);
Core.c (components\drivers\usb\usbdevice\core):    ep0->request.size = size;
Core.c (components\drivers\usb\usbdevice\core):    ep0->request.remain_size = size;
Core.c (components\drivers\usb\usbdevice\core):rt_size_t rt_usbd_ep0_read(udevice_t device, void *buffer, rt_size_t size, 
Core.c (components\drivers\usb\usbdevice\core):    rt_err_t (*rx_ind)(udevice_t device, rt_size_t size))
Core.c (components\drivers\usb\usbdevice\core):    ep0->request.size = size;
Core.c (components\drivers\usb\usbdevice\core):    ep0->request.remain_size = size;
Core.c (components\drivers\usb\usbdevice\core):    dcd_ep_read_prepare(device->dcd, EP0_OUT_ADDR, buffer, size);
Core.c (components\drivers\usb\usbdevice\core):    return size;
Core.c (components\drivers\usb\usbdevice\core): * @param size the size of the message .
Core.c (components\drivers\usb\usbhost\core):    /* set device max packet size */
Core.c (components\drivers\usb\usbhost\core): * @param nbytes the size of buffer
Cpu.c (libcpu\arm\cortex-r4):     * size.  It can be omitted if it is known that the data cache has no dirty
Crt.cpp (components\cplusplus):void *operator new(size_t size)
Crt.cpp (components\cplusplus):    return rt_malloc(size);
Crt.cpp (components\cplusplus):void *operator new[](size_t size)
Crt.cpp (components\cplusplus):    return rt_malloc(size);
Crt.h (components\cplusplus):void *operator new(size_t size);
Crt.h (components\cplusplus):void *operator new[](size_t size);
Dataqueue.c (components\drivers\src):                   rt_uint16_t size,
Dataqueue.c (components\drivers\src):    queue->size = size;
Dataqueue.c (components\drivers\src):    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
Dataqueue.c (components\drivers\src):    mask = queue->size - 1;
Dataqueue.c (components\drivers\src):    while (queue->put_index - queue->get_index == queue->size)
Dataqueue.c (components\drivers\src):                           rt_size_t *size, 
Dataqueue.c (components\drivers\src):    RT_ASSERT(size != RT_NULL);
Dataqueue.c (components\drivers\src):    mask   = queue->size - 1;
Dataqueue.c (components\drivers\src):    *size     = queue->queue[queue->get_index & mask].data_size;
Dataqueue.c (components\drivers\src):                            rt_size_t *size)
Dataqueue.c (components\drivers\src):    mask = queue->size - 1;
Dataqueue.c (components\drivers\src):    *size     = queue->queue[queue->get_index & mask].data_size;
Dc_rotozoom.c (components\gui\src):	/* Maximum scaled source size */
Dc_rotozoom.c (components\gui\src):\brief Returns the size of the resulting target surface for a rotozoomSurface() call. 
Dc_rotozoom.c (components\gui\src):		/* Determine target size */
Dc_rotozoom.c (components\gui\src):		/* Calculate half size */
Dc_rotozoom.c (components\gui\src):		* Calculate target size
Dc_rotozoom.c (components\gui\src):\brief Calculates the size of the target surface for a rtgui_dc_zoom() call.
Dc_rotozoom.c (components\gui\src):The minimum size of the target surface is 1. The input factors can be positive or negative.
Dc_rotozoom.c (components\gui\src):	* Calculate target size 
Dc_rotozoom.c (components\gui\src):	/* Get size if target */
Dc_rotozoom.c (components\gui\src):'factorx' and 'factory' are the shrinking ratios (i.e. 2=1/2 the size,
Dc_rotozoom.c (components\gui\src):3=1/3 the size, etc.) The destination dc is antialiased by averaging
Dc_rotozoom.c (components\gui\src):	/* Get size for target */
Debug.c (components\dfs\filesystems\jffs2\src):			   and merged anyway, so we just check for the frag size here,
Debug.c (components\dfs\filesystems\jffs2\src):					&& frag_prev(frag)->size < PAGE_CACHE_SIZE && frag_prev(frag)->node) {
Debug.c (components\dfs\filesystems\jffs2\src):			if ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag)
Debug.c (components\dfs\filesystems\jffs2\src):					&& frag_next(frag)->size < PAGE_CACHE_SIZE && frag_next(frag)->node) {
Debug.c (components\dfs\filesystems\jffs2\src):					       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);
Debug.c (components\dfs\filesystems\jffs2\src):		JFFS2_ERROR("Calculated used size %#08x != stored used size %#08x.\n",
Debug.c (components\dfs\filesystems\jffs2\src):		JFFS2_ERROR("Calculated unchecked size %#08x != stored unchecked size %#08x.\n",
Debug.c (components\dfs\filesystems\jffs2\src):		JFFS2_ERROR("Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\n",
Debug.c (components\dfs\filesystems\jffs2\src):		JFFS2_ERROR("The sum of all nodes in block (%#x) != size of block (%#x)\n",
Debug.c (components\dfs\filesystems\jffs2\src):	printk(JFFS2_DBG_LVL "jffs2_reserved_blocks size: %#08x\n",
Debug.c (components\dfs\filesystems\jffs2\src):		printk (JFFS2_DBG_LVL "Contains %d blocks with total wasted size %u, average wasted size: %u\n",
Debug.c (components\dfs\filesystems\jffs2\src):		printk (JFFS2_DBG_LVL "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
Debug.c (components\dfs\filesystems\jffs2\src):		printk (JFFS2_DBG_LVL "contains %d blocks with total dirty size %u, average dirty size: %u\n",
Debug.c (components\dfs\filesystems\jffs2\src):				this->ofs, this->ofs+this->size, ref_offset(this->node->raw),
Debug.c (components\dfs\filesystems\jffs2\src):				this->ofs, this->ofs+this->size, this, frag_left(this),
Debug.c (components\dfs\filesystems\jffs2\src):		lastofs = this->ofs + this->size;
Deflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
Deflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):     * output size for (length,distance) codes is <= 24 bits.
Deflate.c (components\dfs\filesystems\jffs2\cyg\compress\src): * a close to exact, as well as small, upper bound on the compressed size.
Deflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):local int read_buf(strm, buf, size)
Deflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):    unsigned size;
Deflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):    if (len > size) len = size;
Deflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):         * UNALIGNED_OK if your compiler uses a different size.
Deflate.c (components\external\libz):local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
Deflate.c (components\external\libz):     * output size for (length,distance) codes is <= 24 bits.
Deflate.c (components\external\libz): * a close to exact, as well as small, upper bound on the compressed size.
Deflate.c (components\external\libz):local int read_buf(strm, buf, size)
Deflate.c (components\external\libz):    unsigned size;
Deflate.c (components\external\libz):    if (len > size) len = size;
Deflate.c (components\external\libz):         * UNALIGNED_OK if your compiler uses a different size.
Deflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):/* maximum heap size */
Deflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):    ulg   pending_buf_size; /* size of pending_buf */
Deflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):    uInt  w_size;        /* LZ77 window size (32K by default) */
Deflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):     * performed with a length multiple of the block size. Also, it limits
Deflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):     * the window size to 64K, which is quite useful on MSDOS.
Deflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):    /* Actual size of window: 2*wSize, except when the user input buffer
Deflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):    /* Link to older string with same hash index. To limit the size of this
Deflate.h (components\external\libz):/* maximum heap size */
Deflate.h (components\external\libz):    ulg   pending_buf_size; /* size of pending_buf */
Deflate.h (components\external\libz):    uInt  w_size;        /* LZ77 window size (32K by default) */
Deflate.h (components\external\libz):     * performed with a length multiple of the block size. Also, it limits
Deflate.h (components\external\libz):     * the window size to 64K, which is quite useful on MSDOS.
Deflate.h (components\external\libz):    /* Actual size of window: 2*wSize, except when the user input buffer
Deflate.h (components\external\libz):    /* Link to older string with same hash index. To limit the size of this
Device.c (src): * @param size the size of buffer
Device.c (src): * @return the actually read size on successful, otherwise negative returned.
Device.c (src): * @note since 0.4.0, the unit of size/pos is a block for block device.
Device.c (src):                         rt_size_t   size)
Device.c (src):        return dev->read(dev, pos, buffer, size);
Device.c (src): * @param size the size of buffer
Device.c (src): * @return the actually written size on successful, otherwise negative returned.
Device.c (src): * @note since 0.4.0, the unit of size/pos is a block for block device.
Device.c (src):                          rt_size_t   size)
Device.c (src):        return dev->write(dev, pos, buffer, size);
Device.c (src):                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
Dfs_def.h (components\dfs\include):    rt_size_t f_bsize;   /* block size */
Dfs_def.h (components\dfs\include):    rt_size_t   size;            /* Size in bytes */
Dfs_elm.c (components\dfs\filesystems\elmfat): * 2011-10-08     Bernard      fixed the block size in statfs.
Dfs_elm.c (components\dfs\filesystems\elmfat): * 2014-01-26     Bernard      Check the sector size before mount.
Dfs_elm.c (components\dfs\filesystems\elmfat):	/* check sector size */
Dfs_elm.c (components\dfs\filesystems\elmfat):			rt_kprintf("The sector size of device is greater than the sector size of FAT.\n");
Dfs_elm.c (components\dfs\filesystems\elmfat):    /* 0: auto selection of cluster size */
Dfs_elm.c (components\dfs\filesystems\elmfat):            file->size = fd->fsize;
Dfs_elm.c (components\dfs\filesystems\elmfat):    /* update position and file size */
Dfs_elm.c (components\dfs\filesystems\elmfat):    file->size = fd->fsize;
Dfs_elm.c (components\dfs\filesystems\elmfat):    else if (ctrl == GET_BLOCK_SIZE) /* Get erase block size in unit of sectors (DWORD) */
Dfs_elm.c (components\dfs\filesystems\elmfat):void *ff_memalloc(UINT size)
Dfs_elm.c (components\dfs\filesystems\elmfat):    return rt_malloc(size);
Dfs_file.c (components\dfs\src):    fd->size  = 0;
Dfs_fs.c (components\dfs\src):#define DPT_ITEM_SIZE   16          /* partition item size */
Dfs_fs.c (components\dfs\src):     *    size is the number of 512-Byte */
Dfs_fs.c (components\dfs\src):    part->size = *(dpt+12) | *(dpt+13)<<8 | *(dpt+14)<<16 | *(dpt+15)<<24;
Dfs_fs.c (components\dfs\src):    rt_kprintf("found part[%d], begin: %d, size: ",
Dfs_fs.c (components\dfs\src):    if ((part->size>>11) == 0)
Dfs_fs.c (components\dfs\src):        rt_kprintf("%d%s",part->size>>1,"KB\n");     /* KB */
Dfs_fs.c (components\dfs\src):        part_size = part->size >> 11;                /* MB */
Dfs_fs.c (components\dfs\src):            rt_kprintf("%d.%d%s",part_size,(part->size>>1)&0x3FF,"MB\n");
Dfs_fs.h (components\dfs\include):    rt_size_t size;         /* partition size */
Dfs_jffs2.c (components\dfs\filesystems\jffs2):	/* since the limit of unsigned long, so the max size of flash device is 4G */
Dfs_jffs2.c (components\dfs\filesystems\jffs2):	file->size = 0;
Dfs_jffs2.c (components\dfs\filesystems\jffs2):	jffs2_file_lseek(jffs2_file, (off_t *)(&(file->size)), DFS_SEEK_END);
Dfs_jffs2.c (components\dfs\filesystems\jffs2):		file->pos = file->size;	
Dfs_jffs2.c (components\dfs\filesystems\jffs2): 		jffs2_file->f_offset = file->size;
Dfs_jffs2.c (components\dfs\filesystems\jffs2):/* fixme warning: the offset is rt_off_t, so maybe the size of a file is must <= 2G*/
Dfs_jffs2.c (components\dfs\filesystems\jffs2):/* return the size of  struct dirent*/
Dfs_nfs.c (components\dfs\filesystems\nfs):    size_t size;        /* total size */
Dfs_nfs.c (components\dfs\filesystems\nfs):    size_t size;
Dfs_nfs.c (components\dfs\filesystems\nfs):    size = info->size;
Dfs_nfs.c (components\dfs\filesystems\nfs):    return size;
Dfs_nfs.c (components\dfs\filesystems\nfs):    args.how.createhow3_u.obj_attributes.size.set_it = FALSE;
Dfs_nfs.c (components\dfs\filesystems\nfs):    args.attributes.size.set_it = FALSE;
Dfs_nfs.c (components\dfs\filesystems\nfs):            /* update file size */
Dfs_nfs.c (components\dfs\filesystems\nfs):			if (fd->size < fd->offset) fd->size = fd->offset;
Dfs_nfs.c (components\dfs\filesystems\nfs):			file->size = fd->size;
Dfs_nfs.c (components\dfs\filesystems\nfs):    if (offset <= fd->size)
Dfs_nfs.c (components\dfs\filesystems\nfs):        /* get size of file */
Dfs_nfs.c (components\dfs\filesystems\nfs):        fp->size = nfs_get_filesize(nfs, handle);
Dfs_nfs.c (components\dfs\filesystems\nfs):            fp->offset = fp->size;
Dfs_nfs.c (components\dfs\filesystems\nfs):        file->size = fp->size;
Dfs_nfs.c (components\dfs\filesystems\nfs):    st->st_size  = info->size;
Dfs_posix.c (components\dfs\src):        offset += d->size;
Dfs_posix.c (components\dfs\src):    buf->st_size    = d->size;
Dfs_posix.c (components\dfs\src): * @param size the buffer size.
Dfs_posix.c (components\dfs\src):char *getcwd(char *buf, size_t size)
Dfs_posix.c (components\dfs\src):    rt_strncpy(buf, working_directory, size);
Dfs_posix.h (components\dfs\include):char *getcwd(char *buf, size_t size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):                                      rt_size_t        *size)
Dfs_ramfs.c (components\dfs\filesystems\ramfs):        *size = 0;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):            *size = dirent->size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    if (count < file->size - file->pos)
Dfs_ramfs.c (components\dfs\filesystems\ramfs):        length = file->size - file->pos;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    if (count + fd->pos > fd->size)
Dfs_ramfs.c (components\dfs\filesystems\ramfs):        /* update dirent and file size */
Dfs_ramfs.c (components\dfs\filesystems\ramfs):        dirent->size = fd->pos + count;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):        fd->size = dirent->size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    if (offset <= (rt_off_t)file->size)
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    rt_size_t size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):        dirent = dfs_ramfs_lookup(ramfs, file->path, &size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):        dirent = dfs_ramfs_lookup(ramfs, file->path, &size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):                dirent->size = 0;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):            dirent->size = 0;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    file->size = dirent->size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):		file->pos = file->size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    rt_size_t size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    dirent = dfs_ramfs_lookup(ramfs, path, &size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    st->st_size = dirent->size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    rt_size_t size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    dirent = dfs_ramfs_lookup(ramfs, path, &size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    rt_size_t size;
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    dirent = dfs_ramfs_lookup(ramfs, newpath, &size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    dirent = dfs_ramfs_lookup(ramfs, oldpath, &size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):struct dfs_ramfs* dfs_ramfs_create(rt_uint8_t *pool, rt_size_t size)
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    size  = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    size = size - sizeof(struct dfs_ramfs);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    result = rt_memheap_init(&ramfs->memheap, "ramfs", data_ptr, size);
Dfs_ramfs.c (components\dfs\filesystems\ramfs):    ramfs->root.size = 0;
Dfs_ramfs.h (components\dfs\filesystems\ramfs):    rt_size_t size;	/* file size */
Dfs_ramfs.h (components\dfs\filesystems\ramfs):struct dfs_ramfs* dfs_ramfs_create(rt_uint8_t* pool, rt_size_t size);
Dfs_romfs.c (components\dfs\filesystems\romfs):        || dirent->size == ~0)
Dfs_romfs.c (components\dfs\filesystems\romfs):struct romfs_dirent *dfs_romfs_lookup(struct romfs_dirent *root_dirent, const char *path, rt_size_t *size)
Dfs_romfs.c (components\dfs\filesystems\romfs):		*size = root_dirent->size;
Dfs_romfs.c (components\dfs\filesystems\romfs):	dirent_size = root_dirent->size;
Dfs_romfs.c (components\dfs\filesystems\romfs):				dirent_size = dirent[index].size;
Dfs_romfs.c (components\dfs\filesystems\romfs):					*size = dirent_size;
Dfs_romfs.c (components\dfs\filesystems\romfs):	if (count < file->size - file->pos)
Dfs_romfs.c (components\dfs\filesystems\romfs):		length = file->size - file->pos;
Dfs_romfs.c (components\dfs\filesystems\romfs):	if (offset <= file->size)
Dfs_romfs.c (components\dfs\filesystems\romfs):	rt_size_t size;
Dfs_romfs.c (components\dfs\filesystems\romfs):	dirent = dfs_romfs_lookup(root_dirent, file->path, &size);
Dfs_romfs.c (components\dfs\filesystems\romfs):	file->size = size;
Dfs_romfs.c (components\dfs\filesystems\romfs):	rt_size_t size;
Dfs_romfs.c (components\dfs\filesystems\romfs):	dirent = dfs_romfs_lookup(root_dirent, path, &size);
Dfs_romfs.c (components\dfs\filesystems\romfs):	st->st_size = dirent->size;
Dfs_romfs.c (components\dfs\filesystems\romfs):	for (index = 0; index < count && file->pos < file->size; index ++)
Dfs_romfs.h (components\dfs\filesystems\romfs):	rt_size_t		 size;	/* file size */
Dfs_uffs.c (components\dfs\filesystems\uffs):	file->size = uffs_seek(fd, 0, USEEK_END);
Dfs_uffs.c (components\dfs\filesystems\uffs):/* return the size of struct dirent*/
Dhcp.c (components\net\lwip-1.3.2\src\core):    /* resize pbuf to reflect true size of options */
Dhcp.c (components\net\lwip-1.4.1\src\core):    /* resize pbuf to reflect true size of options */
Dhcp.c (components\net\lwip-head\src\core):    /* resize pbuf to reflect true size of options */
Dhcp.c (components\net\lwip\src\core):    /* resize pbuf to reflect true size of options */
Dhcp.h (components\net\lwip-1.3.2\src\include\lwip):#define DHCP_OPTION_MAX_MSG_SIZE 57 /* RFC 2132 9.10, message size accepted >= 576 */
Dhcp.h (components\net\lwip-1.4.1\src\include\lwip):#define DHCP_OPTION_MAX_MSG_SIZE 57 /* RFC 2132 9.10, message size accepted >= 576 */
Dhcp.h (components\net\lwip-head\src\include\lwip):#define DHCP_OPTION_MAX_MSG_SIZE 57 /* RFC 2132 9.10, message size accepted >= 576 */
Dhcp.h (components\net\lwip\src\include\lwip):#define DHCP_OPTION_MAX_MSG_SIZE 57 /* RFC 2132 9.10, message size accepted >= 576 */
Dhcp_server.c (components\net\lwip_dhcpd):/* buffer size for receive DHCP packet */
Dhcp_server.c (components\net\lwip_dhcpd):                                     rt_size_t size)
Dhcp_server.c (components\net\lwip_dhcpd):                   + sizeof(struct udp_hdr) + size,
Dhcp_server.c (components\net\lwip_dhcpd):    IPH_LEN_SET(iphdr, htons(IP_HLEN + sizeof(struct udp_hdr) + size));
Dhcp_server.c (components\net\lwip_dhcpd):    udphdr->len = htons(sizeof(struct udp_hdr) + size);
Dhcp_server.c (components\net\lwip_dhcpd):           buffer, size);
DIALOG_Intern.h (components\emwin1\inc):  I16                      xSize;            // x size
DIALOG_Intern.h (components\emwin1\inc):  I16                      ySize;            // y size
DIALOG_Intern.h (components\emwin1\inc\include):  I16                      xSize;            // x size
DIALOG_Intern.h (components\emwin1\inc\include):  I16                      ySize;            // y size
DIALOG_Intern.h (components\emwin\include):  I16                      xSize;            // x size
DIALOG_Intern.h (components\emwin\include):  I16                      ySize;            // y size
DIALOG_Intern.h (components\stemwin\inc):  I16                      xSize;            // x size
DIALOG_Intern.h (components\stemwin\inc):  I16                      ySize;            // y size
DIALOG_Intern.h (components\stemwin\inc\include):  I16                      xSize;            // x size
DIALOG_Intern.h (components\stemwin\inc\include):  I16                      ySize;            // y size
Diskio.h (components\dfs\filesystems\elmfat):#define GET_SECTOR_COUNT	1	/* Get media size (for only f_mkfs()) */
Diskio.h (components\dfs\filesystems\elmfat):#define GET_SECTOR_SIZE		2	/* Get sector size (for multiple sector size (_MAX_SS >= 1024)) */
Diskio.h (components\dfs\filesystems\elmfat):#define GET_BLOCK_SIZE		3	/* Get erase block size (for only f_mkfs()) */
Dns.h (components\net\lwip-1.4.1\src\include\lwip):/* The size used for the next line is rather a hack, but it prevents including socket.h in all files
Dns.h (components\net\lwip-head\src\include\lwip):/* The size used for the next line is rather a hack, but it prevents including socket.h in all files
Dns.h (components\net\lwip\src\include\lwip):/* The size used for the next line is rather a hack, but it prevents including socket.h in all files
Doxygen.css (components\net\uip\doc\html):       font-size: 90%;
Doxygen.css (components\net\uip\doc\html):       font-size: 160%;
Doxygen.css (components\net\uip\doc\html):       font-size: 120%;
Doxygen.css (components\net\uip\doc\html):       font-size: 100%;
Doxygen.css (components\net\uip\doc\html):       font-size: 70%;
Doxygen.css (components\net\uip\doc\html):       font-size: 95%;
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):DIV.groupText { margin-left: 16px; font-style: italic; font-size: 90% }
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):	font-size: 80%;
Doxygen.css (components\net\uip\doc\html):INPUT.search { font-size: 75%;
Doxygen.css (components\net\uip\doc\html):TD.tiny      { font-size: 75%;
Drv_lcd_st7735.c (bsp\stm32f407vgt6\drivers):  uint32_t index = 0, size = 0;
Drv_lcd_st7735.c (bsp\stm32f407vgt6\drivers):  /* Read bitmap size */
Drv_lcd_st7735.c (bsp\stm32f407vgt6\drivers):  size = *(volatile uint16_t *) (pbmp + 2);
Drv_lcd_st7735.c (bsp\stm32f407vgt6\drivers):  size |= (*(volatile uint16_t *) (pbmp + 4)) << 16;
Drv_lcd_st7735.c (bsp\stm32f407vgt6\drivers):  size = (size - index)/2;
Drv_lcd_st7735.c (bsp\stm32f407vgt6\drivers):  LCD_IO_WriteMultipleData((uint8_t*)pbmp, size*2);
Enc28j60.c (components\drivers\spi):    // Set the maximum packet size which the controller will accept
Enc28j60.c (components\drivers\spi):static rt_size_t enc28j60_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size)
Enc28j60.c (components\drivers\spi):static rt_size_t enc28j60_write(rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size)
Enc28j60.c (components\drivers\spi):    // Set the TXND pointer to correspond to the packet size given
Enc28j60.c (components\drivers\spi):    NET_DEBUG("tx_dump, size:%d\r\n", p->tot_len);
Enc28j60.c (components\drivers\spi):                NET_DEBUG("rx_dump, size:%d\r\n", len);
Espruino.c (components\external\espruino\targets\rtthread):  int size = (int)results.st_size;
Espruino.c (components\external\espruino\targets\rtthread):  /* if we open as text, the number of bytes read may be > the size we read */
Espruino.c (components\external\espruino\targets\rtthread):  char *buffer = malloc(size+1);
Espruino.c (components\external\espruino\targets\rtthread):  size_t actualRead = fread(buffer,1,size,file);
Espruino.c (components\external\espruino\targets\rtthread):  buffer[size]=0;
Example.c (components\external\jpeg):   * In this example, we need to make an output work buffer of the right size.
Examples.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Expr.c (components\external\sqlite-3.8.1\src):** (2) the EP_xxx flags that indicate what the structure size should be.
Expr.c (components\external\sqlite-3.8.1\src):** The size of the structure can be found by masking the return value
Expr.c (components\external\sqlite-3.8.1\src):** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size
Expr.c (components\external\sqlite-3.8.1\src):      /* Set nNewSize to the size allocated for the structure pointed to
Expr.c (components\external\sqlite-3.8.1\src):  /* Note that because the size of the allocation for p->a[] is not
Fast_vacuum.c (components\external\sqlite-3.8.1\tool):**  (2)  Database reconfiguration such as page size or auto_vacuum changes
Ff.c (components\dfs\filesystems\elmfat):/                   Added a capability of extending file size to f_lseek().
Ff.c (components\dfs\filesystems\elmfat):/                   Added auto cluster size selection to f_mkfs().
Ff.c (components\dfs\filesystems\elmfat):/                   Added multiple sector size feature.
Ff.c (components\dfs\filesystems\elmfat):/                   f_lseek() reports required table size on creating CLMP.
Ff.c (components\dfs\filesystems\elmfat):/* Definitions on sector size */
Ff.c (components\dfs\filesystems\elmfat):#error Wrong sector size.
Ff.c (components\dfs\filesystems\elmfat):#define	SS(fs)	((fs)->ssize)	/* sector size */
Ff.c (components\dfs\filesystems\elmfat):#define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
Ff.c (components\dfs\filesystems\elmfat):#define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
Ff.c (components\dfs\filesystems\elmfat):#define BPB_TotSec16		19	/* Volume size [sector] (2) */
Ff.c (components\dfs\filesystems\elmfat):#define BPB_FATSz16			22	/* FAT size [sector] (2) */
Ff.c (components\dfs\filesystems\elmfat):#define BPB_SecPerTrk		24	/* Track size [sector] (2) */
Ff.c (components\dfs\filesystems\elmfat):#define BPB_TotSec32		32	/* Volume size [sector] (4) */
Ff.c (components\dfs\filesystems\elmfat):#define BPB_FATSz32			36	/* FAT size [sector] (4) */
Ff.c (components\dfs\filesystems\elmfat):#define	DIR_FileSize		28	/* File size (4) */
Ff.c (components\dfs\filesystems\elmfat):	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
Ff.c (components\dfs\filesystems\elmfat):	/* Get disk sector size (variable sector size cfg only) */
Ff.c (components\dfs\filesystems\elmfat):	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
Ff.c (components\dfs\filesystems\elmfat):	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
Ff.c (components\dfs\filesystems\elmfat):	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
Ff.c (components\dfs\filesystems\elmfat):		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
Ff.c (components\dfs\filesystems\elmfat):		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
Ff.c (components\dfs\filesystems\elmfat):			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
Ff.c (components\dfs\filesystems\elmfat):		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
Ff.c (components\dfs\filesystems\elmfat):			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
Ff.c (components\dfs\filesystems\elmfat):	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
Ff.c (components\dfs\filesystems\elmfat):			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
Ff.c (components\dfs\filesystems\elmfat):	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
Ff.c (components\dfs\filesystems\elmfat):				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
Ff.c (components\dfs\filesystems\elmfat):			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
Ff.c (components\dfs\filesystems\elmfat):				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
Ff.c (components\dfs\filesystems\elmfat):			if (ofs > fp->fsize)		/* Clip offset at the file size */
Ff.c (components\dfs\filesystems\elmfat):		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
Ff.c (components\dfs\filesystems\elmfat):			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
Ff.c (components\dfs\filesystems\elmfat):						if (clst == 0) {				/* When disk gets full, clip file size */
Ff.c (components\dfs\filesystems\elmfat):		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
Ff.c (components\dfs\filesystems\elmfat):			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
Ff.c (components\dfs\filesystems\elmfat):			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
Ff.c (components\dfs\filesystems\elmfat):	UINT au			/* Allocation unit size [bytes] */
Ff.c (components\dfs\filesystems\elmfat):	/* Get disk sector size */
Ff.c (components\dfs\filesystems\elmfat):	if (au & (au - 1)) au = 0;	/* Check validity of the AU size */
Ff.c (components\dfs\filesystems\elmfat):	/* Determine offset and size of FAT structure */
Ff.c (components\dfs\filesystems\elmfat):	} else {					/* FAT12/16: Expand FAT size */
Ff.c (components\dfs\filesystems\elmfat):		ST_DWORD(tbl+12, n_vol);			/* Partition size in LBA */
Ff.c (components\dfs\filesystems\elmfat):	i = SS(fs);								/* Sector size */
Ff.c (components\dfs\filesystems\elmfat):	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
Ff.h (components\dfs\filesystems\elmfat):	DWORD	fsize;			/* File size */
Ff.h (components\dfs\filesystems\elmfat):	DWORD	fsize;			/* File size */
Ffconf.h (components\dfs\filesystems\elmfat):/* Maximum sector size to be handled.
Ffconf.h (components\dfs\filesystems\elmfat):/  When _MAX_SS is larger than 512, it configures FatFs to variable sector size
Ffconf.h (components\dfs\filesystems\elmfat):/  performance and code size. */
Fileio.h (components\dfs\filesystems\jffs2\cyg\fileio):    size_t      size;           /* size of buffer */
Filerw.c (components\gui\src):static int stdio_read(struct rtgui_filerw *context, void *ptr, rt_size_t size, rt_size_t maxnum)
Filerw.c (components\gui\src):    result = read(stdio_filerw->fd, ptr, size * maxnum);
Filerw.c (components\gui\src):static int stdio_write(struct rtgui_filerw *context, const void *ptr, rt_size_t size, rt_size_t num)
Filerw.c (components\gui\src):    return write(stdio_filerw->fd, (char *)ptr, size * num);
Filerw.c (components\gui\src):static int mem_read(struct rtgui_filerw *context, void *ptr, rt_size_t size, rt_size_t maxnum)
Filerw.c (components\gui\src):    total_bytes = (maxnum * size);
Filerw.c (components\gui\src):    if ((maxnum <= 0) || (size <= 0) || ((total_bytes / maxnum) != size))
Filerw.c (components\gui\src):    return (total_bytes / size);
Filerw.c (components\gui\src):static int mem_write(struct rtgui_filerw *context, const void *ptr, rt_size_t size, rt_size_t num)
Filerw.c (components\gui\src):struct rtgui_filerw *rtgui_filerw_create_mem(const rt_uint8_t *mem, rt_size_t size)
Filerw.c (components\gui\src):        rw->mem_end = mem + size;
Filerw.c (components\gui\src):int rtgui_filerw_read(struct rtgui_filerw *context, void *buffer, rt_size_t size, rt_size_t count)
Filerw.c (components\gui\src):    return context->read(context, buffer, size, count);
Filerw.c (components\gui\src):int rtgui_filerw_write(struct rtgui_filerw *context, const void *buffer, rt_size_t size, rt_size_t count)
Filerw.c (components\gui\src):    return context->write(context, buffer, size, count);
Filerw.h (components\gui\include\rtgui):    int (*read)(struct rtgui_filerw *context, void *buffer, rt_size_t size, rt_size_t count);
Filerw.h (components\gui\include\rtgui):    int (*write)(struct rtgui_filerw *context, const void *buffer, rt_size_t size, rt_size_t count);
Filerw.h (components\gui\include\rtgui):struct rtgui_filerw *rtgui_filerw_create_mem(const rt_uint8_t *mem, rt_size_t size);
Filerw.h (components\gui\include\rtgui):int rtgui_filerw_read(struct rtgui_filerw *context, void *buffer, rt_size_t size, rt_size_t count);
Filerw.h (components\gui\include\rtgui):int rtgui_filerw_write(struct rtgui_filerw *context, const void *buffer, rt_size_t size, rt_size_t count);
Files.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
Finsh.h (components\finsh):#define FINSH_STACK_MAX         64      /* max stack size */
Finsh.h (components\finsh):#define FINSH_TEXT_MAX          128     /* max text segment size */
Finsh_heap.c (components\finsh):#define HEAP_ALIGN_SIZE(size)			(((size) + HEAP_ALIGNMENT - 1) & ~(HEAP_ALIGNMENT-1))
Finsh_heap.c (components\finsh):static void finsh_block_split(struct finsh_block_header* header, size_t size);
Finsh_heap.c (components\finsh):void* finsh_heap_allocate(size_t size)
Finsh_heap.c (components\finsh):	size = HEAP_ALIGN_SIZE(size);
Finsh_heap.c (components\finsh):        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
Finsh_heap.c (components\finsh):			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
Finsh_heap.c (components\finsh):	finsh_block_split(header, size);
Finsh_heap.c (components\finsh):	memset(finsh_block_get_data(header), 0, size);
Finsh_heap.c (components\finsh):void finsh_block_split(struct finsh_block_header* header, size_t size)
Finsh_heap.c (components\finsh):    next = BLOCK_HEADER((u_char*)header + sizeof(struct finsh_block_header) + size);
Finsh_heap.c (components\finsh):    next->length = header->length - sizeof(struct finsh_block_header) - size;
Finsh_heap.c (components\finsh):    header->length = size;
Finsh_heap.h (components\finsh):void* finsh_heap_allocate(size_t size);
Fkey.c (components\external\sqlite-3.8.1\src):** Otherwise, it is set to point to an allocated array of size N, where
Fkey.c (components\external\sqlite-3.8.1\src):** to an array of size N, where N is the number of columns in table pTab.
Flash-interface-example.c (components\dfs\filesystems\uffs\src\example):	attr->page_data_size = PAGE_DATA_SIZE;		/* page data size */
Flash-interface-example.c (components\dfs\filesystems\uffs\src\example):	attr->spare_size = PAGE_SPARE_SIZE;		  	/* page spare size */
Flashio.c (components\dfs\filesystems\jffs2\src):		const size_t size,
Flashio.c (components\dfs\filesystems\jffs2\src):	len = rt_mtd_nor_read(RT_MTD_NOR_DEVICE(sb->s_dev), offset, buffer, size);
Flashio.c (components\dfs\filesystems\jffs2\src):	if (len != size)
Flashio.c (components\dfs\filesystems\jffs2\src):		uint32_t offset, const size_t size,
Flashio.c (components\dfs\filesystems\jffs2\src):	len = rt_mtd_nor_write(RT_MTD_NOR_DEVICE(sb->s_dev), offset, buffer, size);
Flashio.c (components\dfs\filesystems\jffs2\src):	if (len != size)
Flashio.c (components\dfs\filesystems\jffs2\src):				//rt_kprintf("direct_write: offset %d, size %d\n", to, sizetomalloc);
Flashio.c (components\dfs\filesystems\jffs2\src):				//rt_kprintf("direct_write: offset %d, size %d\n", to, lentowrite);
Flashio.c (components\dfs\filesystems\jffs2\src):			//rt_kprintf("direct_writev: offset %d, size %d\n", to, vecs[i].iov_len);
Font.c (components\gui\src):    // rt_kprintf("set font size to %d\n", font->height);
Font.h (components\gui\include\rtgui):    /* font size */
Font.h (components\gui\include\rtgui):    /* Keep the size of this struct within 4 bytes so it can be passed by
Font_fnt.c (components\gui\src):	if (!readlong(fd, &fnt_header->size)) goto __exit;
Font_fnt.h (components\gui\include\rtgui):	rt_uint32_t size;
Font_freetype.c (components\gui\src):    /* FIXME: face->size->metrics.descender is format specific actually. But it
Font_freetype.c (components\gui\src):    topy = rect->y1 + (fft->face->size->metrics.descender >> 6);
Font_freetype.c (components\gui\src):                         face->size->metrics.y_scale) >> 6;
Font_freetype.c (components\gui\src):                         face->size->metrics.y_scale) >> 6;
Font_freetype.c (components\gui\src):rtgui_font_t *rtgui_freetype_font_create(const char *filename, int bold, int italic, rt_size_t size)
Font_freetype.c (components\gui\src):    err = FT_Set_Pixel_Sizes(fft->face, 0, size);
Font_freetype.c (components\gui\src):    font->height = (rt_uint16_t)size;
Font_freetype.c (components\gui\src):FINSH_FUNCTION_EXPORT_ALIAS(rtgui_freetype_font_create, ftc, "create freetype font: name, bold, italic, size")
Font_freetype.h (components\gui\include\rtgui):rtgui_font_t *rtgui_freetype_font_create(const char *filename, int bold, int italic, rt_size_t size);
FRAMEWIN.h (components\emwin1\inc):*       Getting border size
FRAMEWIN.h (components\emwin1\inc\include):*       Getting border size
FRAMEWIN.h (components\emwin\include):*       Getting border size
FRAMEWIN.h (components\stemwin\inc):*       Getting border size
FRAMEWIN.h (components\stemwin\inc\include):*       Getting border size
FRAMEWIN_Private.h (components\emwin1\inc):// Default for top frame size
FRAMEWIN_Private.h (components\emwin1\inc):// Default for left/right/top/bottom frame size
FRAMEWIN_Private.h (components\emwin1\inc):// Default for inner frame size
FRAMEWIN_Private.h (components\emwin1\inc\include):// Default for top frame size
FRAMEWIN_Private.h (components\emwin1\inc\include):// Default for left/right/top/bottom frame size
FRAMEWIN_Private.h (components\emwin1\inc\include):// Default for inner frame size
FRAMEWIN_Private.h (components\emwin\include):// Default for top frame size
FRAMEWIN_Private.h (components\emwin\include):// Default for left/right/top/bottom frame size
FRAMEWIN_Private.h (components\emwin\include):// Default for inner frame size
FRAMEWIN_Private.h (components\stemwin\inc):// Default for top frame size
FRAMEWIN_Private.h (components\stemwin\inc):// Default for left/right/top/bottom frame size
FRAMEWIN_Private.h (components\stemwin\inc):// Default for inner frame size
FRAMEWIN_Private.h (components\stemwin\inc\include):// Default for top frame size
FRAMEWIN_Private.h (components\stemwin\inc\include):// Default for left/right/top/bottom frame size
FRAMEWIN_Private.h (components\stemwin\inc\include):// Default for inner frame size
Freetype.h (components\external\freetype\include):  /*    of glyphs for a given point size and resolution) in a bitmap font. */
Freetype.h (components\external\freetype\include):  /*    size   :: The nominal size of the strike in 26.6 fractional        */
Freetype.h (components\external\freetype\include):  /*      The nominal size given in a FNT font is not reliable.  Thus when */
Freetype.h (components\external\freetype\include):  /*      the driver finds it incorrect, it sets `size' to some calculated */
Freetype.h (components\external\freetype\include):  /*      `size', `width', and `height' values are not contained in the    */
Freetype.h (components\external\freetype\include):    FT_Pos    size;
Freetype.h (components\external\freetype\include):  /*    character size.                                                    */
Freetype.h (components\external\freetype\include):  /*    You can use @FT_New_Size to create additional size objects for a   */
Freetype.h (components\external\freetype\include):  /*    you activate it through @FT_Activate_Size.  Only one size can be   */
Freetype.h (components\external\freetype\include):  /*    See @FT_SizeRec for the publicly accessible fields of a given size */
Freetype.h (components\external\freetype\include):  /*    size                :: The current active size for this face.      */
Freetype.h (components\external\freetype\include):    FT_Size           size;
Freetype.h (components\external\freetype\include):  /*    The size metrics structure gives the metrics of a size object.     */
Freetype.h (components\external\freetype\include):  /*    size changing operation.  The remaining fields are then set by the */
Freetype.h (components\external\freetype\include):  /*    FreeType root size class structure.  A size object models a face   */
Freetype.h (components\external\freetype\include):  /*    object at a given size.                                            */
Freetype.h (components\external\freetype\include):  /*               applications to link their own data to each size        */
Freetype.h (components\external\freetype\include):  /*    metrics :: Metrics for this size object.  This field is read-only. */
Freetype.h (components\external\freetype\include):    FT_Size_Metrics   metrics;   /* size metrics                    */
Freetype.h (components\external\freetype\include):  /*    memory_size :: The size in bytes of the file in memory.            */
Freetype.h (components\external\freetype\include):  /*    file_size  :: The size of the memory chunk used by the font data.  */
Freetype.h (components\external\freetype\include):  /*    default @FT_Size object, accessible as `face->size'.               */
Freetype.h (components\external\freetype\include):  /*    An enumeration type that lists the supported size request types.   */
Freetype.h (components\external\freetype\include):  /*      The nominal size.  The `units_per_EM' field of @FT_FaceRec is    */
Freetype.h (components\external\freetype\include):  /*      want to specify the font size for, say, a window of a given      */
Freetype.h (components\external\freetype\include):  /*    See the note section of @FT_Size_Metrics if you wonder how size    */
Freetype.h (components\external\freetype\include):  /*    A structure used to model a size request.                          */
Freetype.h (components\external\freetype\include):  /*    A handle to a size request structure.                              */
Freetype.h (components\external\freetype\include):  /*    The relation between the requested size and the resulting glyph    */
Freetype.h (components\external\freetype\include):  /*    size is dependent entirely on how the size is defined in the       */
Freetype.h (components\external\freetype\include):  /*    source face.  The font designer chooses the final size of each     */
Freetype.h (components\external\freetype\include):  /*    glyph relative to this size.  For more information refer to        */
Freetype.h (components\external\freetype\include):  /*    This function calls @FT_Request_Size to request the nominal size   */
Freetype.h (components\external\freetype\include):  /*    This function calls @FT_Request_Size to request the nominal size   */
Freetype.h (components\external\freetype\include):  /*    constrained, to this pixel size.  Refer to @FT_Request_Size to     */
Freetype.h (components\external\freetype\include):   *        face's current size.  If one is found, the function returns.
Freetype.h (components\external\freetype\include):   *     setting the character size to `font->units_per_EM'.
Freetype.h (components\external\freetype\include):  /*    the transformation and is performed on the character size given in */
Freetype.h (components\external\freetype\include):  /*    Return the track kerning for a given face object at a given size.  */
Freetype.h (components\external\freetype\include):  /*    point_size :: The point size in 16.16 fractional points.           */
Fs-ecos.c (components\dfs\filesystems\jffs2\src):	/* sector size is the erase block size */
Fs-ecos.c (components\dfs\filesystems\jffs2\src):		D2(printf("jffs2_fo_read inode size %d\n", inode->i_size));
Fs-ecos.c (components\dfs\filesystems\jffs2\src):		D2(printf("jffs2_fo_write transfer size %d\n", len));
Fs-ecos.c (components\dfs\filesystems\jffs2\src):	// times of the inode, increase its size appropriately, and update
Fs-ecos.c (components\dfs\filesystems\jffs2\src):		// Add pos to file size.
Ftadvanc.c (components\external\freetype\src\base):    if ( face->size == NULL )
Ftadvanc.c (components\external\freetype\src\base):      scale = face->size->metrics.y_scale;
Ftadvanc.c (components\external\freetype\src\base):      scale = face->size->metrics.x_scale;
Ftapi.c (components\external\freetype\src\base):                        FT_ULong    size,
Ftapi.c (components\external\freetype\src\base):    FT_Stream_OpenMemory( stream, base, size );
Ftbase.h (components\external\freetype\src\base):                         FT_ULong     size,
Ftbitmap.c (components\external\freetype\src\base):    FT_ULong  size;
Ftbitmap.c (components\external\freetype\src\base):    size = (FT_ULong)pitch * source->rows;
Ftbitmap.c (components\external\freetype\src\base):      if ( target_size != size )
Ftbitmap.c (components\external\freetype\src\base):        (void)FT_QREALLOC( target->buffer, target_size, size );
Ftbitmap.c (components\external\freetype\src\base):      (void)FT_QALLOC( target->buffer, size );
Ftbitmap.c (components\external\freetype\src\base):        FT_MEM_COPY( target->buffer, source->buffer, size );
Ftbzip2.c (components\external\freetype\src\bzip2):                  int        size )
Ftbzip2.c (components\external\freetype\src\bzip2):    FT_ULong    sz = (FT_ULong)size * items;
Ftbzip2.c (components\external\freetype\src\bzip2):    FT_ULong    size;
Ftbzip2.c (components\external\freetype\src\bzip2):      size = stream->read( stream, stream->pos, zip->input,
Ftbzip2.c (components\external\freetype\src\bzip2):      if ( size == 0 )
Ftbzip2.c (components\external\freetype\src\bzip2):      size = stream->size - stream->pos;
Ftbzip2.c (components\external\freetype\src\bzip2):      if ( size > FT_BZIP2_BUFFER_SIZE )
Ftbzip2.c (components\external\freetype\src\bzip2):        size = FT_BZIP2_BUFFER_SIZE;
Ftbzip2.c (components\external\freetype\src\bzip2):      if ( size == 0 )
Ftbzip2.c (components\external\freetype\src\bzip2):      FT_MEM_COPY( zip->input, stream->base + stream->pos, size );
Ftbzip2.c (components\external\freetype\src\bzip2):    stream->pos += size;
Ftbzip2.c (components\external\freetype\src\bzip2):    bzstream->avail_in = size;
Ftbzip2.c (components\external\freetype\src\bzip2):    stream->size  = 0x7FFFFFFFL;  /* don't know the real size! */
Ftcache.h (components\external\freetype\include):   *    How to cache face, size, and glyph data with FreeType~2.
Ftcache.h (components\external\freetype\include):  /*    The @FT_Face object doesn't necessarily have a current size object */
Ftcache.h (components\external\freetype\include):  /*    (i.e., face->size can be~0).  If you need a specific `font size',  */
Ftcache.h (components\external\freetype\include):  /*    A structure used to describe a given character size in either      */
Ftcache.h (components\external\freetype\include):  /*    asize   :: A handle to the size object.                            */
Ftcache.h (components\external\freetype\include):  /*    You can access the parent @FT_Face object simply as `size->face'   */
Ftcache.h (components\external\freetype\include):  /*    to specify the face ID and its size.                               */
Ftcache.h (components\external\freetype\include):  /*    to specify the face ID and its size.                               */
Ftcbasic.c (components\external\freetype\src\cache):    FT_Size          size;
Ftcbasic.c (components\external\freetype\src\cache):    error = FTC_Manager_LookupSize( manager, &family->attrs.scaler, &size );
Ftcbasic.c (components\external\freetype\src\cache):      FT_Face  face = size->face;
Ftcbasic.c (components\external\freetype\src\cache):    FT_Size          size;
Ftcbasic.c (components\external\freetype\src\cache):                                    &size );
Ftcbasic.c (components\external\freetype\src\cache):      face = size->face;
Ftccache.c (components\external\freetype\src\cache):  /* Note that this function cannot fail.  If we cannot re-size the
Ftccache.h (components\external\freetype\src\cache):  /* glyphs for a given size, some metrics, etc.                           */
Ftccache.h (components\external\freetype\src\cache):  /* structure size should be 20 bytes on 32-bits machines */
Ftcglyph.h (components\external\freetype\src\cache):   *   - Glyph attributes, like face ID, character size, render mode, etc.,
Ftcglyph.h (components\external\freetype\src\cache):  *  given face ID, character size, transform, etc.
Ftcimage.c (components\external\freetype\src\cache):    FT_Offset  size  = 0;
Ftcimage.c (components\external\freetype\src\cache):        size = bitg->bitmap.rows * ft_labs( bitg->bitmap.pitch ) +
Ftcimage.c (components\external\freetype\src\cache):        size = outg->outline.n_points *
Ftcimage.c (components\external\freetype\src\cache):    size += sizeof ( *inode );
Ftcimage.c (components\external\freetype\src\cache):    return size;
Ftcmanag.c (components\external\freetype\src\cache):    FT_Size   size = NULL;
Ftcmanag.c (components\external\freetype\src\cache):    error = FT_New_Size( face, &size );
Ftcmanag.c (components\external\freetype\src\cache):    FT_Activate_Size( size );
Ftcmanag.c (components\external\freetype\src\cache):      FT_Done_Size( size );
Ftcmanag.c (components\external\freetype\src\cache):      size = NULL;
Ftcmanag.c (components\external\freetype\src\cache):    *asize = size;
Ftcmanag.c (components\external\freetype\src\cache):    FT_Size         size;
Ftcmanag.c (components\external\freetype\src\cache):    FT_Size       size = node->size;
Ftcmanag.c (components\external\freetype\src\cache):    if ( size )
Ftcmanag.c (components\external\freetype\src\cache):      FT_Done_Size( size );
Ftcmanag.c (components\external\freetype\src\cache):      FT_Activate_Size( node->size );
Ftcmanag.c (components\external\freetype\src\cache):    return ftc_scaler_lookup_size( manager, scaler, &node->size );
Ftcmanag.c (components\external\freetype\src\cache):    FT_Done_Size( node->size );
Ftcmanag.c (components\external\freetype\src\cache):    return ftc_scaler_lookup_size( manager, scaler, &node->size );
Ftcmanag.c (components\external\freetype\src\cache):      *asize = FTC_SIZE_NODE( mrunode )->size;
Ftcmanag.c (components\external\freetype\src\cache):      /* destroy initial size object; it will be re-created later */
Ftcmanag.c (components\external\freetype\src\cache):      if ( node->face->size )
Ftcmanag.c (components\external\freetype\src\cache):        FT_Done_Size( node->face->size );
Ftcmanag.h (components\external\freetype\src\cache):  /*    Each cache node has a certain size in bytes that is added to the   */
Ftconfig.h (components\external\freetype\builds\vms):  /*    A typedef for a 32bit signed integer type.  The size depends on    */
Ftconfig.h (components\external\freetype\builds\vms):  /*    A typedef for a 32bit unsigned integer type.  The size depends on  */
Ftconfig.h (components\external\freetype\builds\vms):  /*    A typedef for a 64bit signed integer type.  The size depends on    */
Ftconfig.h (components\external\freetype\builds\vms):  /*    A typedef for a 64bit unsigned integer type.  The size depends on  */
Ftconfig.h (components\external\freetype\include\config):  /* The size of an `int' type.  */
Ftconfig.h (components\external\freetype\include\config):#error "Unsupported size of `int' type!"
Ftconfig.h (components\external\freetype\include\config):  /* The size of a `long' type.  A five-byte `long' (as used e.g. on the */
Ftconfig.h (components\external\freetype\include\config):#error "Unsupported size of `long' type!"
Ftconfig.h (components\external\freetype\include\config):  /*    A typedef for a 32bit signed integer type.  The size depends on    */
Ftconfig.h (components\external\freetype\include\config):  /*    A typedef for a 32bit unsigned integer type.  The size depends on  */
Ftconfig.h (components\external\freetype\include\config):  /*    A typedef for a 64bit signed integer type.  The size depends on    */
Ftconfig.h (components\external\freetype\include\config):  /*    A typedef for a 64bit unsigned integer type.  The size depends on  */
Ftcsbits.c (components\external\freetype\src\cache):    FT_ULong  size;
Ftcsbits.c (components\external\freetype\src\cache):    size = (FT_ULong)( pitch * bitmap->rows );
Ftcsbits.c (components\external\freetype\src\cache):    if ( !FT_ALLOC( sbit->buffer, size ) )
Ftcsbits.c (components\external\freetype\src\cache):      FT_MEM_COPY( sbit->buffer, bitmap->buffer, size );
Ftcsbits.c (components\external\freetype\src\cache):      /* now, compute size */
Ftcsbits.c (components\external\freetype\src\cache):    FT_Offset  size;
Ftcsbits.c (components\external\freetype\src\cache):    size = sizeof ( *snode );
Ftcsbits.c (components\external\freetype\src\cache):        /* add the size of a given glyph image */
Ftcsbits.c (components\external\freetype\src\cache):        size += pitch * sbit->height;
Ftcsbits.c (components\external\freetype\src\cache):    return size;
Ftcsbits.c (components\external\freetype\src\cache):        FT_ULong  size;
Ftcsbits.c (components\external\freetype\src\cache):          error = ftc_snode_load( snode, cache->manager, gindex, &size );
Ftcsbits.c (components\external\freetype\src\cache):          cache->manager->cur_weight += size;
Ftdbgmem.c (components\external\freetype\src\base):    FT_Long       cur_size;     /* current cumulative allocated size */
Ftdbgmem.c (components\external\freetype\src\base):    FT_Long       max_size;     /* maximum cumulative allocated size */
Ftdbgmem.c (components\external\freetype\src\base):    FT_Long       all_size;     /* total cumulative allocated size   */
Ftdbgmem.c (components\external\freetype\src\base):    FT_Long       cur_max;      /* current maximum allocated size */
Ftdbgmem.c (components\external\freetype\src\base):   *  FreeType are never released to the system.  Instead, their `size'
Ftdbgmem.c (components\external\freetype\src\base):   *  field is set to -size.  This is mainly useful to detect double frees,
Ftdbgmem.c (components\external\freetype\src\base):    FT_Long       size;     /* < 0 if the block was freed */
Ftdbgmem.c (components\external\freetype\src\base):    FT_ULong         size;
Ftdbgmem.c (components\external\freetype\src\base):                      FT_Long      size )
Ftdbgmem.c (components\external\freetype\src\base):    block = table->alloc( memory, size );
Ftdbgmem.c (components\external\freetype\src\base):    if ( new_size != table->size )
Ftdbgmem.c (components\external\freetype\src\base):      for ( i = 0; i < table->size; i++ )
Ftdbgmem.c (components\external\freetype\src\base):      table->size    = new_size;
Ftdbgmem.c (components\external\freetype\src\base):    table->size  = FT_MEM_SIZE_MIN;
Ftdbgmem.c (components\external\freetype\src\base):                                      table->size * sizeof ( FT_MemNode ) );
Ftdbgmem.c (components\external\freetype\src\base):      FT_ARRAY_ZERO( table->buckets, table->size );
Ftdbgmem.c (components\external\freetype\src\base):    for ( i = 0; i < table->size; i++ )
Ftdbgmem.c (components\external\freetype\src\base):        if ( node->size > 0 )
Ftdbgmem.c (components\external\freetype\src\base):            "leaked memory block at address %p, size %8ld in (%s:%ld)\n",
Ftdbgmem.c (components\external\freetype\src\base):            node->address, node->size,
Ftdbgmem.c (components\external\freetype\src\base):          leaks += node->size;
Ftdbgmem.c (components\external\freetype\src\base):        node->size    = 0;
Ftdbgmem.c (components\external\freetype\src\base):    table->size  = 0;
Ftdbgmem.c (components\external\freetype\src\base):    pnode = table->buckets + ( hash % table->size );
Ftdbgmem.c (components\external\freetype\src\base):                    FT_ULong     size,
Ftdbgmem.c (components\external\freetype\src\base):        if ( node->size < 0 )
Ftdbgmem.c (components\external\freetype\src\base):            " %p, of size %ld)\n"
Ftdbgmem.c (components\external\freetype\src\base):            node->address, node->size,
Ftdbgmem.c (components\external\freetype\src\base):      node->size    = size;
Ftdbgmem.c (components\external\freetype\src\base):      if ( size > (FT_ULong)source->cur_max )
Ftdbgmem.c (components\external\freetype\src\base):        source->cur_max = size;
Ftdbgmem.c (components\external\freetype\src\base):        source->cur_size     += size;
Ftdbgmem.c (components\external\freetype\src\base):        table->alloc_current += size;
Ftdbgmem.c (components\external\freetype\src\base):      source->all_size += size;
Ftdbgmem.c (components\external\freetype\src\base):      table->alloc_total += size;
Ftdbgmem.c (components\external\freetype\src\base):      if ( table->nodes * 3 < table->size  ||
Ftdbgmem.c (components\external\freetype\src\base):           table->size  * 3 < table->nodes )
Ftdbgmem.c (components\external\freetype\src\base):        if ( node->size < 0 )
Ftdbgmem.c (components\external\freetype\src\base):        FT_MEM_SET( address, 0xF3, node->size );
Ftdbgmem.c (components\external\freetype\src\base):          source->cur_size -= node->size;
Ftdbgmem.c (components\external\freetype\src\base):          table->alloc_current -= node->size;
Ftdbgmem.c (components\external\freetype\src\base):          /* we simply invert the node's size to indicate that the node */
Ftdbgmem.c (components\external\freetype\src\base):          node->size           = -node->size;
Ftdbgmem.c (components\external\freetype\src\base):          node->size   = 0;
Ftdbgmem.c (components\external\freetype\src\base):          if ( table->nodes * 3 < table->size  ||
Ftdbgmem.c (components\external\freetype\src\base):               table->size  * 3 < table->nodes )
Ftdbgmem.c (components\external\freetype\src\base):                      FT_Long    size )
Ftdbgmem.c (components\external\freetype\src\base):    if ( size <= 0 )
Ftdbgmem.c (components\external\freetype\src\base):      ft_mem_debug_panic( "negative block size allocation (%ld)", size );
Ftdbgmem.c (components\external\freetype\src\base):    /* return NULL if this allocation would overflow the maximum heap size */
Ftdbgmem.c (components\external\freetype\src\base):         table->alloc_total_max - table->alloc_current > (FT_ULong)size )
Ftdbgmem.c (components\external\freetype\src\base):    block = (FT_Byte *)ft_mem_table_alloc( table, size );
Ftdbgmem.c (components\external\freetype\src\base):      ft_mem_table_set( table, block, (FT_ULong)size, 0 );
Ftdbgmem.c (components\external\freetype\src\base):        "trying to reallocate %p to size 0 (current is %ld) in (%s:%ld)",
Ftdbgmem.c (components\external\freetype\src\base):    if ( node->size <= 0 )
Ftdbgmem.c (components\external\freetype\src\base):    if ( node->size != cur_size )
Ftdbgmem.c (components\external\freetype\src\base):                          block, cur_size, node->size, file_name, line_no );
Ftdbgmem.c (components\external\freetype\src\base):    /* return NULL if this allocation would overflow the maximum heap size */
Ftdriver.h (components\external\freetype\include\internal):  (*FT_Size_InitFunc)( FT_Size  size );
Ftdriver.h (components\external\freetype\include\internal):  (*FT_Size_DoneFunc)( FT_Size  size );
Ftdriver.h (components\external\freetype\include\internal):  (*FT_Size_RequestFunc)( FT_Size          size,
Ftdriver.h (components\external\freetype\include\internal):  (*FT_Size_SelectFunc)( FT_Size   size,
Ftdriver.h (components\external\freetype\include\internal):                       FT_Size       size,
Ftdriver.h (components\external\freetype\include\internal):  /*    face_object_size :: The size of a face object in bytes.            */
Ftdriver.h (components\external\freetype\include\internal):  /*    size_object_size :: The size of a size object in bytes.            */
Ftdriver.h (components\external\freetype\include\internal):  /*    slot_object_size :: The size of a glyph object in bytes.           */
Ftdriver.h (components\external\freetype\include\internal):  /*    init_size        :: The format-specific size constructor.          */
Ftdriver.h (components\external\freetype\include\internal):  /*    done_size        :: The format-specific size destructor.           */
Ftdriver.h (components\external\freetype\include\internal):  /*                        character size.  Can be set to 0 if the        */
Ftdriver.h (components\external\freetype\include\internal):  /*                        fixed size.  It is used only if                */
Fterrdef.h (components\external\freetype\include):                "array allocation size too large" )
Fterrdef.h (components\external\freetype\include):                "invalid pixel size" )
Fterrdef.h (components\external\freetype\include):                "invalid size handle" )
Ftgasp.h (components\external\freetype\include):   *   return the entry corresponding to a given character pixel size.
Ftgasp.h (components\external\freetype\include):   *   ppem :: The vertical character pixel size.
Ftgrays.c (components\external\freetype\src\smooth):  /* approximately determine the size of integers using an ANSI-C header */
Ftgxval.h (components\external\freetype\include):  *       The size of the `tables' array.  Normally, @FT_VALIDATE_GX_LENGTH
Ftgzip.c (components\external\freetype\src\gzip):                 uInt       size )
Ftgzip.c (components\external\freetype\src\gzip):    FT_ULong    sz = (FT_ULong)size * items;
Ftgzip.c (components\external\freetype\src\gzip):            unsigned  size )
Ftgzip.c (components\external\freetype\src\gzip):    return ft_gzip_alloc( (FT_Memory)opaque, items, size );
Ftgzip.c (components\external\freetype\src\gzip):    FT_ULong   size;
Ftgzip.c (components\external\freetype\src\gzip):      size = stream->read( stream, stream->pos, zip->input,
Ftgzip.c (components\external\freetype\src\gzip):      if ( size == 0 )
Ftgzip.c (components\external\freetype\src\gzip):      size = stream->size - stream->pos;
Ftgzip.c (components\external\freetype\src\gzip):      if ( size > FT_GZIP_BUFFER_SIZE )
Ftgzip.c (components\external\freetype\src\gzip):        size = FT_GZIP_BUFFER_SIZE;
Ftgzip.c (components\external\freetype\src\gzip):      if ( size == 0 )
Ftgzip.c (components\external\freetype\src\gzip):      FT_MEM_COPY( zip->input, stream->base + stream->pos, size );
Ftgzip.c (components\external\freetype\src\gzip):    stream->pos += size;
Ftgzip.c (components\external\freetype\src\gzip):    zstream->avail_in = size;
Ftgzip.c (components\external\freetype\src\gzip):    if ( !FT_Stream_Seek( stream, stream->size - 4 ) )
Ftgzip.c (components\external\freetype\src\gzip):     *  size is less than a certain threshold, we try to load the whole font
Ftgzip.c (components\external\freetype\src\gzip):            stream->size  = zip_size;
Ftgzip.c (components\external\freetype\src\gzip):    stream->size  = 0x7FFFFFFFL;  /* don't know the real size! */
Ftgzip.h (components\external\freetype\include):  *     Before calling the function, this is the the total size of the
Ftgzip.h (components\external\freetype\include):  *     uncompressed data (so the size of the uncompressed data must be
Ftgzip.h (components\external\freetype\include):  *     size of the used data in `output'.
Ftimage.h (components\external\freetype\include):  /*    pool_size :: The size in bytes of the render pool.                 */
Ftlzw.c (components\external\freetype\src\lzw):    stream->size  = 0x7FFFFFFFL;  /* don't know the real size! */
Ftmac.c (components\external\freetype\builds\mac):    sfnt fonts, bitmap glyph data for each size is stored in each `NFNT'
Ftmac.c (components\external\freetype\builds\mac):          FMFontSize   size;
Ftmac.c (components\external\freetype\builds\mac):                                               &style, &size );
Ftmac.c (components\external\freetype\builds\mac):          if ( stat2 == 0 && size == 0 )
Ftmac.c (components\external\freetype\builds\mac):    stream->size               = 0;
Ftmac.c (components\external\freetype\builds\mac):    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */
Ftmac.c (components\external\freetype\builds\mac):             FT_ULong*      size )
Ftmac.c (components\external\freetype\builds\mac):    /* First pass: load all POST resources, and determine the size of */
Ftmac.c (components\external\freetype\builds\mac):          /* we are done adding a chunk, fill in the size field */
Ftmac.c (components\external\freetype\builds\mac):          p += 4;       /* make space for size field */
Ftmac.c (components\external\freetype\builds\mac):    *size = total_size;
Ftmac.c (components\external\freetype\src\base):    sfnt fonts, bitmap glyph data for each size is stored in each `NFNT'
Ftmac.c (components\external\freetype\src\base):    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */
Ftmac.c (components\external\freetype\src\base):             FT_ULong*      size )
Ftmac.c (components\external\freetype\src\base):    /* First pass: load all POST resources, and determine the size of */
Ftmac.c (components\external\freetype\src\base):          /* we are done adding a chunk, fill in the size field */
Ftmac.c (components\external\freetype\src\base):          p += 4;       /* make space for size field */
Ftmac.c (components\external\freetype\src\base):    *size = total_size;
Ftmemory.h (components\external\freetype\include\internal):                FT_Long    size,
Ftmemory.h (components\external\freetype\include\internal):                 FT_Long    size,
Ftmemory.h (components\external\freetype\include\internal):#define FT_MEM_ALLOC( ptr, size )                               \
Ftmemory.h (components\external\freetype\include\internal):                                               (FT_Long)(size), \
Ftmemory.h (components\external\freetype\include\internal):#define FT_MEM_QALLOC( ptr, size )                               \
Ftmemory.h (components\external\freetype\include\internal):                                                (FT_Long)(size), \
Ftmemory.h (components\external\freetype\include\internal):#define FT_ALLOC( ptr, size )                           \
Ftmemory.h (components\external\freetype\include\internal):          FT_MEM_SET_ERROR( FT_MEM_ALLOC( ptr, size ) )
Ftmemory.h (components\external\freetype\include\internal):#define FT_QALLOC( ptr, size )                           \
Ftmemory.h (components\external\freetype\include\internal):          FT_MEM_SET_ERROR( FT_MEM_QALLOC( ptr, size ) )
Ftmemory.h (components\external\freetype\include\internal):              FT_ULong     size,
Ftmemory.h (components\external\freetype\include\internal):#define FT_MEM_DUP( dst, address, size )                                    \
Ftmemory.h (components\external\freetype\include\internal):          (dst) = ft_mem_dup( memory, (address), (FT_ULong)(size), &error )
Ftmemory.h (components\external\freetype\include\internal):#define FT_DUP( dst, address, size )                           \
Ftmemory.h (components\external\freetype\include\internal):          FT_MEM_SET_ERROR( FT_MEM_DUP( dst, address, size ) )
Ftmemory.h (components\external\freetype\include\internal):                  FT_ULong     size );
Ftmemory.h (components\external\freetype\include\internal):#define FT_STRCPYN( dst, src, size )                                         \
Ftmemory.h (components\external\freetype\include\internal):          ft_mem_strcpyn( (char*)dst, (const char*)(src), (FT_ULong)(size) )
Ftmisc.h (components\external\freetype\src\raster):                                  long       size );
Ftmodapi.h (components\external\freetype\include):  /*    module_size     :: The size of one module object/instance in       */
Ftobjs.c (components\external\freetype\src\base):                             FT_ULong      size )
Ftobjs.c (components\external\freetype\src\base):    (void)FT_ALLOC( slot->bitmap.buffer, size );
Ftobjs.c (components\external\freetype\src\base):    if ( !face || !face->size || !face->glyph )
Ftobjs.c (components\external\freetype\src\base):        /* check the size of the `fpgm' and `prep' tables, too --    */
Ftobjs.c (components\external\freetype\src\base):        error = driver->clazz->load_glyph( slot, face->size,
Ftobjs.c (components\external\freetype\src\base):                                       slot, face->size,
Ftobjs.c (components\external\freetype\src\base):                                         face->size,
Ftobjs.c (components\external\freetype\src\base):      FT_Size_Metrics*  metrics = &face->size->metrics;
Ftobjs.c (components\external\freetype\src\base):                FT_Size    size,
Ftobjs.c (components\external\freetype\src\base):    if ( size->generic.finalizer )
Ftobjs.c (components\external\freetype\src\base):      size->generic.finalizer( size );
Ftobjs.c (components\external\freetype\src\base):      driver->clazz->done_size( size );
Ftobjs.c (components\external\freetype\src\base):    FT_FREE( size->internal );
Ftobjs.c (components\external\freetype\src\base):    FT_FREE( size );
Ftobjs.c (components\external\freetype\src\base):    face->size = 0;
Ftobjs.c (components\external\freetype\src\base):    stream->size  = 0;
Ftobjs.c (components\external\freetype\src\base):  /* Create a new memory stream from a buffer and a size. */
Ftobjs.c (components\external\freetype\src\base):                     FT_ULong             size,
Ftobjs.c (components\external\freetype\src\base):    FT_Stream_OpenMemory( stream, base, size );
Ftobjs.c (components\external\freetype\src\base):                         FT_ULong     size,
Ftobjs.c (components\external\freetype\src\base):                               size,
Ftobjs.c (components\external\freetype\src\base):    FT_TRACE2(( "             total buffer size to concatenate %d"
Ftobjs.c (components\external\freetype\src\base):      /* finally, allocate a size object for the face */
Ftobjs.c (components\external\freetype\src\base):        FT_Size  size;
Ftobjs.c (components\external\freetype\src\base):        FT_TRACE4(( "FT_Open_Face: Creating size object\n" ));
Ftobjs.c (components\external\freetype\src\base):        error = FT_New_Size( face, &size );
Ftobjs.c (components\external\freetype\src\base):        face->size = size;
Ftobjs.c (components\external\freetype\src\base):    FT_Size          size = 0;
Ftobjs.c (components\external\freetype\src\base):    /* Allocate new size object and perform basic initialisation */
Ftobjs.c (components\external\freetype\src\base):    if ( FT_ALLOC( size, clazz->size_object_size ) || FT_NEW( node ) )
Ftobjs.c (components\external\freetype\src\base):    size->face = face;
Ftobjs.c (components\external\freetype\src\base):    /* for now, do not use any internal fields in size objects */
Ftobjs.c (components\external\freetype\src\base):    size->internal = 0;
Ftobjs.c (components\external\freetype\src\base):      error = clazz->init_size( size );
Ftobjs.c (components\external\freetype\src\base):      *asize     = size;
Ftobjs.c (components\external\freetype\src\base):      node->data = size;
Ftobjs.c (components\external\freetype\src\base):      FT_FREE( size );
Ftobjs.c (components\external\freetype\src\base):  FT_Done_Size( FT_Size  size )
Ftobjs.c (components\external\freetype\src\base):    if ( !size )
Ftobjs.c (components\external\freetype\src\base):    face = size->face;
Ftobjs.c (components\external\freetype\src\base):    node  = FT_List_Find( &face->sizes_list, size );
Ftobjs.c (components\external\freetype\src\base):      if ( face->size == size )
Ftobjs.c (components\external\freetype\src\base):        face->size = 0;
Ftobjs.c (components\external\freetype\src\base):          face->size = (FT_Size)(face->sizes_list.head->data);
Ftobjs.c (components\external\freetype\src\base):      destroy_size( memory, size, driver );
Ftobjs.c (components\external\freetype\src\base):    metrics = &face->size->metrics;
Ftobjs.c (components\external\freetype\src\base):    metrics = &face->size->metrics;
Ftobjs.c (components\external\freetype\src\base):      error = clazz->select_size( face->size, (FT_ULong)strike_index );
Ftobjs.c (components\external\freetype\src\base):        FT_Size_Metrics*  metrics = &face->size->metrics;
Ftobjs.c (components\external\freetype\src\base):      error = clazz->request_size( face->size, req );
Ftobjs.c (components\external\freetype\src\base):        FT_Size_Metrics*  metrics = &face->size->metrics;
Ftobjs.c (components\external\freetype\src\base):     * are bitmap-only and size matching is not implemented.
Ftobjs.c (components\external\freetype\src\base):     * In the latter case, a simple size matching is done.
Ftobjs.c (components\external\freetype\src\base):          akerning->x = FT_MulFix( akerning->x, face->size->metrics.x_scale );
Ftobjs.c (components\external\freetype\src\base):          akerning->y = FT_MulFix( akerning->y, face->size->metrics.y_scale );
Ftobjs.c (components\external\freetype\src\base):            if ( face->size->metrics.x_ppem < 25 )
Ftobjs.c (components\external\freetype\src\base):                                       face->size->metrics.x_ppem, 25 );
Ftobjs.c (components\external\freetype\src\base):            if ( face->size->metrics.y_ppem < 25 )
Ftobjs.c (components\external\freetype\src\base):                                       face->size->metrics.y_ppem, 25 );
Ftobjs.c (components\external\freetype\src\base):    if ( !FT_ALLOC( cmap, clazz->size ) )
Ftobjs.c (components\external\freetype\src\base):  FT_Activate_Size( FT_Size  size )
Ftobjs.c (components\external\freetype\src\base):    if ( !size )
Ftobjs.c (components\external\freetype\src\base):    face = size->face;
Ftobjs.c (components\external\freetype\src\base):    /* we don't need anything more complex than that; all size objects */
Ftobjs.c (components\external\freetype\src\base):    face->size = size;
Ftobjs.h (components\external\freetype\include\internal):    FT_ULong               size;
Ftobjs.h (components\external\freetype\include\internal):    clazz->size             = size_;                     \
Ftobjs.h (components\external\freetype\include\internal):#define FT_FACE_SIZE( x )     FT_FACE( x )->size
Ftobjs.h (components\external\freetype\include\internal):  /* Set the metrics according to a size request. */
Ftobjs.h (components\external\freetype\include\internal):  /* Match a size request against `available_sizes'. */
Ftobjs.h (components\external\freetype\include\internal):                             FT_ULong      size );
Ftobjs.h (components\external\freetype\include\internal):  /*    raster_pool_size :: The size of the render pool in bytes.          */
Ftobjs.h (components\external\freetype\include\internal):    FT_ULong           raster_pool_size; /* size of render pool in bytes */
Ftoption.h (components\external\freetype\builds\rt-thread):  /* the original size in case this macro isn't defined; however, each     */
Ftoption.h (components\external\freetype\builds\rt-thread):  /* The size in bytes of the render pool used by the scan-line converter  */
Ftoption.h (components\external\freetype\devel):  /* the original size in case this macro isn't defined; however, each     */
Ftoption.h (components\external\freetype\devel):  /* The size in bytes of the render pool used by the scan-line converter  */
Ftoption.h (components\external\freetype\include\config):  /* the original size in case this macro isn't defined; however, each     */
Ftoption.h (components\external\freetype\include\config):  /* The size in bytes of the render pool used by the scan-line converter  */
Ftoutln.h (components\external\freetype\include):  /*    Create a new outline of a given size.                              */
Ftpatent.c (components\external\freetype\src\base):                              FT_ULong   size )
Ftpatent.c (components\external\freetype\src\base):    if ( FT_FRAME_ENTER( size ) )
Ftpatent.c (components\external\freetype\src\base):    end = p + size;
Ftpatent.c (components\external\freetype\src\base):      FT_ULong  offset, num_ins, size;
Ftpatent.c (components\external\freetype\src\base):      offset = service->get_location( face, gindex, &size );
Ftpatent.c (components\external\freetype\src\base):      if ( size == 0 )
Ftpd.c (components\net\lwip-1.3.2\apps):static int build_full_path(struct ftp_session* session, char* path, char* new_path, size_t size)
Ftpd.c (components\net\lwip\apps):int build_full_path(struct ftp_session* session, char* path, char* new_path, size_t size)
Ftpfr.c (components\external\freetype\src\base):      if ( face->size )
Ftpfr.c (components\external\freetype\src\base):        x_scale = face->size->metrics.x_scale;
Ftpfr.c (components\external\freetype\src\base):        y_scale = face->size->metrics.y_scale;
Ftpfr.h (components\external\freetype\include):  *      `face->size->x_scale', but for metrics only.  Optional (parameter
Ftrandom.c (components\external\freetype\src\tools\ftrandom):    fprintf( out, "  --size <float>           Use the given font size for the tests.\n" );
Ftrandom.c (components\external\freetype\src\tools\ftrandom):      else if ( strcmp( pt, "-size" ) == 0 )
Ftrandom.c (components\external\freetype\src\tools\ftrandom):          fprintf( stderr, "Bad value for size: %s\n", argv[i] );
Ftraster.c (components\external\freetype\src\raster):  /* The size of the two-lines intermediate bitmap used */
Ftraster.c (components\external\freetype\src\raster):    PLong       sizeBuff;           /* Render pool size                    */
Ftraster.c (components\external\freetype\src\raster):    PLong       maxBuff;            /* Profiles buffer size                */
Ftraster.c (components\external\freetype\src\raster):                       /* The gray_lines must hold 2 lines, thus with size */
Ftraster.c (components\external\freetype\src\raster):    Int    e1, e2, f1, f2, size;     /* XXX: is `Short' sufficient? */
Ftraster.c (components\external\freetype\src\raster):    size = e2 - e1 + 1;
Ftraster.c (components\external\freetype\src\raster):    if ( ras.top + size >= ras.maxBuff )
Ftraster.c (components\external\freetype\src\raster):    while ( size > 0 )
Ftraster.c (components\external\freetype\src\raster):      size--;
Fts1.c (components\external\sqlite-3.8.1\ext\fts1):  int iStart, int nByte     /* Offset and size of the match */
Fts1_hash.c (components\external\sqlite-3.8.1\ext\fts1):  int h;                    /* the hash of the key modulo hash table size */
Fts1_porter.c (components\external\sqlite-3.8.1\ext\fts1):  int nInput;                  /* size of the input */
Fts1_porter.c (components\external\sqlite-3.8.1\ext\fts1):** size of the output word (exclusive of the '\0' terminator) into *pnOut.
Fts1_tokenizer1.c (components\external\sqlite-3.8.1\ext\fts1):  int nBytes;                  /* size of the input */
Fts2.c (components\external\sqlite-3.8.1\ext\fts2):  /* Conservatively size output to sum of inputs.  Output should end
Fts2.c (components\external\sqlite-3.8.1\ext\fts2):  ** nPendingData estimates the memory size of the pending data.  It
Fts2.c (components\external\sqlite-3.8.1\ext\fts2):  int iStart, int nByte     /* Offset and size of the match */
Fts2.c (components\external\sqlite-3.8.1\ext\fts2):/* Keep leaf blocks below this size. */
Fts2.c (components\external\sqlite-3.8.1\ext\fts2):  ** we ordered the doclists by size and flushed the largest until the
Fts2.c (components\external\sqlite-3.8.1\ext\fts2):** size grows exponentially (so segment count logrithmically) this is
Fts2_hash.c (components\external\sqlite-3.8.1\ext\fts2):  int h;                    /* the hash of the key modulo hash table size */
Fts2_porter.c (components\external\sqlite-3.8.1\ext\fts2):  int nInput;                  /* size of the input */
Fts2_porter.c (components\external\sqlite-3.8.1\ext\fts2):** size of the output word (exclusive of the '\0' terminator) into *pnOut.
Fts2_tokenizer1.c (components\external\sqlite-3.8.1\ext\fts2):  int nBytes;                  /* size of the input */
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):        "CREATE TABLE %Q.'%q_docsize'(docid INTEGER PRIMARY KEY, size BLOB);",
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** Store the current database page-size in bytes in p->nPgsz.
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):  int *pnIndex,                   /* OUT: size of *apIndex[] array */
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):  /* Figure out the page-size for the database. This is required in order to
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):    int nBuffer;                  /* Total term size */
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):    ** the size of zBuffer if required.  */
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** The buffer pointed to by argument zNode (size nNode bytes) contains an
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** interior node of a b-tree segment. The zTerm buffer (size nTerm bytes)
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** Argument pList points to a position list nList bytes in size. This
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** in buffer aList[], size nList bytes.
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** If the value passed as the third argument is a blob of size
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** Determine the average document (row) size in pages. If successful,
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** The average document size in pages is calculated by first calculating 
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** determining the average size in bytes, B. If B is less than the amount
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):** the number of overflow pages consumed by a record B bytes in size.
Fts3.c (components\external\sqlite-3.8.1\ext\fts3):    /* The average document size, which is required to calculate the cost
fts3Int.h (components\external\sqlite-3.8.1\ext\fts3):  int nNodeSize;                  /* Soft limit for node size */
fts3Int.h (components\external\sqlite-3.8.1\ext\fts3):  int nPgsz;                      /* Page size for host database */
fts3Int.h (components\external\sqlite-3.8.1\ext\fts3):  int nRowAvg;                    /* Average size of database rows, in pages */
fts3Int.h (components\external\sqlite-3.8.1\ext\fts3):** points to a malloced buffer, size nDoclist bytes, containing the results 
fts3Int.h (components\external\sqlite-3.8.1\ext\fts3):** matchinfo data. If it is not NULL, it points to an array of size nCol*3,
fts3Int.h (components\external\sqlite-3.8.1\ext\fts3):  int nBuffer;                    /* Allocated size of aBuffer[] in bytes */
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Total size of all segments............... %9lld\n", szSeg+szRoot);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Total size of all leaf segments.......... %9lld\n", szSeg-szIdx);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Total size of all index segments......... %9lld\n", szIdx);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Total size of all root segments.......... %9lld\n", szRoot);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):    printf("Average size of all segments............. %11.1f\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):    printf("Average size of leaf segments............ %11.1f\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):    printf("Average size of index segments........... %11.1f\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):    printf("Average size of root segments............ %11.1f\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Maximum segment size..................... %9lld\n", mx);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Maximum index segment size............... %9lld\n", mxIdx);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Maximum root segment size................ %9lld\n", mxRoot);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Database page size....................... %9d\n", pgsz);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):      printf("  Total size of all leaf segments........ %9lld\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):      printf("  Average size of leaf segments.......... %11.1f\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):        printf("  Average leaf segment size per index.... %11.1f\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):      printf("  Maximum leaf segment size.............. %9lld\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Segment %s of size %d bytes:\n", azExtra[0], nData);
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):** into the segment is identified by azExtra[1].  The size of the doclist
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):  printf("Doclist at %s offset %lld of size %lld bytes:\n",
Fts3view.c (components\external\sqlite-3.8.1\ext\fts3\tool):    printf("  %2d. %9lld size %lld\n", i, id, sz);
Fts3_hash.c (components\external\sqlite-3.8.1\ext\fts3):  int h;                    /* the hash of the key modulo hash table size */
Fts3_porter.c (components\external\sqlite-3.8.1\ext\fts3):  int nInput;                  /* size of the input */
Fts3_porter.c (components\external\sqlite-3.8.1\ext\fts3):** size of the output word (exclusive of the '\0' terminator) into *pnOut.
Fts3_snippet.c (components\external\sqlite-3.8.1\ext\fts3):  SnippetPhrase *aPhrase;         /* Array of size nPhrase */
Fts3_snippet.c (components\external\sqlite-3.8.1\ext\fts3):  int nAlloc;                     /* Allocated size of buffer z in bytes */
Fts3_snippet.c (components\external\sqlite-3.8.1\ext\fts3):  ** size that contains at least one instance of all phrases in the query
Fts3_test.c (components\external\sqlite-3.8.1\ext\fts3):** size eligible for incremental loading, and the size of the chunks loaded
Fts3_test.c (components\external\sqlite-3.8.1\ext\fts3):** in. The second argument is the minimum doclist size in bytes to use
Fts3_tokenizer1.c (components\external\sqlite-3.8.1\ext\fts3):  int nBytes;                  /* size of the input */
Fts3_unicode2.c (components\external\sqlite-3.8.1\ext\fts3):  ** the size of the range (always at least 1). In other words, the value 
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** of it. i.e. if a full-text index node is 900 bytes in size, then a buffer
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  int nTermAlloc;                 /* Allocated size of zTerm buffer */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):/* 21 */  "SELECT size FROM %Q.'%q_docsize' WHERE docid=?",
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  sqlite3_int64 iDocid,           /* Docid to read size data for */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** document terms, and each configured prefix size (configured the FTS 
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  ** we ordered the doclists by size and flushed the largest until the
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** to the size of the blob in bytes before returning.
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):    ** size of the previous offset-list.
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** Return the size of the common prefix (if any) shared by zPrev and
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):    int nData = pTree->nData;     /* Current size of node in bytes */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  nReq = sqlite3Fts3VarintLen(nPrefix) +    /* varint containing prefix size */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):    sqlite3Fts3VarintLen(nSuffix) +         /* varint containing suffix size */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):    nReq = 1 +                              /* varint containing prefix size */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):      sqlite3Fts3VarintLen(nTerm) +         /* varint containing suffix size */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** When this function is called, buffer *ppList (size *pnList bytes) contains 
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  int nBuf           /* size of the BLOB */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  char *pBlob;             /* The BLOB encoding of the document size */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):**   Varint 1+nCol:  The total size, in bytes, of all text values in all
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  int nAlloc;                     /* Allocated size of a[] (nAlloc>=n) */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** bytes in size, extend (realloc) it to be so.
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** to reflect the new size of the pBlob->a[] buffer.
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):      ** bytes in size, write the key here.  */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** If the size of the value in blob pPrev is zero, then this is the first
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** Compare the term in buffer zLhs (size in bytes nLhs) with that in
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** zRhs (size in bytes nRhs) using memcmp. If one term is a prefix of
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):  int nAlloc = 0;                 /* Allocated size of aIdx[] */
Fts3_write.c (components\external\sqlite-3.8.1\ext\fts3):** The first two arguments are a pointer to and the size of a segment b-tree
Ftsizes.h (components\external\freetype\include):/*    FreeType size objects management (specification).                    */
Ftsizes.h (components\external\freetype\include):  /*    pixel-size dependent information, available in the `face->size'    */
Ftsizes.h (components\external\freetype\include):  /*    modify the contents of the current `active' size; you thus need    */
Ftsizes.h (components\external\freetype\include):  /*    Create a new size object from a given face object.                 */
Ftsizes.h (components\external\freetype\include):  /*    asize :: A handle to a new size object.                            */
Ftsizes.h (components\external\freetype\include):  /*    You need to call @FT_Activate_Size in order to select the new size */
Ftsizes.h (components\external\freetype\include):               FT_Size*  size );
Ftsizes.h (components\external\freetype\include):  /*    Discard a given size object.  Note that @FT_Done_Face              */
Ftsizes.h (components\external\freetype\include):  /*    automatically discards all size objects allocated with             */
Ftsizes.h (components\external\freetype\include):  /*    size :: A handle to a target size object.                          */
Ftsizes.h (components\external\freetype\include):  FT_Done_Size( FT_Size  size );
Ftsizes.h (components\external\freetype\include):  /*    Even though it is possible to create several size objects for a    */
Ftsizes.h (components\external\freetype\include):  /*    activated last to determine the `current character pixel size'.    */
Ftsizes.h (components\external\freetype\include):  /*    This function can be used to `activate' a previously created size  */
Ftsizes.h (components\external\freetype\include):  /*    size :: A handle to a target size object.                          */
Ftsizes.h (components\external\freetype\include):  /*    If `face' is the size's parent face object, this function changes  */
Ftsizes.h (components\external\freetype\include):  /*    the value of `face->size' to the input size handle.                */
Ftsizes.h (components\external\freetype\include):  FT_Activate_Size( FT_Size  size );
Ftstdlib.h (components\external\freetype\include\config):  /* UINT_MAX and ULONG_MAX are used to automatically compute the size  */
Ftstream.c (components\external\freetype\src\base):                        FT_ULong        size )
Ftstream.c (components\external\freetype\src\base):    stream->size   = size;
Ftstream.c (components\external\freetype\src\base):                   " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):                   pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):    else if ( pos > stream->size )
Ftstream.c (components\external\freetype\src\base):                 " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):                 pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):    if ( pos >= stream->size )
Ftstream.c (components\external\freetype\src\base):                 " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):                 pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):      read_bytes = stream->size - pos;
Ftstream.c (components\external\freetype\src\base):    if ( stream->pos >= stream->size )
Ftstream.c (components\external\freetype\src\base):      read_bytes = stream->size - stream->pos;
Ftstream.c (components\external\freetype\src\base):      if ( count > stream->size )
Ftstream.c (components\external\freetype\src\base):                   " frame size (%lu) larger than stream size (%lu)\n",
Ftstream.c (components\external\freetype\src\base):                   count, stream->size ));
Ftstream.c (components\external\freetype\src\base):      if ( stream->pos >= stream->size        ||
Ftstream.c (components\external\freetype\src\base):           stream->size - stream->pos < count )
Ftstream.c (components\external\freetype\src\base):                   " invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):                   stream->pos, count, stream->size ));
Ftstream.c (components\external\freetype\src\base):      if ( stream->pos < stream->size )
Ftstream.c (components\external\freetype\src\base):               " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):               stream->pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):    if ( stream->pos + 1 < stream->size )
Ftstream.c (components\external\freetype\src\base):               " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):               stream->pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):    if ( stream->pos + 1 < stream->size )
Ftstream.c (components\external\freetype\src\base):               " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):               stream->pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):    if ( stream->pos + 2 < stream->size )
Ftstream.c (components\external\freetype\src\base):               " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):               stream->pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):    if ( stream->pos + 3 < stream->size )
Ftstream.c (components\external\freetype\src\base):               " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):               stream->pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):    if ( stream->pos + 3 < stream->size )
Ftstream.c (components\external\freetype\src\base):               " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
Ftstream.c (components\external\freetype\src\base):               stream->pos, stream->size ));
Ftstream.c (components\external\freetype\src\base):          FT_UInt  len = fields->size;
Ftstream.c (components\external\freetype\src\base):      switch ( fields->size )
Ftstream.h (components\external\freetype\include\internal):    FT_Byte    size;
Ftstream.h (components\external\freetype\include\internal):#define FT_FRAME_START( size )   { ft_frame_start, 0, size }
Ftstream.h (components\external\freetype\include\internal):                        FT_ULong        size );
Ftstream.h (components\external\freetype\include\internal):#define FT_FRAME_ENTER( size )                                           \
Ftstream.h (components\external\freetype\include\internal):                                                  (FT_ULong)(size) ) ) )
Ftstream.h (components\external\freetype\include\internal):#define FT_FRAME_EXTRACT( size, bytes )                                       \
Ftstream.h (components\external\freetype\include\internal):                                                    (FT_ULong)(size),         \
Ftstroke.h (components\external\freetype\include):   *   to account for this added size.
Ftstroke.h (components\external\freetype\include):   *   to account for this added size.
Ftsynth.c (components\external\freetype\src\base):                      face->size->metrics.y_scale ) / 24;
Ftsystem.c (components\external\freetype\builds\amiga\src\base):  /*    size   :: The requested size in bytes.                             */
Ftsystem.c (components\external\freetype\builds\amiga\src\base):            long       size )
Ftsystem.c (components\external\freetype\builds\amiga\src\base):    return AllocVecPooled( memory->user, size );
Ftsystem.c (components\external\freetype\builds\amiga\src\base):    return Alloc_VecPooled( memory->user, size );
Ftsystem.c (components\external\freetype\builds\amiga\src\base):  /*    cur_size :: The current size of the allocated memory block.        */
Ftsystem.c (components\external\freetype\builds\amiga\src\base):  /*    new_size :: The newly requested size in bytes.                     */
Ftsystem.c (components\external\freetype\builds\amiga\src\base):    stream->size               = 0;
Ftsystem.c (components\external\freetype\builds\amiga\src\base):    stream->size = fib->fib_Size;
Ftsystem.c (components\external\freetype\builds\amiga\src\base):    if ( !stream->size )
Ftsystem.c (components\external\freetype\builds\amiga\src\base):                filepathname, stream->size ));
Ftsystem.c (components\external\freetype\builds\rt-thread):  /*    size   :: The requested size in bytes.                             */
Ftsystem.c (components\external\freetype\builds\rt-thread):            long       size )
Ftsystem.c (components\external\freetype\builds\rt-thread):    return rt_malloc( size );
Ftsystem.c (components\external\freetype\builds\rt-thread):  /*    cur_size :: The current size of the allocated memory block.        */
Ftsystem.c (components\external\freetype\builds\rt-thread):  /*    new_size :: The newly requested size in bytes.                     */
Ftsystem.c (components\external\freetype\builds\rt-thread):    stream->size               = 0;
Ftsystem.c (components\external\freetype\builds\rt-thread):    if ( !count && offset > stream->size )
Ftsystem.c (components\external\freetype\builds\rt-thread):    stream->size = dfd->size;
Ftsystem.c (components\external\freetype\builds\rt-thread):    if ( !stream->size )
Ftsystem.c (components\external\freetype\builds\rt-thread):                filepathname, stream->size ));
Ftsystem.c (components\external\freetype\builds\unix):  /*    size   :: The requested size in bytes.                             */
Ftsystem.c (components\external\freetype\builds\unix):            long       size )
Ftsystem.c (components\external\freetype\builds\unix):    return malloc( size );
Ftsystem.c (components\external\freetype\builds\unix):  /*    cur_size :: The current size of the allocated memory block.        */
Ftsystem.c (components\external\freetype\builds\unix):  /*    new_size :: The newly requested size in bytes.                     */
Ftsystem.c (components\external\freetype\builds\unix):    munmap( (MUNMAP_ARG_CAST)stream->descriptor.pointer, stream->size );
Ftsystem.c (components\external\freetype\builds\unix):    stream->size               = 0;
Ftsystem.c (components\external\freetype\builds\unix):    stream->size               = 0;
Ftsystem.c (components\external\freetype\builds\unix):    /* `stream->size' is typedef'd to unsigned long (in `ftsystem.h'); */
Ftsystem.c (components\external\freetype\builds\unix):    stream->size = (unsigned long)stat_buf.st_size;
Ftsystem.c (components\external\freetype\builds\unix):                                          stream->size,
Ftsystem.c (components\external\freetype\builds\unix):      stream->base = (unsigned char*)ft_alloc( NULL, stream->size );
Ftsystem.c (components\external\freetype\builds\unix):                           stream->size - total_read_count );
Ftsystem.c (components\external\freetype\builds\unix):      } while ( (unsigned long)total_read_count != stream->size );
Ftsystem.c (components\external\freetype\builds\unix):                filepathname, stream->size ));
Ftsystem.c (components\external\freetype\builds\unix):    stream->size = 0;
Ftsystem.c (components\external\freetype\builds\vms):  /*    size   :: The requested size in bytes.                             */
Ftsystem.c (components\external\freetype\builds\vms):            long       size )
Ftsystem.c (components\external\freetype\builds\vms):    return malloc( size );
Ftsystem.c (components\external\freetype\builds\vms):  /*    cur_size :: The current size of the allocated memory block.        */
Ftsystem.c (components\external\freetype\builds\vms):  /*    new_size :: The newly requested size in bytes.                     */
Ftsystem.c (components\external\freetype\builds\vms):    munmap( (MUNMAP_ARG_CAST)stream->descriptor.pointer, stream->size );
Ftsystem.c (components\external\freetype\builds\vms):    stream->size               = 0;
Ftsystem.c (components\external\freetype\builds\vms):    stream->size = stat_buf.st_size;
Ftsystem.c (components\external\freetype\builds\vms):    if ( !stream->size )
Ftsystem.c (components\external\freetype\builds\vms):                                          stream->size,
Ftsystem.c (components\external\freetype\builds\vms):                filepathname, stream->size ));
Ftsystem.c (components\external\freetype\builds\vms):    stream->size = 0;
Ftsystem.c (components\external\freetype\src\base):  /*    size   :: The requested size in bytes.                             */
Ftsystem.c (components\external\freetype\src\base):            long       size )
Ftsystem.c (components\external\freetype\src\base):    return ft_smalloc( size );
Ftsystem.c (components\external\freetype\src\base):  /*    cur_size :: The current size of the allocated memory block.        */
Ftsystem.c (components\external\freetype\src\base):  /*    new_size :: The newly requested size in bytes.                     */
Ftsystem.c (components\external\freetype\src\base):    stream->size               = 0;
Ftsystem.c (components\external\freetype\src\base):    if ( !count && offset > stream->size )
Ftsystem.c (components\external\freetype\src\base):    stream->size = ft_ftell( file );
Ftsystem.c (components\external\freetype\src\base):    if ( !stream->size )
Ftsystem.c (components\external\freetype\src\base):                filepathname, stream->size ));
Ftsystem.h (components\external\freetype\include):   *   A function used to allocate `size' bytes from `memory'.
Ftsystem.h (components\external\freetype\include):   *   size ::
Ftsystem.h (components\external\freetype\include):   *     The size in bytes to allocate.
Ftsystem.h (components\external\freetype\include):                    long       size );
Ftsystem.h (components\external\freetype\include):   *     The block's current size in bytes.
Ftsystem.h (components\external\freetype\include):   *     The block's requested new size.
Ftsystem.h (components\external\freetype\include):   *   size ::
Ftsystem.h (components\external\freetype\include):   *     The stream size in bytes.
Ftsystem.h (components\external\freetype\include):    unsigned long        size;
Fttypes.h (components\external\freetype\include):  /*    _unsigned_ integer type used to express a file size or position,   */
Fttypes.h (components\external\freetype\include):  /*    or a memory block size.                                            */
Fttypes.h (components\external\freetype\include):  /*    might want to associate a glyph cache to a given size object.      */
Ftutil.c (components\external\freetype\src\base):                FT_Long    size,
Ftutil.c (components\external\freetype\src\base):    FT_Pointer  block = ft_mem_qalloc( memory, size, &error );
Ftutil.c (components\external\freetype\src\base):    if ( !error && size > 0 )
Ftutil.c (components\external\freetype\src\base):      FT_MEM_ZERO( block, size );
Ftutil.c (components\external\freetype\src\base):                 FT_Long    size,
Ftutil.c (components\external\freetype\src\base):    if ( size > 0 )
Ftutil.c (components\external\freetype\src\base):      block = memory->alloc( memory, size );
Ftutil.c (components\external\freetype\src\base):    else if ( size < 0 )
Ftutil.c (components\external\freetype\src\base):              FT_ULong     size,
Ftutil.c (components\external\freetype\src\base):    FT_Pointer  p = ft_mem_qalloc( memory, size, &error );
Ftutil.c (components\external\freetype\src\base):      ft_memcpy( p, address, size );
Ftutil.c (components\external\freetype\src\base):                  FT_ULong     size )
Ftutil.c (components\external\freetype\src\base):    while ( size > 1 && *src != 0 )
Ftutil.c (components\external\freetype\src\base):      size--;
Ft_hash.c (components\external\sqlite-3.8.1\ext\fts1):  int h;                /* the hash of the key modulo hash table size */
Func.c (components\external\sqlite-3.8.1\src):** character is exactly one byte in size.  Also, all characters are
Func.c (components\external\sqlite-3.8.1\src):** The zeroblob(N) function returns a zero-filled blob of size N bytes.
Func.c (components\external\sqlite-3.8.1\src):  i64 nOut;                /* Maximum size of zOut */
Functions.html (components\net\uip\doc\html):: <a class="el" href="a00077.html#564bab93ef6a268a5de2fab885c1d32a">dhcpc_state</a><li>size
Functions.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
Functions_vars.html (components\net\uip\doc\html):: <a class="el" href="a00077.html#564bab93ef6a268a5de2fab885c1d32a">dhcpc_state</a><li>size
Functions_vars.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
Fuzzer.c (components\external\sqlite-3.8.1\ext\misc):#define FUZZER_HASH  4001    /* Hash table size */
Gc.c (components\dfs\filesystems\jffs2\src):			end = frag->ofs + frag->size;
Gc.c (components\dfs\filesystems\jffs2\src):		mdatalen = fn->size;
Gc.c (components\dfs\filesystems\jffs2\src):		mdata = kmalloc(fn->size, GFP_KERNEL);
Gc.c (components\dfs\filesystems\jffs2\src):		ilen = last_frag->ofs + last_frag->size;
Gc.c (components\dfs\filesystems\jffs2\src):		ilen = frag->ofs + frag->size;
Gc.c (components\dfs\filesystems\jffs2\src):		if (frag->ofs > fn->size + fn->ofs)
Gc.c (components\dfs\filesystems\jffs2\src):					  frag->ofs, frag->ofs+frag->size));
Gc.c (components\dfs\filesystems\jffs2\src):					  frag->ofs, frag->ofs+frag->size));
Gc.c (components\dfs\filesystems\jffs2\src):						  frag->ofs, frag->ofs+frag->size, ref_offset(raw)));
Gc.c (components\dfs\filesystems\jffs2\src):						  frag->ofs, frag->ofs+frag->size, jeb->offset));
Gc.c (components\dfs\filesystems\jffs2\src):						  frag->ofs, frag->ofs+frag->size, jeb->offset));
Gc.c (components\dfs\filesystems\jffs2\src):		while((frag = frag_next(frag)) && frag->ofs+frag->size <= max) {
Gc.c (components\dfs\filesystems\jffs2\src):			if (frag->ofs+frag->size < max) {
Gc.c (components\dfs\filesystems\jffs2\src):					  frag->ofs, frag->ofs+frag->size));
Gc.c (components\dfs\filesystems\jffs2\src):				end = frag->ofs + frag->size;
Gc.c (components\dfs\filesystems\jffs2\src):					  frag->ofs, frag->ofs+frag->size));
Gc.c (components\dfs\filesystems\jffs2\src):						  frag->ofs, frag->ofs+frag->size, ref_offset(raw)));
Gc.c (components\dfs\filesystems\jffs2\src):					end = frag->ofs + frag->size;
Gc.c (components\dfs\filesystems\jffs2\src):						  frag->ofs, frag->ofs+frag->size, jeb->offset));
Gc.c (components\dfs\filesystems\jffs2\src):						  frag->ofs, frag->ofs+frag->size, jeb->offset));
Gc.c (components\dfs\filesystems\jffs2\src):				end = frag->ofs + frag->size;
Gc.c (components\dfs\filesystems\jffs2\src):		D1(BUG_ON(end > frag_last(&f->fragtree)->ofs + frag_last(&f->fragtree)->size));
Gdb_stub.c (components\gdb):static long probe_kernel_write(void *dst, void *src, size_t size)
Gdb_stub.c (components\gdb):    for (i = 0; i<size; i++) {
Globals.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x61.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x62.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x64.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x65.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x66.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x68.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x69.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x6c.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x6d.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x6e.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x70.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x72.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x73.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x74.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x75.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_0x77.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x61.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x62.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x64.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x65.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x66.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x68.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x69.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x6c.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x6d.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x6e.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x70.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x72.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x73.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x74.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x75.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_defs_0x77.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_func.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_type.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Globals_vars.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
GUI.h (components\emwin1\inc):  int xSize;         // X-size of images
GUI.h (components\emwin1\inc):  int ySize;         // Y-size of images
GUI.h (components\emwin1\inc):GUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
GUI.h (components\emwin1\inc):GUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
GUI.h (components\emwin1\inc\include):  int xSize;         // X-size of images
GUI.h (components\emwin1\inc\include):  int ySize;         // Y-size of images
GUI.h (components\emwin1\inc\include):GUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
GUI.h (components\emwin1\inc\include):GUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
GUI.h (components\emwin\include):  int xSize;         // X-size of images
GUI.h (components\emwin\include):  int ySize;         // Y-size of images
GUI.h (components\emwin\include):GUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
GUI.h (components\emwin\include):GUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
GUI.h (components\stemwin\inc):  int xSize;         // X-size of images
GUI.h (components\stemwin\inc):  int ySize;         // Y-size of images
GUI.h (components\stemwin\inc):GUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
GUI.h (components\stemwin\inc):GUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
GUI.h (components\stemwin\inc\include):  int xSize;         // X-size of images
GUI.h (components\stemwin\inc\include):  int ySize;         // Y-size of images
GUI.h (components\stemwin\inc\include):GUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
GUI.h (components\stemwin\inc\include):GUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
GUIConf.c (components\emwin1\emwindemo):// Define the average block size
GUIConf.c (components\emwin\config):/* Define the average block size */
GUIConf.c (components\emwin\emwindemo):// Define the average block size
GUIConf.c (components\stemwin\emwindemo):// Define the average block size
GUIDEMO.c (components\emwin\ucguidemo):    /* Calculate position and size of FrameWin[1] */
GUIDEMO.c (components\emwin\ucguidemo):    /* Calculate position and size of FrameWin[0] */
GUIDEMO_Automotive.c (components\emwin1\demo):  // Determine if additional information can be shown (depending on display size)
GUIDEMO_Automotive.c (components\emwin1\emwindemo):  // Determine if additional information can be shown (depending on display size)
GUIDEMO_Automotive.c (components\emwin\emwindemo):  // Determine if additional information can be shown (depending on display size)
GUIDEMO_Automotive.c (components\stemwin\emwindemo):  // Determine if additional information can be shown (depending on display size)
GUIDEMO_Graph.c (components\emwin1\demo):  // Determine size of GRAPH
GUIDEMO_Graph.c (components\emwin1\demo):  Graph_xSize = xSize - (DIST_TO_BORDER << 1);            // xsize = Screen size subtracting twice the distance to the border of the screen
GUIDEMO_Graph.c (components\emwin1\demo):  Graph_ySize = ySize - INFO_SIZE_Y - (DIST_TO_WIN << 1); // ysize = Screen size subtracting the window sizes and twice the distance to the windows
GUIDEMO_Graph.c (components\emwin1\emwindemo):  // Determine size of GRAPH
GUIDEMO_Graph.c (components\emwin1\emwindemo):  Graph_xSize = xSize - (DIST_TO_BORDER << 1);            // xsize = Screen size subtracting twice the distance to the border of the screen
GUIDEMO_Graph.c (components\emwin1\emwindemo):  Graph_ySize = ySize - INFO_SIZE_Y - (DIST_TO_WIN << 1); // ysize = Screen size subtracting the window sizes and twice the distance to the windows
GUIDEMO_Graph.c (components\emwin\emwindemo):  // Determine size of GRAPH
GUIDEMO_Graph.c (components\emwin\emwindemo):  Graph_xSize = xSize - (DIST_TO_BORDER << 1);            // xsize = Screen size subtracting twice the distance to the border of the screen
GUIDEMO_Graph.c (components\emwin\emwindemo):  Graph_ySize = ySize - INFO_SIZE_Y - (DIST_TO_WIN << 1); // ysize = Screen size subtracting the window sizes and twice the distance to the windows
GUIDEMO_Graph.c (components\stemwin\emwindemo):  // Determine size of GRAPH
GUIDEMO_Graph.c (components\stemwin\emwindemo):  Graph_xSize = xSize - (DIST_TO_BORDER << 1);            // xsize = Screen size subtracting twice the distance to the border of the screen
GUIDEMO_Graph.c (components\stemwin\emwindemo):  Graph_ySize = ySize - INFO_SIZE_Y - (DIST_TO_WIN << 1); // ysize = Screen size subtracting the window sizes and twice the distance to the windows
GUIDEMO_MemDevB.c (components\emwin\ucguidemo):    /* Calculate required size */
GUIDEMO_Speedometer.c (components\emwin1\demo):  // Magnify gradient device to desired size
GUIDEMO_Speedometer.c (components\emwin1\demo):  // Get display size
GUIDEMO_Speedometer.c (components\emwin1\emwindemo):  // Magnify gradient device to desired size
GUIDEMO_Speedometer.c (components\emwin1\emwindemo):  // Get display size
GUIDEMO_Speedometer.c (components\emwin\emwindemo):  // Magnify gradient device to desired size
GUIDEMO_Speedometer.c (components\emwin\emwindemo):  // Get display size
GUIDEMO_Speedometer.c (components\stemwin\emwindemo):  // Magnify gradient device to desired size
GUIDEMO_Speedometer.c (components\stemwin\emwindemo):  // Get display size
GUIDRV_DCache_Private.h (components\emwin1\inc):  int xSize, ySize;       // Display size
GUIDRV_DCache_Private.h (components\emwin1\inc):  int vxSize, vySize;     // Virtual display size
GUIDRV_DCache_Private.h (components\emwin1\inc\include):  int xSize, ySize;       // Display size
GUIDRV_DCache_Private.h (components\emwin1\inc\include):  int vxSize, vySize;     // Virtual display size
GUIDRV_DCache_Private.h (components\emwin\include):  int xSize, ySize;       // Display size
GUIDRV_DCache_Private.h (components\emwin\include):  int vxSize, vySize;     // Virtual display size
GUIDRV_DCache_Private.h (components\stemwin\inc):  int xSize, ySize;       // Display size
GUIDRV_DCache_Private.h (components\stemwin\inc):  int vxSize, vySize;     // Virtual display size
GUIDRV_DCache_Private.h (components\stemwin\inc\include):  int xSize, ySize;       // Display size
GUIDRV_DCache_Private.h (components\stemwin\inc\include):  int vxSize, vySize;     // Virtual display size
GUIDRV_FlexColor_Private.h (components\emwin1\inc):  int xSize, ySize;   // Display size
GUIDRV_FlexColor_Private.h (components\emwin1\inc):  int vxSize, vySize; // Virtual display size
GUIDRV_FlexColor_Private.h (components\emwin1\inc\include):  int xSize, ySize;   // Display size
GUIDRV_FlexColor_Private.h (components\emwin1\inc\include):  int vxSize, vySize; // Virtual display size
GUIDRV_FlexColor_Private.h (components\emwin\include):  int xSize, ySize;   // Display size
GUIDRV_FlexColor_Private.h (components\emwin\include):  int vxSize, vySize; // Virtual display size
GUIDRV_FlexColor_Private.h (components\stemwin\inc):  int xSize, ySize;   // Display size
GUIDRV_FlexColor_Private.h (components\stemwin\inc):  int vxSize, vySize; // Virtual display size
GUIDRV_FlexColor_Private.h (components\stemwin\inc\include):  int xSize, ySize;   // Display size
GUIDRV_FlexColor_Private.h (components\stemwin\inc\include):  int vxSize, vySize; // Virtual display size
GUIDRV_Lin_Private.h (components\emwin1\inc):*   Returns the display size.
GUIDRV_Lin_Private.h (components\emwin1\inc\include):*   Returns the display size.
GUIDRV_Lin_Private.h (components\emwin\include):*   Returns the display size.
GUIDRV_Lin_Private.h (components\stemwin\inc):*   Returns the display size.
GUIDRV_Lin_Private.h (components\stemwin\inc\include):*   Returns the display size.
GUI_Debug.h (components\emwin1\inc):    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
GUI_Debug.h (components\emwin1\inc\include):    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
GUI_Debug.h (components\emwin\include):    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
GUI_Debug.h (components\stemwin\inc):    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
GUI_Debug.h (components\stemwin\inc\include):    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
GUI_JPEG_Private.h (components\emwin1\inc):  MCU         - (Minimum Coded Unit) is an interleaved set of blocks of size
GUI_JPEG_Private.h (components\emwin1\inc):  /* Image size */
GUI_JPEG_Private.h (components\emwin1\inc):  U8 aaHuffNum[MAX_HUFFTABLES][17];   /* Pointer to number of Huffman codes per bit size */
GUI_JPEG_Private.h (components\emwin1\inc):  int MaxMCU_xSize;             /* MCU's max. X size in pixels */
GUI_JPEG_Private.h (components\emwin1\inc):  int MaxMCU_ySize;             /* MCU's max. Y size in pixels */
GUI_JPEG_Private.h (components\emwin1\inc\include):  MCU         - (Minimum Coded Unit) is an interleaved set of blocks of size
GUI_JPEG_Private.h (components\emwin1\inc\include):  /* Image size */
GUI_JPEG_Private.h (components\emwin1\inc\include):  U8 aaHuffNum[MAX_HUFFTABLES][17];   /* Pointer to number of Huffman codes per bit size */
GUI_JPEG_Private.h (components\emwin1\inc\include):  int MaxMCU_xSize;             /* MCU's max. X size in pixels */
GUI_JPEG_Private.h (components\emwin1\inc\include):  int MaxMCU_ySize;             /* MCU's max. Y size in pixels */
GUI_JPEG_Private.h (components\emwin\include):  MCU         - (Minimum Coded Unit) is an interleaved set of blocks of size
GUI_JPEG_Private.h (components\emwin\include):  /* Image size */
GUI_JPEG_Private.h (components\emwin\include):  U8 aaHuffNum[MAX_HUFFTABLES][17];   /* Pointer to number of Huffman codes per bit size */
GUI_JPEG_Private.h (components\emwin\include):  int MaxMCU_xSize;             /* MCU's max. X size in pixels */
GUI_JPEG_Private.h (components\emwin\include):  int MaxMCU_ySize;             /* MCU's max. Y size in pixels */
GUI_JPEG_Private.h (components\stemwin\inc):  MCU         - (Minimum Coded Unit) is an interleaved set of blocks of size
GUI_JPEG_Private.h (components\stemwin\inc):  /* Image size */
GUI_JPEG_Private.h (components\stemwin\inc):  U8 aaHuffNum[MAX_HUFFTABLES][17];   /* Pointer to number of Huffman codes per bit size */
GUI_JPEG_Private.h (components\stemwin\inc):  int MaxMCU_xSize;             /* MCU's max. X size in pixels */
GUI_JPEG_Private.h (components\stemwin\inc):  int MaxMCU_ySize;             /* MCU's max. Y size in pixels */
GUI_JPEG_Private.h (components\stemwin\inc\include):  MCU         - (Minimum Coded Unit) is an interleaved set of blocks of size
GUI_JPEG_Private.h (components\stemwin\inc\include):  /* Image size */
GUI_JPEG_Private.h (components\stemwin\inc\include):  U8 aaHuffNum[MAX_HUFFTABLES][17];   /* Pointer to number of Huffman codes per bit size */
GUI_JPEG_Private.h (components\stemwin\inc\include):  int MaxMCU_xSize;             /* MCU's max. X size in pixels */
GUI_JPEG_Private.h (components\stemwin\inc\include):  int MaxMCU_ySize;             /* MCU's max. Y size in pixels */
GUI_Private.h (components\emwin1\inc):GUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
GUI_Private.h (components\emwin1\inc\include):GUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
GUI_Private.h (components\emwin\include):GUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
GUI_Private.h (components\stemwin\inc):GUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
GUI_Private.h (components\stemwin\inc\include):GUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
GUI_Type.h (components\emwin1\inc):  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
GUI_Type.h (components\emwin1\inc\include):  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
GUI_Type.h (components\emwin\include):  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
GUI_Type.h (components\stemwin\inc):  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
GUI_Type.h (components\stemwin\inc\include):  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):extern voidp  malloc OF((uInt size));
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):#define ALLOC(size) malloc(size)
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):            /* Check CRC and original size */
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):            uInt size = Z_BUFSIZE;
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):            if (offset < Z_BUFSIZE) size = (uInt)offset;
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):            size = gzwrite(file, s->inbuf, size);
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):            if (size == 0) return -1L;
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):            offset -= size;
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):        int size = Z_BUFSIZE;
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):        if (offset < Z_BUFSIZE) size = (int)offset;
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):        size = gzread(file, s->outbuf, (uInt)size);
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):        if (size <= 0) return -1L;
Gzio.c (components\dfs\filesystems\jffs2\cyg\compress\src):        offset -= size;
Gzio.c (components\external\libz):extern voidp  malloc OF((uInt size));
Gzio.c (components\external\libz):#define ALLOC(size) malloc(size)
Gzio.c (components\external\libz):            /* Check CRC and original size */
Gzio.c (components\external\libz):            uInt size = Z_BUFSIZE;
Gzio.c (components\external\libz):            if (offset < Z_BUFSIZE) size = (uInt)offset;
Gzio.c (components\external\libz):            size = gzwrite(file, s->inbuf, size);
Gzio.c (components\external\libz):            if (size == 0) return -1L;
Gzio.c (components\external\libz):            offset -= size;
Gzio.c (components\external\libz):        int size = Z_BUFSIZE;
Gzio.c (components\external\libz):        if (offset < Z_BUFSIZE) size = (int)offset;
Gzio.c (components\external\libz):        size = gzread(file, s->outbuf, (uInt)size);
Gzio.c (components\external\libz):        if (size <= 0) return -1L;
Gzio.c (components\external\libz):        offset -= size;
Hash.c (components\external\sqlite-3.8.1\src):** if the new size is the same as the prior size.
Hash.c (components\external\sqlite-3.8.1\src):  unsigned int h;       /* the hash of the key modulo hash table size */
Hbshim.c (components\external\freetype\src\autofit):      /* we shape at a size of units per EM; this means font units */
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):		MSG("------name-----------size---------serial-----" TENDSTR);
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):	MSG("TreeNode size:         %d" TENDSTR, sizeof(TreeNode));
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):	MSG("TagStore size:         %d" TENDSTR, sizeof(struct uffs_TagStoreSt));
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):	MSG("Block size:            %d" TENDSTR, dev->attr->page_data_size * dev->attr->pages_per_block);
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):/** cat <file> [<offset>] [<size>] */
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):	int start = 0, size = 0, printed = 0, n, len;
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):		if (argc > 3) size = strtol(argv[3], NULL, 10);
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):			if (size == 0 || printed < size) {
Helper_cmds.c (components\dfs\filesystems\uffs\src\emu):				n = (size == 0 ? len : (size - printed > len ? len : size - printed));
Hierarchy.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
Hub.c (components\drivers\usb\usbhost\core): * @param nbytes the size of buffer
Hwtimer.c (components\drivers\hwtimer):static rt_size_t rt_hwtimer_read(struct rt_device *dev, rt_off_t pos, void *buffer, rt_size_t size)
Hwtimer.c (components\drivers\hwtimer):    size = size > sizeof(tv)? sizeof(tv) : size;
Hwtimer.c (components\drivers\hwtimer):    rt_memcpy(buffer, &tv, size);
Hwtimer.c (components\drivers\hwtimer):    return size;
Hwtimer.c (components\drivers\hwtimer):static rt_size_t rt_hwtimer_write(struct rt_device *dev, rt_off_t pos, const void *buffer, rt_size_t size)
Hwtimer.c (components\drivers\hwtimer):    if (size != sizeof(rt_hwtimerval_t))
Hwtimer.c (components\drivers\hwtimer):        size = 0;
Hwtimer.c (components\drivers\hwtimer):    return size;
Hz12font.c (components\gui\src):/* size = 196272 bytes */
Hz12font.c (components\gui\src):    0,                      /* cache size       */
Hz12font.c (components\gui\src):    12,                     /* font size        */
Hz12font.c (components\gui\src):    24,                     /* font data size   */
Hz16font.c (components\gui\src):/* size = 267616 bytes */
Hz16font.c (components\gui\src):    0,                      /* cache size       */
Hz16font.c (components\gui\src):    16,                     /* font size        */
Hz16font.c (components\gui\src):    32,                     /* font data size   */
IMAGE.h (components\emwin1\inc):#define IMAGE_CF_ATTACHED (1 << 3) // Widget size is fixed to the parent border
IMAGE.h (components\emwin1\inc):#define IMAGE_CF_AUTOSIZE (1 << 4) // Widget size is taken from the attached image
IMAGE.h (components\emwin1\inc\include):#define IMAGE_CF_ATTACHED (1 << 3) // Widget size is fixed to the parent border
IMAGE.h (components\emwin1\inc\include):#define IMAGE_CF_AUTOSIZE (1 << 4) // Widget size is taken from the attached image
IMAGE.h (components\emwin\include):#define IMAGE_CF_ATTACHED (1 << 3) // Widget size is fixed to the parent border
IMAGE.h (components\emwin\include):#define IMAGE_CF_AUTOSIZE (1 << 4) // Widget size is taken from the attached image
IMAGE.h (components\stemwin\inc):#define IMAGE_CF_ATTACHED (1 << 3) // Widget size is fixed to the parent border
IMAGE.h (components\stemwin\inc):#define IMAGE_CF_AUTOSIZE (1 << 4) // Widget size is taken from the attached image
IMAGE.h (components\stemwin\inc\include):#define IMAGE_CF_ATTACHED (1 << 3) // Widget size is fixed to the parent border
IMAGE.h (components\stemwin\inc\include):#define IMAGE_CF_AUTOSIZE (1 << 4) // Widget size is taken from the attached image
Image_bmp.c (components\gui\src): *  features. The new decoder uses configurable fixed size working buffer and
Image_bmp.c (components\gui\src):        /* Read BMP header size */
Image_bmp.c (components\gui\src):            /* Read image size */
Image_bmp.c (components\gui\src):            /* Read image size */
Image_bmp.c (components\gui\src):        /* Read BMP header size */
Image_bmp.c (components\gui\src):            /* Read image size */
Image_bmp.c (components\gui\src):            /* Read image size */
Image_bmp.c (components\gui\src):    bhr->bfSize = header_size + image_size; /* data size */
Image_jpg.c (components\gui\src):                    rt_uint32_t size;
Image_jpg.c (components\gui\src):                    size = (magic[2] << 8) + magic[3];
Image_jpg.c (components\gui\src):                    end = rtgui_filerw_seek(file, size - 2, RTGUI_FILE_SEEK_CUR);
Image_jpg.c (components\gui\src):                    if (end != start + size - 2) is_JPG = RT_FALSE;
IMAGE_Private.h (components\emwin1\inc):  void             (* pfGetImageSize)(IMAGE_Handle hObj, int * pxSize, int * pySize); // Returns the image size of the attached item
IMAGE_Private.h (components\emwin1\inc\include):  void             (* pfGetImageSize)(IMAGE_Handle hObj, int * pxSize, int * pySize); // Returns the image size of the attached item
IMAGE_Private.h (components\emwin\include):  void             (* pfGetImageSize)(IMAGE_Handle hObj, int * pxSize, int * pySize); // Returns the image size of the attached item
IMAGE_Private.h (components\stemwin\inc):  void             (* pfGetImageSize)(IMAGE_Handle hObj, int * pxSize, int * pySize); // Returns the image size of the attached item
IMAGE_Private.h (components\stemwin\inc\include):  void             (* pfGetImageSize)(IMAGE_Handle hObj, int * pxSize, int * pySize); // Returns the image size of the attached item
Image_xpm.c (components\gui\src):    int size;
Image_xpm.c (components\gui\src):static int hash_key(const char *key, int cpp, int size)
Image_xpm.c (components\gui\src):    return hash & (size - 1);
Image_xpm.c (components\gui\src):    hash->size = s;
Image_xpm.c (components\gui\src):    bytes = hash->size *sizeof(struct hash_entry **);
Image_xpm.c (components\gui\src):    int index = hash_key(key, cpp, hash->size);
Image_xpm.c (components\gui\src):    struct hash_entry *entry = hash->table[hash_key(key, cpp, hash->size)];
Inet_chksum.c (components\net\lwip-1.3.2\src\core\ipv4): * @note accumulator size limits summable length to 64k
Inet_chksum.c (components\net\lwip-1.4.1\src\core\ipv4): * @note accumulator size limits summable length to 64k
Inet_chksum.c (components\net\lwip-head\src\core): * @note accumulator size limits summable length to 64k
Inet_chksum.c (components\net\lwip\src\core\ipv4): * @note accumulator size limits summable length to 64k
Infback.c (components\dfs\filesystems\jffs2\cyg\compress\src):   thereafter.  This reduces the size of the code by about 2K bytes, in
Infback.c (components\external\libz):   thereafter.  This reduces the size of the code by about 2K bytes, in
Infblock.h (components\dfs\filesystems\jffs2\cyg\compress\src):    uInt w));                   /* window size */
Infblock.h (components\external\freetype\src\gzip):    uInt w));                   /* window size */
Infcodes.c (components\external\freetype\src\gzip):      while (f < s->window)             /* modulo window size-"while" instead */
Inffast.c (components\dfs\filesystems\jffs2\cyg\compress\src):    unsigned wsize;             /* window size or zero if not using window */
Inffast.c (components\external\libz):    unsigned wsize;             /* window size or zero if not using window */
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):   thereafter.  This reduces the size of the code by about 2K bytes, in
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):    unsigned low, size;
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):    size = 1U << 9;
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):    printf("    static const code lenfix[%u] = {", size);
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):        if (++low == size) break;
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):    size = 1U << 5;
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):    printf("\n    static const code distfix[%u] = {", size);
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):        if (++low == size) break;
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):   The advantage may be dependent on the size of the processor's data caches.
Inflate.c (components\dfs\filesystems\jffs2\cyg\compress\src):                strm->msg = (char *)"invalid window size";
Inflate.c (components\external\freetype\src\gzip):  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
Inflate.c (components\external\freetype\src\gzip):  /* set window size */
Inflate.c (components\external\freetype\src\gzip):        z->msg = (char*)"invalid window size";
Inflate.c (components\external\libz):   thereafter.  This reduces the size of the code by about 2K bytes, in
Inflate.c (components\external\libz):    unsigned low, size;
Inflate.c (components\external\libz):    size = 1U << 9;
Inflate.c (components\external\libz):    printf("    static const code lenfix[%u] = {", size);
Inflate.c (components\external\libz):        if (++low == size) break;
Inflate.c (components\external\libz):    size = 1U << 5;
Inflate.c (components\external\libz):    printf("\n    static const code distfix[%u] = {", size);
Inflate.c (components\external\libz):        if (++low == size) break;
Inflate.c (components\external\libz):   The advantage may be dependent on the size of the processor's data caches.
Inflate.c (components\external\libz):                strm->msg = (char *)"invalid window size";
Inflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):        STORED,     /* i: waiting for stored size (length and complement) */
Inflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):    unsigned wbits;             /* log base 2 of requested window size */
Inflate.h (components\dfs\filesystems\jffs2\cyg\compress\src):    unsigned wsize;             /* window size or zero if not using window */
Inflate.h (components\external\libz):        STORED,     /* i: waiting for stored size (length and complement) */
Inflate.h (components\external\libz):    unsigned wbits;             /* log base 2 of requested window size */
Inflate.h (components\external\libz):    unsigned wsize;             /* window size or zero if not using window */
Inftrees.c (components\dfs\filesystems\jffs2\cyg\compress\src):       code lengths to determine what size sub-table is needed.  The length
Inftrees.c (components\external\freetype\src\gzip):   size is determined by the longest code.  However, the time it takes
Inftrees.c (components\external\freetype\src\gzip):   table size, in which case the length of the shortest code in bits is
Inftrees.c (components\external\freetype\src\gzip):/* Given a list of code lengths and a maximum table size, make a set of
Inftrees.c (components\external\freetype\src\gzip):        /* compute minimum size table less than or equal to l bits */
Inftrees.c (components\external\freetype\src\gzip):        z = z > (uInt)l ? (uInt)l : z;        /* table size upper limit */
Inftrees.c (components\external\libz):       code lengths to determine what size sub-table is needed.  The length
Inftrees.h (components\dfs\filesystems\jffs2\cyg\compress\src):/* Maximum size of dynamic tree.  The maximum found in a long but non-
Inftrees.h (components\external\freetype\src\gzip):/* Maximum size of dynamic tree.  The maximum found in a long but non-
Inftrees.h (components\external\libz):/* Maximum size of dynamic tree.  The maximum found in a long but non-
Infutil.h (components\dfs\filesystems\jffs2\cyg\compress\src):/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
Infutil.h (components\external\freetype\src\gzip):/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
Install.txt (components\external\jpeg):code pointers can be either size).  You may be able to use small model to
Ip.c (components\net\lwip-1.3.2\src\core\ipv4): * IP header such as packet size being at least larger than the header
Ip.c (components\net\lwip-1.3.2\src\core\ipv4): * size etc. If the packet was not destined for us, the packet is
Ip.c (components\net\lwip-1.4.1\src\core\ipv4): * IP header such as packet size being at least larger than the header
Ip.c (components\net\lwip-1.4.1\src\core\ipv4): * size etc. If the packet was not destined for us, the packet is
Ip.c (components\net\lwip\src\core\ipv4): * IP header such as packet size being at least larger than the header
Ip.c (components\net\lwip\src\core\ipv4): * size etc. If the packet was not destined for us, the packet is
Ip4.c (components\net\lwip-head\src\core\ipv4): * IP header such as packet size being at least larger than the header
Ip4.c (components\net\lwip-head\src\core\ipv4): * size etc. If the packet was not destined for us, the packet is
Ip6.c (components\net\lwip-1.3.2\src\core\ipv6): * received. The function does the basic checks of the IP header such as packet size
Ip6.c (components\net\lwip-1.3.2\src\core\ipv6): * being at least larger than the header size etc. If the packet was not destined for
Ip6.c (components\net\lwip-1.4.1\src\core\ipv6): * received. The function does the basic checks of the IP header such as packet size
Ip6.c (components\net\lwip-1.4.1\src\core\ipv6): * being at least larger than the header size etc. If the packet was not destined for
Ip6.c (components\net\lwip-head\src\core\ipv6): * IP header such as packet size being at least larger than the header
Ip6.c (components\net\lwip-head\src\core\ipv6): * size etc. If the packet was not destined for us, the packet is
Ip6.c (components\net\lwip\src\core\ipv6): * received. The function does the basic checks of the IP header such as packet size
Ip6.c (components\net\lwip\src\core\ipv6): * being at least larger than the header size etc. If the packet was not destined for
Ip6_frag.c (components\net\lwip-head\src\core\ipv6):     * but limited to the size of an mtu.
Ip6_frag.h (components\net\lwip-head\src\include\ipv6\lwip): * This is exported because memp needs to know the size.
Ipc.c (src): * @param size the size of mailbox
Ipc.c (src):                    rt_size_t    size,
Ipc.c (src):    mb->size       = size;
Ipc.c (src): * @param size the size of mailbox
Ipc.c (src):rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
Ipc.c (src):    mb->size     = size;
Ipc.c (src):    mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
Ipc.c (src):    if (mb->entry == mb->size && timeout == 0)
Ipc.c (src):    while (mb->entry == mb->size)
Ipc.c (src):    if (mb->in_offset >= mb->size)
Ipc.c (src):    if (mb->out_offset >= mb->size)
Ipc.c (src): * @param msg_size the maximum size of message
Ipc.c (src): * @param pool_size the size of buffer to save messages
Ipc.c (src):    /* get correct message size */
Ipc.c (src): * @param msg_size the size of message
Ipc.c (src):    /* get correct message size */
Ipc.c (src): * @param size the size of buffer
Ipc.c (src):rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
Ipc.c (src):    RT_ASSERT(size != 0);
Ipc.c (src):    /* greater than one message size */
Ipc.c (src):    if (size > mq->msg_size)
Ipc.c (src):    rt_memcpy(msg + 1, buffer, size);
Ipc.c (src): * @param size the size of buffer
Ipc.c (src):rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
Ipc.c (src):    RT_ASSERT(size != 0);
Ipc.c (src):    /* greater than one message size */
Ipc.c (src):    if (size > mq->msg_size)
Ipc.c (src):    rt_memcpy(msg + 1, buffer, size);
Ipc.c (src): * @param size the size of buffer
Ipc.c (src):                    rt_size_t  size,
Ipc.c (src):    RT_ASSERT(size != 0);
Ipc.c (src):    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
Ip_frag.c (components\net\lwip-1.3.2\src\core\ipv4): * by using a fixed size static memory buffer (PBUF_REF) or
Ip_frag.c (components\net\lwip-1.3.2\src\core\ipv4):     * but limited to the size of an mtu.
Ip_frag.c (components\net\lwip-1.4.1\src\core\ipv4): * by using a fixed size static memory buffer (PBUF_REF) or
Ip_frag.c (components\net\lwip-1.4.1\src\core\ipv4):     * but limited to the size of an mtu.
Ip_frag.c (components\net\lwip-head\src\core\ipv4): * by using a fixed size static memory buffer (PBUF_REF) or
Ip_frag.c (components\net\lwip-head\src\core\ipv4):     * but limited to the size of an mtu.
Ip_frag.c (components\net\lwip\src\core\ipv4): * by using a fixed size static memory buffer (PBUF_REF) or
Ip_frag.c (components\net\lwip\src\core\ipv4):     * but limited to the size of an mtu.
Ip_frag.h (components\net\lwip-1.3.2\src\include\ipv4\lwip): * This is exported because memp needs to know the size.
Ip_frag.h (components\net\lwip-1.4.1\src\include\ipv4\lwip): * This is exported because memp needs to know the size.
Ip_frag.h (components\net\lwip-head\src\include\ipv4\lwip): * This is exported because memp needs to know the size.
Ip_frag.h (components\net\lwip\src\include\ipv4\lwip): * This is exported because memp needs to know the size.
Isnan.c (components\external\espruino\libs\math):	{ /* size int not 4 */
Isnan.c (components\external\espruino\libs\math):	} /* size int not 4 */
Jcarith.c (components\external\jpeg):  INT32 a;               /* A register, normalized size of coding interval */
Jcarith.c (components\external\jpeg):/* The following two definitions specify the allocation chunk size
Jcarith.c (components\external\jpeg): * they don't provide sufficient gain to exceed the DAC size.
Jcarith.c (components\external\jpeg):      /* If the interval size (qe) for the less probable symbol (LPS)
Jcarith.c (components\external\jpeg):       * is larger than the interval size for the MPS, then exchange
Jcarith.c (components\external\jpeg):      /* If the interval size (qe) for the less probable symbol (LPS)
Jcarith.c (components\external\jpeg):       * is larger than the interval size for the MPS, then exchange
Jcdctmgr.c (components\external\jpeg):	 * The maximum coefficient size is +-16K (for 12-bit data), so this
Jchuff.c (components\external\jpeg): * The minimum safe size is 64 bits.
Jchuff.c (components\external\jpeg):  /* These are code and size indexed by symbol value */
Jchuff.c (components\external\jpeg):emit_bits_s (working_state * state, unsigned int code, int size)
Jchuff.c (components\external\jpeg):  /* if size is 0, caller used an invalid Huffman table entry */
Jchuff.c (components\external\jpeg):  if (size == 0)
Jchuff.c (components\external\jpeg):  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
Jchuff.c (components\external\jpeg):  put_bits += size;		/* new number of bits in buffer */
Jchuff.c (components\external\jpeg):emit_bits_e (huff_entropy_ptr entropy, unsigned int code, int size)
Jchuff.c (components\external\jpeg):  /* if size is 0, caller used an invalid Huffman table entry */
Jchuff.c (components\external\jpeg):  if (size == 0)
Jchuff.c (components\external\jpeg):  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
Jchuff.c (components\external\jpeg):  put_bits += size;		/* new number of bits in buffer */
Jchuff.c (components\external\jpeg):    if (nbits)			/* emit_bits rejects calls with size 0 */
Jchuff.c (components\external\jpeg):  if (nbits)			/* emit_bits rejects calls with size 0 */
Jchuff.c (components\external\jpeg): * microscopic --- usually less than a hundredth of a percent of total size.
Jcmainct.c (components\external\jpeg): * This routine handles all of the modes that use a full-size buffer.
Jcmainct.c (components\external\jpeg):   * may be of a different size.
Jcmarker.c (components\external\jpeg):   * Thumbnail X size		(1 byte)
Jcmarker.c (components\external\jpeg):   * Thumbnail Y size		(1 byte)
Jcmarker.c (components\external\jpeg):  emit_byte(cinfo, cinfo->density_unit); /* Pixel size information */
Jcmarker.c (components\external\jpeg):      /* If it's baseline except for quantizer size, warn the user */
Jcmaster.c (components\external\jpeg):    /* Overall image size in MCUs */
Jcmaster.c (components\external\jpeg):    /* Overall image size in MCUs */
Jcparam.c (components\external\jpeg):  cinfo->density_unit = 0;	/* Pixel size is unknown by default */
Jcsample.c (components\external\jpeg): * This version handles the special case of a full-size component,
Jcsample.c (components\external\jpeg): * This version handles the special case of a full-size component,
Jcsample.c (components\external\jpeg):    /* Compute size of an "output group" for DCT scaling.  This many samples
Jctrans.c (components\external\jpeg): * Each passed coefficient array must be the right size for that
Jdarith.c (components\external\jpeg):  INT32 a;               /* A register, normalized size of coding interval */
Jdarith.c (components\external\jpeg):/* The following two definitions specify the allocation chunk size
Jdarith.c (components\external\jpeg): * fixed size) shift for the LPS/MPS decision, and
Jdatadst.c (components\external\jpeg):#define OUTPUT_BUF_SIZE  4096	/* choose an efficiently fwrite'able size */
Jdatasrc.c (components\external\jpeg):#define INPUT_BUF_SIZE  4096	/* choose an efficiently fread'able size */
Jdhuff.c (components\external\jpeg):#define BIT_BUF_SIZE  32	/* size of buffer in bits */
Jdhuff.c (components\external\jpeg): * appropriately should be a win.  Unfortunately we can't define the size
Jdhuff.c (components\external\jpeg):	  if (s != 1)		/* size of new coef should always be 1 */
Jdinput.c (components\external\jpeg): * Routines to calculate various quantities related to the size of the image.
Jdinput.c (components\external\jpeg):    /* Overall image size in MCUs */
Jdinput.c (components\external\jpeg):    /* Overall image size in MCUs */
Jdmainct.c (components\external\jpeg): * be worth providing --- if someone wants a 1/8th-size preview, they probably
Jdmarker.c (components\external\jpeg): *      dependent on buffer size and chance buffer-boundary positions.)
Jdpostct.c (components\external\jpeg):  JDIMENSION strip_height;	/* buffer size in rows */
Jdsample.c (components\external\jpeg):   * Note: we do not allocate any storage for component(s) which are full-size,
Jdsample.c (components\external\jpeg): * For full-size components, we just make color_buf[ci] point at the
Jdsample.c (components\external\jpeg):    /* Compute size of an "input group" after IDCT scaling.  This many samples
Jerror.h (components\external\jpeg):JMESSAGE(JERR_BAD_DCTSIZE, "DCT scaled block size %dx%d not supported")
Jerror.h (components\external\jpeg):	 "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u")
Jerror.h (components\external\jpeg):JMESSAGE(JERR_HUFF_CLEN_OVERFLOW, "Huffman code size table overflow")
Jerror.h (components\external\jpeg):	 "Warning: thumbnail image size does not match data length %u")
Jfdctint.c (components\external\jpeg):  /* scaling for different DCT size. */
Jfdctint.c (components\external\jpeg):  /* scaling for different DCT size. */
Jfdctint.c (components\external\jpeg):  /* scaling for different DCT size. */
Jfdctint.c (components\external\jpeg):  /* scaling for different DCT size. */
Jfdctint.c (components\external\jpeg):  /* scaling for different DCT size. */
Jfdctint.c (components\external\jpeg):  /* scaling for different DCT size. */
Jfdctint.c (components\external\jpeg):  /* scaling for different DCT size. */
Jffs2.h (components\dfs\filesystems\jffs2\include\linux):	jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */
Jffs2.h (components\dfs\filesystems\jffs2\include\linux):	jint32_t csize;      /* (Compressed) data size */
Jffs2.h (components\dfs\filesystems\jffs2\include\linux):	jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */
Jffs2.h (components\dfs\filesystems\jffs2\include\linux):	jint32_t csize;      /* (Compressed) data size */
Jffs2_config.h (components\dfs\filesystems\jffs2):/* memory page size in kernel/asm/page.h, it is correspond with flash read/write
Jffs2_config.h (components\dfs\filesystems\jffs2): * option, so this size has a great impact on reading/writing speed */
Jidctint.c (components\external\jpeg): * regarding the output size.
Jidctint.c (components\external\jpeg): * producing a reduced-size 6x6 output block.
Jidctint.c (components\external\jpeg): * producing a reduced-size 5x5 output block.
Jidctint.c (components\external\jpeg): * producing a reduced-size 4x4 output block.
Jidctint.c (components\external\jpeg): * producing a reduced-size 3x3 output block.
Jidctint.c (components\external\jpeg): * producing a reduced-size 2x2 output block.
Jidctint.c (components\external\jpeg): * producing a reduced-size 1x1 output block.
Jidctint.c (components\external\jpeg): * producing a reduced-size 6x3 output block.
Jidctint.c (components\external\jpeg): * producing a reduced-size 3x6 output block.
Jinclude.h (components\external\jpeg): * NOTE: we assume the size parameters to these functions are of type size_t.
Jinclude.h (components\external\jpeg):#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
Jinclude.h (components\external\jpeg):#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))
Jinclude.h (components\external\jpeg):#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
Jinclude.h (components\external\jpeg):#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))
Jmemansi.c (components\external\jpeg):extern void * malloc JPP((size_t size));
Jmemansi.c (components\external\jpeg): * you probably won't be able to process useful-size images in only 64KB.
Jmemdos.c (components\external\jpeg):extern void * malloc JPP((size_t size));
Jmemdos.c (components\external\jpeg):   * blocks of size > 32Kbytes unless we give it a kick in the rear, like so:
Jmemmac.c (components\external\jpeg):   * CompactMem tries to create a contiguous block of the requested size,
Jmemmac.c (components\external\jpeg):   * and then returns the size of the largest free block (which could be
Jmemmac.c (components\external\jpeg):   * it may not be possible to allocate a single block of this size.
Jmemmgr.c (components\external\jpeg):  JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
Jmemmgr.c (components\external\jpeg):  JDIMENSION rowsperchunk;	/* allocation chunk size in mem_buffer */
Jmemmgr.c (components\external\jpeg):  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
Jmemmgr.c (components\external\jpeg): * deliberately bunch rows together to ensure a large request size.
Jmemmgr.c (components\external\jpeg):  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
Jmemmgr.c (components\external\jpeg): * The request_virt_array routines are told the total size of the image and
Jmemname.c (components\external\jpeg):extern void * malloc JPP((size_t size));
Jmemname.c (components\external\jpeg): * you probably won't be able to process useful-size images in only 64KB.
Jmemnobs.c (components\external\jpeg):extern void * malloc JPP((size_t size));
Jmemnobs.c (components\external\jpeg): * you probably won't be able to process useful-size images in only 64KB.
Jmemsys.h (components\external\jpeg): * size of the object being freed, just in case it's needed.
Jmemsys.h (components\external\jpeg): * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.
Jmemsys.h (components\external\jpeg): * may take an error exit if the specified maximum file size is exceeded.
Journal.c (components\external\sqlite-3.8.1\src):** the caller specifies a buffer size for an in-memory buffer to
Journal.c (components\external\sqlite-3.8.1\src):static int jrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){
Journal.c (components\external\sqlite-3.8.1\src):    rc = sqlite3OsTruncate(p->pReal, size);
Journal.c (components\external\sqlite-3.8.1\src):  }else if( size<p->iSize ){
Journal.c (components\external\sqlite-3.8.1\src):    p->iSize = size;
Journal.c (components\external\sqlite-3.8.1\src):** Query the size of the file in bytes.
Jpeglib.h (components\external\jpeg):  /* Component's size in DCT blocks.
Jpeglib.h (components\external\jpeg):  UINT8 density_unit;		/* JFIF code for pixel size units */
Jpeglib.h (components\external\jpeg):  UINT8 density_unit;		/* JFIF code for pixel size units */
Jpeglib.h (components\external\jpeg):#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
Jquant1.c (components\external\jpeg):	 * The maximum error is +- MAXJSAMPLE; this sets the required size
Jquant2.c (components\external\jpeg): * size, we reduce the precision of the input; typical practice is to retain
Jquant2.c (components\external\jpeg): * enough results.  This reduces the recommended histogram size from 256Kb
Jquant2.c (components\external\jpeg):#define MAXNUMCOLORS  (MAXJSAMPLE+1) /* maximum size of colormap */
Jquant2.c (components\external\jpeg):  int desired;			/* desired # of colors = size of colormap */
Jquant2.c (components\external\jpeg): * The speed of this approach is heavily influenced by the subbox size: too
Jquant2.c (components\external\jpeg): * size seems to be about 1/512th of the histogram (1/8th in each direction).
Jquant2.c (components\external\jpeg):       * this sets the required size of the range_limit array.
Jshardware.c (components\external\espruino\targets\rtthread):rt_err_t es_rx_ind(rt_device_t dev, rt_size_t size)
Jsutils.c (components\external\espruino\src):void *memcpy(void *dst, const void *src, size_t size) {
Jsutils.c (components\external\espruino\src):        for (i=0;i<size;i++)
Jsutils.c (components\external\espruino\src):void *memset(void *dst, int val, size_t size) {
Jsutils.c (components\external\espruino\src):  for (i=0;i<size;i++)
Jsutils.c (components\external\espruino\src):/// Wrap a value so it is always between 0 and size (eg. wrapAround(angle, 360))
Jsutils.c (components\external\espruino\src):JsVarFloat wrapAround(JsVarFloat val, JsVarFloat size) {
Jsutils.c (components\external\espruino\src):  val = val / size;
Jsutils.c (components\external\espruino\src):  return val * size;
Jsutils.h (components\external\espruino\src):#define JS_ERROR_BUF_SIZE 64 // size of buffer error messages are written into
Jsutils.h (components\external\espruino\src):// To handle variable size bit fields
Jsutils.h (components\external\espruino\src):void *memcpy(void *dst, const void *src, size_t size);
Jsutils.h (components\external\espruino\src):void *memset(void *dst, int val, size_t size);
Jsutils.h (components\external\espruino\src):/// Wrap a value so it is always between 0 and size (eg. wrapAround(angle, 360))
Jsutils.h (components\external\espruino\src):JsVarFloat wrapAround(JsVarFloat val, JsVarFloat size);
Jsvar.c (components\external\espruino\src):void jsvSetMaxVarsUsed(unsigned int size) {
Jsvar.c (components\external\espruino\src):  assert(size < JSVAR_BLOCK_SIZE); // remember - this is only for DEBUGGING - as such it doesn't use multiple blocks
Jsvar.c (components\external\espruino\src):  assert(size < JSVAR_CACHE_SIZE);
Jsvar.c (components\external\espruino\src):  jsVarsSize = size;
Jsvar.c (components\external\espruino\src):  return index+1; // new size
Jsvar.h (components\external\espruino\src): * safe just to set it to the same size as JsVarRef. However
Jsvar.h (components\external\espruino\src):void jsvSetMaxVarsUsed(unsigned int size);
Jswrap_array.c (components\external\espruino\src):         "return" : ["int", "The new size of the array"]
Jutils.c (components\external\jpeg):#define FMEMCOPY(dest,src,size)	MEMCOPY(dest,src,size)
Jutils.c (components\external\jpeg):#define FMEMZERO(target,size)	MEMZERO(target,size)
Jutils.c (components\external\jpeg):#define FMEMCOPY(dest,src,size)	_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))
Jutils.c (components\external\jpeg):#define FMEMZERO(target,size)	_fmemset((void FAR *)(target), 0, (size_t)(size))
Kservice.c (src):    /* If the size is small, or either SRC or DST is unaligned,
Kservice.c (src): * @param count the size of the area
Kservice.c (src):    register int size;
Kservice.c (src):    size = s;
Kservice.c (src):            size -= 2;
Kservice.c (src):            size--;
Kservice.c (src):    size -= precision;
Kservice.c (src):    size -= i;
Kservice.c (src):        if ((sign)&&(size>0))
Kservice.c (src):            size--;
Kservice.c (src):        while (size-->0)
Kservice.c (src):            -- size;
Kservice.c (src):        while (size-- > 0)
Kservice.c (src):    while (size-- > 0)
Kservice.c (src):                        rt_size_t   size,
Kservice.c (src):    end = buf + size - 1;
Kservice.c (src):        size = end - buf;
Kservice.c (src): * @param size the size of buffer
Kservice.c (src):rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
Kservice.c (src):    n = rt_vsnprintf(buf, size, fmt, args);
Kservice.c (src):     * written to buffer had if the size of the buffer been sufficiently
Kservice.c (src): * specified alignment size.
Kservice.c (src): * @param size the allocated memory block size
Kservice.c (src): * @param align the alignment size
Kservice.c (src):void* rt_malloc_align(rt_size_t size, rt_size_t align)
Kservice.c (src):    /* align the alignment size to 4 byte */
Kservice.c (src):    /* get total aligned size */
Kservice.c (src):    align_size = ((size + 0x03) & ~0x03) + align;
Kservice.c (src):int snprintf(char *buf, rt_size_t size, const char *fmt, ...) __attribute__((weak, alias("rt_snprintf")));
Lapi.c (components\external\lua\lua):LUA_API int lua_checkstack (lua_State *L, int size) {
Lapi.c (components\external\lua\lua):  if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK)
Lapi.c (components\external\lua\lua):  else if (size > 0) {
Lapi.c (components\external\lua\lua):    luaD_checkstack(L, size);
Lapi.c (components\external\lua\lua):    if (L->ci->top < L->top + size)
Lapi.c (components\external\lua\lua):      L->ci->top = L->top + size;
Lapi.c (components\external\lua\lua):LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
Lapi.c (components\external\lua\lua):  u = luaS_newudata(L, size, getcurrenv(L));
Lauxlib.c (components\external\lua\lua):  int size = 0;
Lauxlib.c (components\external\lua\lua):  for (; l->name; l++) size++;
Lauxlib.c (components\external\lua\lua):  return size;
Lauxlib.c (components\external\lua\lua):    int size = libsize(l);
Lauxlib.c (components\external\lua\lua):      if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)
Lauxlib.c (components\external\lua\lua):** getn-setn: size for arrays
Lauxlib.c (components\external\lua\lua):  if (lua_isnil(L, -1)) {  /* no `size' table? */
Lauxlib.c (components\external\lua\lua):    lua_pushvalue(L, -1);  /* `size' will be its own metatable */
Lauxlib.c (components\external\lua\lua):static const char *getF (lua_State *L, void *ud, size_t *size) {
Lauxlib.c (components\external\lua\lua):    *size = 1;
Lauxlib.c (components\external\lua\lua):  *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);
Lauxlib.c (components\external\lua\lua):  return (*size > 0) ? lf->buff : NULL;
Lauxlib.c (components\external\lua\lua):  size_t size;
Lauxlib.c (components\external\lua\lua):static const char *getS (lua_State *L, void *ud, size_t *size) {
Lauxlib.c (components\external\lua\lua):  if (L == NULL && size == NULL) // direct mode check
Lauxlib.c (components\external\lua\lua):  if (ls->size == 0) return NULL;
Lauxlib.c (components\external\lua\lua):  *size = ls->size;
Lauxlib.c (components\external\lua\lua):  ls->size = 0;
Lauxlib.c (components\external\lua\lua):LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
Lauxlib.c (components\external\lua\lua):  ls.size = size;
Lbaselib.c (components\external\lua\lua):static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
Lbaselib.c (components\external\lua\lua):  if (L == NULL && size == NULL) // direct mode check, doesn't happen
Lbaselib.c (components\external\lua\lua):    *size = 0;
Lbaselib.c (components\external\lua\lua):    return lua_tolstring(L, 3, size);
LCD.h (components\emwin1\inc):  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
LCD.h (components\emwin1\inc):#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
LCD.h (components\emwin1\inc):#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
LCD.h (components\emwin1\inc):#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
LCD.h (components\emwin1\inc):#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
LCD.h (components\emwin1\inc\include):  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
LCD.h (components\emwin1\inc\include):#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
LCD.h (components\emwin1\inc\include):#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
LCD.h (components\emwin1\inc\include):#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
LCD.h (components\emwin1\inc\include):#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
LCD.h (components\emwin\include):  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
LCD.h (components\emwin\include):#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
LCD.h (components\emwin\include):#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
LCD.h (components\emwin\include):#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
LCD.h (components\emwin\include):#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
LCD.h (components\stemwin\inc):  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
LCD.h (components\stemwin\inc):#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
LCD.h (components\stemwin\inc):#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
LCD.h (components\stemwin\inc):#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
LCD.h (components\stemwin\inc):#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
LCD.h (components\stemwin\inc\include):  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
LCD.h (components\stemwin\inc\include):#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
LCD.h (components\stemwin\inc\include):#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
LCD.h (components\stemwin\inc\include):#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
LCD.h (components\stemwin\inc\include):#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
LCDConf.c (components\emwin\config):// Physical display size
LCDConf.c (components\emwin\config):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\config):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_bitplains\generic):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_bitplains\generic):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_bitplains\generic):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_bitplains\r32c):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_bitplains\r32c):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_bitplains\r32c):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66708_c16_240x320):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66708_c16_240x320):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66708_c16_240x320):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66709_c16_240x260):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66709_c16_240x260):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66709_c16_240x260):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66714_c18_320x240):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66714_c18_320x240):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66714_c18_320x240):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):  _WriteCommand(REG_SCR1_FX1, 0x00);                // Reg:33h Action: Display size X start
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):  _WriteCommand(REG_SCR1_FX2, 0x9f);                // Reg:34h Action: Display size X end
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):  _WriteCommand(REG_SCR1_FY1, 0x00);                // Reg:35h Action: Display size Y start
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):  _WriteCommand(REG_SCR1_FY2, 0x7f);                // Reg:36h Action: Display size Y end
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c16_160x128):  // Display size configuration
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):  _WriteCommand(REG_SCR1_FX1, 0x00);                // Reg:33h Action: Display size X start
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):  _WriteCommand(REG_SCR1_FX2, 0x9f);                // Reg:34h Action: Display size X end
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):  _WriteCommand(REG_SCR1_FY1, 0x00);                // Reg:35h Action: Display size Y start
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):  _WriteCommand(REG_SCR1_FY2, 0x7f);                // Reg:36h Action: Display size Y end
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66718_c18_160x128):  // Display size configuration
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66719_c16_240x320):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66719_c16_240x320):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66719_c16_240x320):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_flexcolor\66719_c16_240x320):  // Display size configuration
LCDConf.c (components\emwin\lcdconf\guidrv_ist3088\multek_m4_320x240):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_lin\generic):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_lin\generic):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_lin\generic):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_lin\mpc5606_multilayer):// Physical layer size
LCDConf.c (components\emwin\lcdconf\guidrv_lin\mpc5606_multilayer):// Virtual display size
LCDConf.c (components\emwin\lcdconf\guidrv_lin\mpc5606_multilayer):    // Required for setting the layer size which is passed in the 'xSize' and 'xSize' element of pData 
LCDConf.c (components\emwin\lcdconf\guidrv_lin\s1d13506_c8_640x480):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_lin\s1d13506_c8_640x480):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_lin\s1d13506_c8_640x480):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_lin\s1d13506_c8_640x480):#define LCD_REG38 ((YSIZE_PHYS - 1) & 255) /* Vert. panel size, lsb */
LCDConf.c (components\emwin\lcdconf\guidrv_lin\s1d13506_c8_640x480):#define LCD_REG39 ((YSIZE_PHYS - 1) >> 8)  /* Vert. panel size, msb */
LCDConf.c (components\emwin\lcdconf\guidrv_s1d13748\s1d13748_c16_480x272):// Physical display size of MAIN layer
LCDConf.c (components\emwin\lcdconf\guidrv_s1d13748\s1d13748_c16_480x272):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_s1d13748\s1d13748_c16_480x272):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_s1d15g00\s1d15g00_c12_130x130):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_s1d15g00\s1d15g00_c12_130x130):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_s1d15g00\s1d15g00_c12_130x130):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_slin\s1d13700_m2_320x240):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_slin\ssd1848_m1_128x108):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_slin\ssd1848_m2_128x108):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_slin\t6963_m1_240x128):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_slin\uc1617_m2_128x108):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_spage\s1d15719_m1_180x132):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_spage\s1d15719_m1_180x132):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_spage\s1d15719_m1_180x132):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_spage\s1d15719_m1_180x132):  // Display size configuration
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m1_224x160):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m1_224x160):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m1_224x160):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m1_224x160):  // Display size configuration
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m4_224x160):// Physical display size
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m4_224x160):  #error Physical X size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m4_224x160):  #error Physical Y size of display is not defined!
LCDConf.c (components\emwin\lcdconf\guidrv_spage\uc1611s_m4_224x160):  // Display size configuration
LCDConf.c (components\emwin\lcdconf\guidrv_ssd1926\ssd1926_c8_320x240):// Physical display size
LCDConf_CustomColorConversion.c (components\emwin\lcdconf\common):// Physical display size
LCDConf_CustomColorConversion.c (components\emwin\lcdconf\common):  #error Physical X size of display is not defined!
LCDConf_CustomColorConversion.c (components\emwin\lcdconf\common):  #error Physical Y size of display is not defined!
LCDConf_FlexColor_Template.c (components\emwin1\config):// Physical display size
LCDConf_FlexColor_Template.c (components\emwin1\config):#define XSIZE_PHYS 128 // To be adapted to x-screen size
LCDConf_FlexColor_Template.c (components\emwin1\config):#define YSIZE_PHYS  160// To be adapted to y-screen size
LCDConf_FlexColor_Template.c (components\emwin1\config):  #error Physical X size of display is not defined!
LCDConf_FlexColor_Template.c (components\emwin1\config):  #error Physical Y size of display is not defined!
LCDConf_FlexColor_Template.c (components\stemwin\config):// Physical display size
LCDConf_FlexColor_Template.c (components\stemwin\config):#define XSIZE_PHYS 128 // To be adapted to x-screen size
LCDConf_FlexColor_Template.c (components\stemwin\config):#define YSIZE_PHYS  160// To be adapted to y-screen size
LCDConf_FlexColor_Template.c (components\stemwin\config):  #error Physical X size of display is not defined!
LCDConf_FlexColor_Template.c (components\stemwin\config):  #error Physical Y size of display is not defined!
LCDConf_GammaCorrection.c (components\emwin\lcdconf\common):// Physical display size
LCDConf_Lin_Template.c (components\emwin1\config):// Physical display size
LCDConf_Lin_Template.c (components\emwin1\config):  #error Physical X size of display is not defined!
LCDConf_Lin_Template.c (components\emwin1\config):  #error Physical Y size of display is not defined!
LCDConf_Lin_Template.c (components\emwin\lcdconf):// Physical display size
LCDConf_Lin_Template.c (components\emwin\lcdconf):  #error Physical X size of display is not defined!
LCDConf_Lin_Template.c (components\emwin\lcdconf):  #error Physical Y size of display is not defined!
LCDConf_Lin_Template.c (components\stemwin\config):// Physical display size
LCDConf_Lin_Template.c (components\stemwin\config):  #error Physical X size of display is not defined!
LCDConf_Lin_Template.c (components\stemwin\config):  #error Physical Y size of display is not defined!
Lcode.c (components\external\lua\lua):                  MAX_INT, "code size overflow");
Lcode.c (components\external\lua\lua):                  MAX_INT, "code size overflow");
Lcp.c (components\net\lwip-head\src\netif\ppp):      "Set MRU (maximum received packet size) for negotiation",
Lcp.c (components\net\lwip-head\src\netif\ppp):      "Maximum received packet size for multilink bundle",
Ldblib.c (components\external\lua\lua):#define LEVELS1	12	/* size of the first part of the stack */
Ldblib.c (components\external\lua\lua):#define LEVELS2	10	/* size of the second part of the stack */
Ldo.c (components\external\lua\lua):  if (n <= L->stacksize)  /* double size is enough? */
Ldo.c (components\external\lua\lua):    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
Ldo.c (components\external\lua\lua):    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
Ldump.c (components\external\lua\lua):#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
Ldump.c (components\external\lua\lua):static void DumpBlock(const void* b, size_t size, DumpState* D)
Ldump.c (components\external\lua\lua):  D->status=(*D->writer)(D->L,b,size,D->data);
Ldump.c (components\external\lua\lua):  D->wrote+=size;
Ldump.c (components\external\lua\lua):  strsize_t size=0;
Ldump.c (components\external\lua\lua):  DumpSize(size,D);
Ldump.c (components\external\lua\lua):  strsize_t size=( strsize_t )s->tsv.len+1;		/* include trailing '\0' */
Ldump.c (components\external\lua\lua):  DumpSize(size,D);
Ldump.c (components\external\lua\lua):  DumpBlock(getstr(s),size,D);
Lemon.c (components\external\sqlite-3.8.1\tool):void  SetSize(int);             /* All sets will be of size N */
Lemon.c (components\external\sqlite-3.8.1\tool):    /* Initialize the size for all follow and first sets */
Lemon.c (components\external\sqlite-3.8.1\tool):  /* Compute the action table.  In order to try to keep the size of the
Lemon.c (components\external\sqlite-3.8.1\tool):/* Reduce the size of the action tables, if possible, by making use
Lemon.c (components\external\sqlite-3.8.1\tool):static int size = 0;
Lemon.c (components\external\sqlite-3.8.1\tool):/* Set the set size */
Lemon.c (components\external\sqlite-3.8.1\tool):  size = n+1;
Lemon.c (components\external\sqlite-3.8.1\tool):  s = (char*)calloc( size, 1);
Lemon.c (components\external\sqlite-3.8.1\tool):  assert( e>=0 && e<size );
Lemon.c (components\external\sqlite-3.8.1\tool):  for(i=0; i<size; i++){
Lemon.c (components\external\sqlite-3.8.1\tool):  int size;               /* The number of available slots. */
Lemon.c (components\external\sqlite-3.8.1\tool):    x1a->size = 1024;
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x1a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  if( x1a->count>=x1a->size ){
Lemon.c (components\external\sqlite-3.8.1\tool):    int i,size;
Lemon.c (components\external\sqlite-3.8.1\tool):    array.size = size = x1a->size*2;
Lemon.c (components\external\sqlite-3.8.1\tool):      (sizeof(x1node) + sizeof(x1node*))*size );
Lemon.c (components\external\sqlite-3.8.1\tool):    array.ht = (x1node**)&(array.tbl[size]);
Lemon.c (components\external\sqlite-3.8.1\tool):    for(i=0; i<size; i++) array.ht[i] = 0;
Lemon.c (components\external\sqlite-3.8.1\tool):      h = strhash(oldnp->data) & (size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x1a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = strhash(key) & (x1a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  int size;               /* The number of available slots. */
Lemon.c (components\external\sqlite-3.8.1\tool):    x2a->size = 128;
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x2a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  if( x2a->count>=x2a->size ){
Lemon.c (components\external\sqlite-3.8.1\tool):    int i,size;
Lemon.c (components\external\sqlite-3.8.1\tool):    array.size = size = x2a->size*2;
Lemon.c (components\external\sqlite-3.8.1\tool):      (sizeof(x2node) + sizeof(x2node*))*size );
Lemon.c (components\external\sqlite-3.8.1\tool):    array.ht = (x2node**)&(array.tbl[size]);
Lemon.c (components\external\sqlite-3.8.1\tool):    for(i=0; i<size; i++) array.ht[i] = 0;
Lemon.c (components\external\sqlite-3.8.1\tool):      h = strhash(oldnp->key) & (size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x2a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = strhash(key) & (x2a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):/* Return the size of the array */
Lemon.c (components\external\sqlite-3.8.1\tool):  int i,size;
Lemon.c (components\external\sqlite-3.8.1\tool):  size = x2a->count;
Lemon.c (components\external\sqlite-3.8.1\tool):  array = (struct symbol **)calloc(size, sizeof(struct symbol *));
Lemon.c (components\external\sqlite-3.8.1\tool):    for(i=0; i<size; i++) array[i] = x2a->tbl[i].data;
Lemon.c (components\external\sqlite-3.8.1\tool):  int size;               /* The number of available slots. */
Lemon.c (components\external\sqlite-3.8.1\tool):    x3a->size = 128;
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x3a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  if( x3a->count>=x3a->size ){
Lemon.c (components\external\sqlite-3.8.1\tool):    int i,size;
Lemon.c (components\external\sqlite-3.8.1\tool):    array.size = size = x3a->size*2;
Lemon.c (components\external\sqlite-3.8.1\tool):      (sizeof(x3node) + sizeof(x3node*))*size );
Lemon.c (components\external\sqlite-3.8.1\tool):    array.ht = (x3node**)&(array.tbl[size]);
Lemon.c (components\external\sqlite-3.8.1\tool):    for(i=0; i<size; i++) array.ht[i] = 0;
Lemon.c (components\external\sqlite-3.8.1\tool):      h = statehash(oldnp->key) & (size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x3a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = statehash(key) & (x3a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  int i,size;
Lemon.c (components\external\sqlite-3.8.1\tool):  size = x3a->count;
Lemon.c (components\external\sqlite-3.8.1\tool):  array = (struct state **)malloc( sizeof(struct state *)*size );
Lemon.c (components\external\sqlite-3.8.1\tool):    for(i=0; i<size; i++) array[i] = x3a->tbl[i].data;
Lemon.c (components\external\sqlite-3.8.1\tool):  int size;               /* The number of available slots. */
Lemon.c (components\external\sqlite-3.8.1\tool):    x4a->size = 64;
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x4a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  if( x4a->count>=x4a->size ){
Lemon.c (components\external\sqlite-3.8.1\tool):    int i,size;
Lemon.c (components\external\sqlite-3.8.1\tool):    array.size = size = x4a->size*2;
Lemon.c (components\external\sqlite-3.8.1\tool):      (sizeof(x4node) + sizeof(x4node*))*size );
Lemon.c (components\external\sqlite-3.8.1\tool):    array.ht = (x4node**)&(array.tbl[size]);
Lemon.c (components\external\sqlite-3.8.1\tool):    for(i=0; i<size; i++) array.ht[i] = 0;
Lemon.c (components\external\sqlite-3.8.1\tool):      h = confighash(oldnp->data) & (size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = ph & (x4a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  h = confighash(key) & (x4a->size-1);
Lemon.c (components\external\sqlite-3.8.1\tool):  for(i=0; i<x4a->size; i++) x4a->ht[i] = 0;
Lemon.html (components\external\sqlite-3.8.1\doc):encourage rules to reduce sooner and keep the stack size down.
Lemon.html (components\external\sqlite-3.8.1\doc):by using left-recursion, then you might want to increase the size
Lemon.html (components\external\sqlite-3.8.1\doc):with a stack of the requested size.  The default value is 100.</p>
Lemon.html (components\external\sqlite-3.8.1\doc):the grammar designer should keep in mind that the size of the union
Lemon.html (components\external\sqlite-3.8.1\doc):will be the size of its largest element.  So if you have a single
Lempar.c (components\external\sqlite-3.8.1\src):** Try to increase the size of the parser stack.
Lempar.c (components\external\sqlite-3.8.1\tool):** Try to increase the size of the parser stack.
Lfunc.c (components\external\lua\lua):  int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
Lfunc.c (components\external\lua\lua):  luaM_freemem(L, c, size);
Lgc.c (components\external\lua\lua):  if (!isfixedstack(l)) /* if stack size is fixed, can't resize it. */
Lgc.c (components\external\lua\lua):  /* check size of string hash */
Lgc.c (components\external\lua\lua):  if (g->strt.nuse < cast(lu_int32, g->strt.size/4) &&
Lgc.c (components\external\lua\lua):      g->strt.size > MINSTRTABSIZE*2)
Lgc.c (components\external\lua\lua):    luaS_resize(L, g->strt.size/2);  /* table is too big */
Lgc.c (components\external\lua\lua):  /* it is not safe to re-size the buffer if it is in use. */
Lgc.c (components\external\lua\lua):  /* check size of buffer */
Lgc.c (components\external\lua\lua):  for (i = 0; i < g->strt.size; i++)  /* free all string lists */
Lgc.c (components\external\lua\lua):  size_t udsize;  /* total size of userdata to be finalized */
Lgc.c (components\external\lua\lua):  if (g->sweepstrgc >= g->strt.size)  /* nothing more to sweep? */
Libjpeg.txt (components\external\jpeg):	Set parameters for compression, including image size & colorspace
Libjpeg.txt (components\external\jpeg):about the image's size, colorspace, etc is available when the application
Libjpeg.txt (components\external\jpeg):output scaling ratio that will fit the image into the available screen size.
Libjpeg.txt (components\external\jpeg):JSAMPLEs, the maximum number of colors is limited by the size of JSAMPLE
Libjpeg.txt (components\external\jpeg):3. Set parameters for compression, including image size & colorspace.
Libjpeg.txt (components\external\jpeg):example.c shows the following code for the case of a full-size 2-D source
Libjpeg.txt (components\external\jpeg):	of file size compared to the default tables.  Note that when this is
Libjpeg.txt (components\external\jpeg):	If TRUE, use direct DCT scaling with DCT size > 8 for downsampling
Libjpeg.txt (components\external\jpeg):	If FALSE, use only DCT size <= 8 and simple separate downsampling.
Libjpeg.txt (components\external\jpeg):	indicating square pixels of unknown size.
Libjpeg.txt (components\external\jpeg):to pick a scaling ratio that will get close to a desired target size.
Libjpeg.txt (components\external\jpeg):	by jpeg_read_header() with the source DCT size, which is currently
Libjpeg.txt (components\external\jpeg):	unchanged, then this specifies the DCT scaled size to be applied on
Libjpeg.txt (components\external\jpeg):	the source DCT size is currently always 8.  Smaller scaling ratios
Libjpeg.txt (components\external\jpeg):	map for the image.  This usually looks a lot better than the one-size-
Libjpeg.txt (components\external\jpeg):actual_number_of_colors to the map size.  Otherwise, jpeg_start_decompress()
Libjpeg.txt (components\external\jpeg):	If TRUE, use direct DCT scaling with DCT size > 8 for upsampling
Libjpeg.txt (components\external\jpeg):	If FALSE, use only DCT size <= 8 and simple separate upsampling.
Libjpeg.txt (components\external\jpeg):close to a desired target size.  It's also important if you are using the
Libjpeg.txt (components\external\jpeg):that would be rather inefficient.)  The buffer's size and location are
Libjpeg.txt (components\external\jpeg):and total size in private fields not visible to the library.
Libjpeg.txt (components\external\jpeg):address and total size in private fields not visible to the library.
Libjpeg.txt (components\external\jpeg):Because of the backtracking behavior, a good-size output buffer is essential
Libjpeg.txt (components\external\jpeg):    so bytes).  The recommended buffer size is bigger than this anyway, so
Libjpeg.txt (components\external\jpeg):even whether there is a fixed-size input buffer.)
Libjpeg.txt (components\external\jpeg):image of the same size, so the decoder must be fairly fast in relation to the
Libjpeg.txt (components\external\jpeg):different sizes.  If the image dimensions are not a multiple of the MCU size,
Libjpeg.txt (components\external\jpeg):images, the standard image size is usually a multiple of the DCT block size,
Libjpeg.txt (components\external\jpeg):during reading and are not stored in the block arrays.  (The size of each
Libjpeg.txt (components\external\jpeg):pass_limit; the step size is usually but not necessarily 1.  The pass_limit
Libjpeg.txt (components\external\jpeg):size, estimating progress based on the fraction of the file that's been read
Libjpeg.txt (components\external\jpeg):  ptr = (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE, size);
Libjpeg.txt (components\external\jpeg):after creating the JPEG object.  (Of course, there is still a minimum size for
Libjpeg.txt (components\external\jpeg): 1. About 24K in more-or-less-fixed-size data.  This varies a bit depending
Libjpeg.txt (components\external\jpeg): 2. Strip buffers (of size proportional to the image width) for IDCT and
Libjpeg.txt (components\external\jpeg):32-bit ints.  For 12-bit JPEG data, double the size of the strip buffers and
Libjpeg.txt (components\external\jpeg):quantization pixel buffer.  The "fixed-size" data will be somewhat smaller
Libjpeg.txt (components\external\jpeg):You can reduce the size of the library by compiling out various optional
Libjpeg.txt (components\external\jpeg):"far"; code pointers can be either size).  You may be able to use small
Libjpeg.txt (components\external\jpeg):depending on selected operating mode, and to a lesser extent on image size.
LISTWHEEL_Private.h (components\emwin1\inc):  int                     ySizeData;        // Data size in pixels
LISTWHEEL_Private.h (components\emwin1\inc\include):  int                     ySizeData;        // Data size in pixels
LISTWHEEL_Private.h (components\emwin\include):  int                     ySizeData;        // Data size in pixels
LISTWHEEL_Private.h (components\stemwin\inc):  int                     ySizeData;        // Data size in pixels
LISTWHEEL_Private.h (components\stemwin\inc\include):  int                     ySizeData;        // Data size in pixels
Llimits.h (components\external\lua\lua):/* minimum size for the string table (must be power of 2) */
Llimits.h (components\external\lua\lua):/* minimum size for string buffer */
Lmem.c (components\external\lua\lua):** (`osize' is the old size, `nsize' is the new size)
Lmem.c (components\external\lua\lua):** * frealloc(ud, NULL, 0, x) creates a new block of size `x'
Lmem.c (components\external\lua\lua):** (any reallocation to an equal or smaller size cannot fail!)
Lmem.c (components\external\lua\lua):void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
Lmem.c (components\external\lua\lua):  if (*size >= limit/2) {  /* cannot double it? */
Lmem.c (components\external\lua\lua):    if (*size >= limit)  /* cannot grow even a little? */
Lmem.c (components\external\lua\lua):    newsize = (*size)*2;
Lmem.c (components\external\lua\lua):      newsize = MINSIZEARRAY;  /* minimum size */
Lmem.c (components\external\lua\lua):  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
Lmem.c (components\external\lua\lua):  *size = newsize;  /* update only when everything else is OK */
Lmem.h (components\external\lua\lua):#define luaM_growvector(L,v,nelems,size,t,limit,e) \
Lmem.h (components\external\lua\lua):          if ((nelems)+1 > (size)) \
Lmem.h (components\external\lua\lua):            ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
Lmem.h (components\external\lua\lua):                                                          size_t size);
Lmem.h (components\external\lua\lua):LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
Lobject.h (components\external\lua\lua):  int sizek;  /* size of `k' */
Lobject.h (components\external\lua\lua):  int sizep;  /* size of `p' */
Lobject.h (components\external\lua\lua):  lu_byte lsizenode;  /* log2 of size of `node' array */
Lobject.h (components\external\lua\lua):  int sizearray;  /* size of `array' array */
Lobject.h (components\external\lua\lua):** `module' operation for hashing (size is always a power of 2)
Lobject.h (components\external\lua\lua):#define lmod(s,size) \
Lobject.h (components\external\lua\lua):	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
Lodepng.c (components\external\lodepng):static void* lodepng_malloc(size_t size)
Lodepng.c (components\external\lodepng):  return malloc(size);
Lodepng.c (components\external\lodepng):void* lodepng_malloc(size_t size);
Lodepng.c (components\external\lodepng):  size_t size; /*size in number of unsigned longs*/
Lodepng.c (components\external\lodepng):  size_t allocsize; /*allocated size in bytes*/
Lodepng.c (components\external\lodepng):  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
Lodepng.c (components\external\lodepng):static unsigned uivector_resize(uivector* p, size_t size)
Lodepng.c (components\external\lodepng):  if(!uivector_reserve(p, size * sizeof(unsigned))) return 0;
Lodepng.c (components\external\lodepng):  p->size = size;
Lodepng.c (components\external\lodepng):static unsigned uivector_resizev(uivector* p, size_t size, unsigned value)
Lodepng.c (components\external\lodepng):  size_t oldsize = p->size, i;
Lodepng.c (components\external\lodepng):  if(!uivector_resize(p, size)) return 0;
Lodepng.c (components\external\lodepng):  for(i = oldsize; i < size; ++i) p->data[i] = value;
Lodepng.c (components\external\lodepng):  p->size = p->allocsize = 0;
Lodepng.c (components\external\lodepng):  if(!uivector_resize(p, p->size + 1)) return 0;
Lodepng.c (components\external\lodepng):  p->data[p->size - 1] = c;
Lodepng.c (components\external\lodepng):  size_t size; /*used size*/
Lodepng.c (components\external\lodepng):  size_t allocsize; /*allocated size*/
Lodepng.c (components\external\lodepng):static unsigned ucvector_resize(ucvector* p, size_t size)
Lodepng.c (components\external\lodepng):  if(!ucvector_reserve(p, size * sizeof(unsigned char))) return 0;
Lodepng.c (components\external\lodepng):  p->size = size;
Lodepng.c (components\external\lodepng):  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
Lodepng.c (components\external\lodepng):  p->size = p->allocsize = 0;
Lodepng.c (components\external\lodepng):static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value)
Lodepng.c (components\external\lodepng):  size_t oldsize = p->size, i;
Lodepng.c (components\external\lodepng):  if(!ucvector_resize(p, size)) return 0;
Lodepng.c (components\external\lodepng):  for(i = oldsize; i < size; ++i) p->data[i] = value;
Lodepng.c (components\external\lodepng):/*you can both convert from vector to buffer&size and vica versa. If you use
Lodepng.c (components\external\lodepng):init_buffer to take over a buffer and size, it is not needed to use cleanup*/
Lodepng.c (components\external\lodepng):static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
Lodepng.c (components\external\lodepng):  p->allocsize = p->size = size;
Lodepng.c (components\external\lodepng):  if(!ucvector_resize(p, p->size + 1)) return 0;
Lodepng.c (components\external\lodepng):  p->data[p->size - 1] = c;
Lodepng.c (components\external\lodepng):static unsigned string_resize(char** out, size_t size)
Lodepng.c (components\external\lodepng):  char* data = (char*)lodepng_realloc(*out, size + 1);
Lodepng.c (components\external\lodepng):    data[size] = 0; /*null termination char*/
Lodepng.c (components\external\lodepng):  ucvector_resize(buffer, buffer->size + 4); /*todo: give error if resize failed*/
Lodepng.c (components\external\lodepng):  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);
Lodepng.c (components\external\lodepng):  long size;
Lodepng.c (components\external\lodepng):  size = ftell(file);
Lodepng.c (components\external\lodepng):  *out = (unsigned char*)lodepng_malloc((size_t)size);
Lodepng.c (components\external\lodepng):  if(size && (*out)) (*outsize) = fread(*out, 1, (size_t)size, file);
Lodepng.c (components\external\lodepng):  if(!(*out) && size) return 83; /*the above malloc failed*/
Lodepng.c (components\external\lodepng):  (bitstream->data[bitstream->size - 1]) |= (bit << ((*bitpointer) & 0x7));\
Lodepng.c (components\external\lodepng):  for(size_t i = 0; i != tree->tree1d.size; ++i)
Lodepng.c (components\external\lodepng):  *outsize = v.size;
Lodepng.c (components\external\lodepng):/*bitlen is the size in bits of the code*/
Lodepng.c (components\external\lodepng):given array must be sorted (if no value is smaller, it returns the size of the given array)*/
Lodepng.c (components\external\lodepng):static unsigned getHash(const unsigned char* data, size_t size, size_t pos)
Lodepng.c (components\external\lodepng):  if(pos + 2 < size)
Lodepng.c (components\external\lodepng):    if(pos >= size) return 0;
Lodepng.c (components\external\lodepng):    amount = size - pos;
Lodepng.c (components\external\lodepng):static unsigned countZeros(const unsigned char* data, size_t size, size_t pos)
Lodepng.c (components\external\lodepng):  if(end > data + size) end = data + size;
Lodepng.c (components\external\lodepng):  for(i = 0; i != lz77_encoded->size; ++i)
Lodepng.c (components\external\lodepng):    for(i = 0; i != lz77_encoded.size; ++i)
Lodepng.c (components\external\lodepng):    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll.data, 257, frequencies_ll.size, 15);
Lodepng.c (components\external\lodepng):    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d.data, 2, frequencies_d.size, 15);
Lodepng.c (components\external\lodepng):    for(i = 0; i != (unsigned)bitlen_lld.size; ++i)
Lodepng.c (components\external\lodepng):      while(i + j + 1 < (unsigned)bitlen_lld.size && bitlen_lld.data[i + j + 1] == bitlen_lld.data[i]) ++j;
Lodepng.c (components\external\lodepng):    for(i = 0; i != bitlen_lld_e.size; ++i)
Lodepng.c (components\external\lodepng):                                            frequencies_cl.size, frequencies_cl.size, 7);
Lodepng.c (components\external\lodepng):    while(bitlen_cl.data[bitlen_cl.size - 1] == 0 && bitlen_cl.size > 4)
Lodepng.c (components\external\lodepng):      /*remove zeros at the end, but minimum size must be 4*/
Lodepng.c (components\external\lodepng):      if(!uivector_resize(&bitlen_cl, bitlen_cl.size - 1)) ERROR_BREAK(83 /*alloc fail*/);
Lodepng.c (components\external\lodepng):    HCLEN = (unsigned)bitlen_cl.size - 4;
Lodepng.c (components\external\lodepng):    for(i = 0; i != bitlen_lld_e.size; ++i)
Lodepng.c (components\external\lodepng):  *outsize = v.size;
Lodepng.c (components\external\lodepng):  if(insize < 2) return 53; /*error, size of zlib data too small*/
Lodepng.c (components\external\lodepng):  unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
Lodepng.c (components\external\lodepng):  *outsize = outv.size;
Lodepng.c (components\external\lodepng):  the max of 256 colors, it'll have the exact alloc size*/
Lodepng.c (components\external\lodepng):/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
Lodepng.c (components\external\lodepng):  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
Lodepng.c (components\external\lodepng):out: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h
Lodepng.c (components\external\lodepng):out has the following size in bits: w * h * bpp.
Lodepng.c (components\external\lodepng):    error = zlib_decompress(&decoded.data, &decoded.size,
Lodepng.c (components\external\lodepng):      error = zlib_decompress(&decoded.data, &decoded.size,
Lodepng.c (components\external\lodepng):      if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;
Lodepng.c (components\external\lodepng):  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
Lodepng.c (components\external\lodepng):  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
Lodepng.c (components\external\lodepng):    /*error: size of the in buffer too small to contain next chunk*/
Lodepng.c (components\external\lodepng):    /*error: chunk length larger than the max PNG chunk size*/
Lodepng.c (components\external\lodepng):      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
Lodepng.c (components\external\lodepng):      size_t oldsize = idat.size;
Lodepng.c (components\external\lodepng):  /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
Lodepng.c (components\external\lodepng):  If the decompressed size does not match the prediction, the image must be corrupt.*/
Lodepng.c (components\external\lodepng):    /*Adam-7 interlaced: predicted size is the sum of the 7 sub-images sizes*/
Lodepng.c (components\external\lodepng):    state->error = zlib_decompress(&scanlines.data, &scanlines.size, idat.data,
Lodepng.c (components\external\lodepng):                                   idat.size, &state->decoder.zlibsettings);
Lodepng.c (components\external\lodepng):    if(!state->error && scanlines.size != predict) state->error = 91; /*decompressed size doesn't match prediction*/
Lodepng.c (components\external\lodepng):  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));
Lodepng.c (components\external\lodepng):  out->allocsize = out->size; /*fix the allocsize again*/
Lodepng.c (components\external\lodepng):  error = addChunk(out, "IHDR", header.data, header.size);
Lodepng.c (components\external\lodepng):  error = addChunk(out, "PLTE", PLTE.data, PLTE.size);
Lodepng.c (components\external\lodepng):  error = addChunk(out, "tRNS", tRNS.data, tRNS.size);
Lodepng.c (components\external\lodepng):  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);
Lodepng.c (components\external\lodepng):  if(!error) error = addChunk(out, "IDAT", zlibdata.data, zlibdata.size);
Lodepng.c (components\external\lodepng):  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
Lodepng.c (components\external\lodepng):  error = addChunk(out, "tEXt", text.data, text.size);
Lodepng.c (components\external\lodepng):  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
Lodepng.c (components\external\lodepng):  error = zlib_compress(&compressed.data, &compressed.size,
Lodepng.c (components\external\lodepng):    for(i = 0; i != compressed.size; ++i) ucvector_push_back(&data, compressed.data[i]);
Lodepng.c (components\external\lodepng):    error = addChunk(out, "zTXt", data.data, data.size);
Lodepng.c (components\external\lodepng):  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
Lodepng.c (components\external\lodepng):    error = zlib_compress(&compressed_data.data, &compressed_data.size,
Lodepng.c (components\external\lodepng):      for(i = 0; i != compressed_data.size; ++i) ucvector_push_back(&data, compressed_data.data[i]);
Lodepng.c (components\external\lodepng):  if(!error) error = addChunk(out, "iTXt", data.data, data.size);
Lodepng.c (components\external\lodepng):  error = addChunk(out, "bKGD", bKGD.data, bKGD.size);
Lodepng.c (components\external\lodepng):  error = addChunk(out, "pHYs", data.data, data.size);
Lodepng.c (components\external\lodepng):  out must be a buffer with as size: h + (w * h * bpp + 7) / 8, because there are
Lodepng.c (components\external\lodepng):    size_t size[5];
Lodepng.c (components\external\lodepng):        unsigned testsize = attempt[type].size;
Lodepng.c (components\external\lodepng):        size[type] = 0;
Lodepng.c (components\external\lodepng):        zlib_compress(&dummy, &size[type], attempt[type].data, testsize, &zlibsettings);
Lodepng.c (components\external\lodepng):        /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
Lodepng.c (components\external\lodepng):        if(type == 0 || size[type] < smallest)
Lodepng.c (components\external\lodepng):          smallest = size[type];
Lodepng.c (components\external\lodepng):    "Use of uninitialised value of size ###" warning from valgrind*/
Lodepng.c (components\external\lodepng):in: non-interlaced image with size w*h
Lodepng.c (components\external\lodepng):in has the following size in bits: w * h * bpp.
Lodepng.c (components\external\lodepng):    *outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/
Lodepng.c (components\external\lodepng):    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
Lodepng.c (components\external\lodepng):    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
Lodepng.c (components\external\lodepng):    out->allocsize = out->size; /*fix the allocsize again*/
Lodepng.c (components\external\lodepng):    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
Lodepng.c (components\external\lodepng):    size_t size = (w * h * lodepng_get_bpp(&info.color) + 7) / 8;
Lodepng.c (components\external\lodepng):    converted = (unsigned char*)lodepng_malloc(size);
Lodepng.c (components\external\lodepng):    if(!converted && size) state->error = 83; /*alloc fail*/
Lodepng.c (components\external\lodepng):  *outsize = outv.size;
Lodepng.c (components\external\lodepng):    case 40: return "tRNS chunk has wrong size for greyscale image";
Lodepng.c (components\external\lodepng):    case 41: return "tRNS chunk has wrong size for RGB image";
Lodepng.c (components\external\lodepng):    case 43: return "bKGD chunk has wrong size for palette image";
Lodepng.c (components\external\lodepng):    case 44: return "bKGD chunk has wrong size for greyscale image";
Lodepng.c (components\external\lodepng):    case 45: return "bKGD chunk has wrong size for RGB image";
Lodepng.c (components\external\lodepng):    case 53: return "size of zlib data too small";
Lodepng.c (components\external\lodepng):    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
Lodepng.c (components\external\lodepng):    case 73: return "invalid tIME chunk size";
Lodepng.c (components\external\lodepng):    case 74: return "invalid pHYs chunk size";
Lodepng.c (components\external\lodepng):    case 77: return "integer overflow in buffer size";
Lodepng.c (components\external\lodepng):    case 89: return "text chunk keyword too short or long: must have size 1-79";
Lodepng.c (components\external\lodepng):    case 91: return "invalid decompressed idat size";
Lodepng.c (components\external\lodepng):  std::streamsize size = 0;
Lodepng.c (components\external\lodepng):  if(file.seekg(0, std::ios::end).good()) size = file.tellg();
Lodepng.c (components\external\lodepng):  if(file.seekg(0, std::ios::beg).good()) size -= file.tellg();
Lodepng.c (components\external\lodepng):  buffer.resize(size_t(size));
Lodepng.c (components\external\lodepng):  if(size > 0) file.read((char*)(&buffer[0]), size);
Lodepng.c (components\external\lodepng):  file.write(buffer.empty() ? 0 : (char*)&buffer[0], std::streamsize(buffer.size()));
Lodepng.c (components\external\lodepng):  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);
Lodepng.c (components\external\lodepng):  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);
Lodepng.c (components\external\lodepng):  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);
Lodepng.c (components\external\lodepng):  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());
Lodepng.c (components\external\lodepng):  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
Lodepng.c (components\external\lodepng):  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;
Lodepng.c (components\external\lodepng):  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
Lodepng.h (components\external\lodepng):     After decoding, its size is w * h * (bytes per pixel) bytes larger than
Lodepng.h (components\external\lodepng):insize: size of the in buffer.
Lodepng.h (components\external\lodepng):outsize: Output parameter. Pointer to the size in bytes of the out buffer.
Lodepng.h (components\external\lodepng):image: The raw pixel data to encode. The size of this buffer should be
Lodepng.h (components\external\lodepng):  unsigned char* palette; /*palette in RGBARGBA... order. When allocated, must be either 0, or have size 1024*/
Lodepng.h (components\external\lodepng):  size_t palettesize; /*palette size in number of colors (amount of bytes is 4 * palettesize)*/
Lodepng.h (components\external\lodepng):/*Returns the byte size of a raw image buffer with given width, height and color mode*/
Lodepng.h (components\external\lodepng):  size_t unknown_chunks_size[3]; /*size in bytes of the unknown chunks, given for protection*/
Lodepng.h (components\external\lodepng):The out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel
Lodepng.h (components\external\lodepng):  LodePNGCompressSettings zlibsettings; /*settings for the zlib encoder, such as window size, ...*/
Lodepng.h (components\external\lodepng):/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/
Lodepng.h (components\external\lodepng):buffer and *outsize its size in bytes. out must be freed by user after usage.
Lodepng.h (components\external\lodepng):buffer and *outsize its size in bytes. out must be freed by user after usage.
Lodepng.h (components\external\lodepng):outsize: output parameter, size of the allocated out buffer
Lodepng.h (components\external\lodepng):buffersize: size of the buffer to write
Lodepng.h (components\external\lodepng):[ ] make sure encoder generates no chunks with size > (2^31)-1
Lodepng.h (components\external\lodepng):*) windowsize: the window size used by the LZ77 encoder (1 - 32768). Has value
Lodepng.h (components\external\lodepng):buffers (each with size) to contain 3 types of unknown chunks:
Log10.c (components\external\espruino\libs\math):z = (x + y) * L10EB;  /* accumulate terms in order of size */
Log_file.c (components\utilities\logtrace):static rt_size_t fdevice_write(rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size)
Log_file.c (components\utilities\logtrace):    return write(fdev->fd, buffer, size);
Log_trace.c (components\utilities\logtrace):static rt_size_t _log_write(rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size)
Log_trace.c (components\utilities\logtrace):    head_len = _lg_parse_lvl(ptr, size, &level);
Log_trace.c (components\utilities\logtrace):    head_len += _lg_parse_session(ptr+head_len, size-head_len, &session);
Log_trace.c (components\utilities\logtrace):        return size;
Log_trace.c (components\utilities\logtrace):        rt_device_write(_traceout_device, -1, ((char*)buffer)+head_len, size - head_len);
Log_trace.c (components\utilities\logtrace):    return size;
Lopcodes.h (components\external\lua\lua):** size and position of opcode arguments.
Lopcodes.h (components\external\lua\lua):OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
Lparser.c (components\external\lua\lua):  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
Lparser.c (components\external\lua\lua):  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
Lstate.c (components\external\lua\lua):  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
Lstate.c (components\external\lua\lua):  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size, TString *);
Lstate.c (components\external\lua\lua):  g->strt.size = 0;
Lstate.h (components\external\lua\lua):  int size;
Lstate.h (components\external\lua\lua):  int gcpause;  /* size of pause between successive GCs */
Lstate.h (components\external\lua\lua):  int size_ci;  /* size of array `base_ci' */
Lstring.c (components\external\lua\lua):  if (luaC_sweepstrgc(L) || newsize == tb->size || is_resizing_strings_gc(L))
Lstring.c (components\external\lua\lua):  if (newsize > tb->size) {
Lstring.c (components\external\lua\lua):    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
Lstring.c (components\external\lua\lua):    for (i=tb->size; i<newsize; i++) tb->hash[i] = NULL;
Lstring.c (components\external\lua\lua):  for (i=0; i<tb->size; i++) {
Lstring.c (components\external\lua\lua):  if (newsize < tb->size)
Lstring.c (components\external\lua\lua):    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
Lstring.c (components\external\lua\lua):  tb->size = newsize;
Lstring.c (components\external\lua\lua):  if ((tb->nuse + 1) > cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
Lstring.c (components\external\lua\lua):    luaS_resize(L, tb->size*2);  /* too crowded */
Lstring.c (components\external\lua\lua):  h = lmod(h, tb->size);
Lstring.c (components\external\lua\lua):  for (o = G(L)->strt.hash[lmod(h, G(L)->strt.size)];
Lstrlib.c (components\external\lua\lua):static int writer (lua_State *L, const void* b, size_t size, void* B) {
Lstrlib.c (components\external\lua\lua):  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
Lstrlib.c (components\external\lua\lua):/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
Lstrlib.c (components\external\lua\lua):** maximum size of each format specification (such as '%-099.99d')
Ltable.c (components\external\lua\lua):** part. The actual size of the array is the largest `n' such that at
Ltable.c (components\external\lua\lua):** max size of array part is 2^MAXBITS
Ltable.c (components\external\lua\lua):  int n = 0;  /* optimal size for array part */
Ltable.c (components\external\lua\lua):        n = twotoi;  /* optimal size (till now) */
Ltable.c (components\external\lua\lua):static void setarrayvector (lua_State *L, Table *t, int size) {
Ltable.c (components\external\lua\lua):  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
Ltable.c (components\external\lua\lua):  for (i=t->sizearray; i<size; i++)
Ltable.c (components\external\lua\lua):  t->sizearray = size;
Ltable.c (components\external\lua\lua):  if (nhsize > 0) { /* round new hashpart size up to next power of two. */
Ltable.c (components\external\lua\lua):  /* grow hash part to new size. */
Ltable.c (components\external\lua\lua):    else { /* new hashpart size is zero. */
Ltable.c (components\external\lua\lua):  /* compute new size for array part */
Ltablib.c (components\external\lua\lua):  luaL_setn(L, 1, e);  /* new size */
Luaconf.h (components\external\lua\lua):@@ LUA_IDSIZE gives the maximum size for the description of the source
Luaconf.h (components\external\lua\lua):** CHANGE it if you want a different size.
Luaconf.h (components\external\lua\lua):** too rigid for you.) Some of these constants control the size of
Luaconf.h (components\external\lua\lua):@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
Luaconf.h (components\external\lua\lua):@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
Luaconf.h (components\external\lua\lua):@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
Lua_in_finsh.c (components\external\lua\applications):rt_err_t lua_rx_ind(rt_device_t dev, rt_size_t size)
Lua_in_finsh.c (components\external\lua\applications):    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
Lundump.c (components\external\lua\lua):#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)
Lundump.c (components\external\lua\lua):static void LoadBlock(LoadState* S, void* b, size_t size)
Lundump.c (components\external\lua\lua): size_t r=luaZ_read(S->Z,b,size);
Lundump.c (components\external\lua\lua): S->total+=size;
Lundump.c (components\external\lua\lua):static void LoadMem (LoadState* S, void* b, int n, size_t size)
Lundump.c (components\external\lua\lua):  LoadBlock(S,b,n*size);
Lundump.c (components\external\lua\lua):    switch (size)
Lundump.c (components\external\lua\lua):   	    IF(1, "bad size");
Lundump.c (components\external\lua\lua): int32_t size;
Lundump.c (components\external\lua\lua): LoadVar(S,size);
Lundump.c (components\external\lua\lua): if (size==0)
Lundump.c (components\external\lua\lua):   s = luaZ_openspace(S->L,S->b,size);
Lundump.c (components\external\lua\lua):   LoadBlock(S,s,size);
Lundump.c (components\external\lua\lua):   return luaS_newlstr(S->L,s,size-1); /* remove trailing zero */
Lundump.c (components\external\lua\lua):   LoadBlock(S,NULL,size);
Lundump.c (components\external\lua\lua):   return luaS_newrolstr(S->L,s,size-1);
Lundump.h (components\external\lua\lua):/* size of header of binary files */
Lwipopts.h (components\net\lwip-1.3.2\src):/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
Lwipopts.h (components\net\lwip-1.3.2\src):/* TCP Maximum segment size. */
Lwipopts.h (components\net\lwip-1.4.1\src):/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
Lwipopts.h (components\net\lwip-1.4.1\src):/* TCP Maximum segment size. */
Lwipopts.h (components\net\lwip-head\src):/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
Lwipopts.h (components\net\lwip-head\src):/* TCP Maximum segment size. */
Lwipopts.h (components\net\lwip\src):/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
Lwipopts.h (components\net\lwip\src):/* TCP Maximum segment size. */
Lwip_sockets.c (components\dfs\filesystems\lwip):        d->size = 0;
Lwip_sockets.c (components\dfs\filesystems\lwip):int send(int s, const void *dataptr, size_t size, int flags)
Lwip_sockets.c (components\dfs\filesystems\lwip):    return lwip_send(sock, dataptr, size, flags);
Lwip_sockets.c (components\dfs\filesystems\lwip):int sendto(int s, const void *dataptr, size_t size, int flags,
Lwip_sockets.c (components\dfs\filesystems\lwip):    return lwip_sendto(sock, dataptr, size, flags, to, tolen);
Lwip_sockets.c (components\dfs\filesystems\lwip):        d->size = 0;
Lzio.c (components\external\lua\lua):  size_t size;
Lzio.c (components\external\lua\lua):  buff = z->reader(L, z->data, &size);
Lzio.c (components\external\lua\lua):  if (buff == NULL || size == 0) return EOZ;
Lzio.c (components\external\lua\lua):  z->n = size - 1;
Lzio.h (components\external\lua\lua):#define luaZ_resizebuffer(L, buff, size) \
Lzio.h (components\external\lua\lua):	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
Lzio.h (components\external\lua\lua):	(buff)->buffsize = size)
Lzo.c (components\external\lzo):#define HEAP_ALLOC(var,size) \
Lzo.c (components\external\lzo):    lzo_align_t __LZO_MMODEL var [ ((size) + (sizeof(lzo_align_t) - 1)) / sizeof(lzo_align_t) ]
Lzoconf.h (components\external\lzo):    (lzo_callback_p self, lzo_uint items, lzo_uint size);
Lzoconf.h (components\external\lzo):/* align a char pointer on a boundary that is a multiple of 'size' */
Lzoconf.h (components\external\lzo):LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp p, lzo_uint size);
Lzoconf.h (components\external\lzo):#define LZO_PTR_ALIGN_UP(p,size) \
Lzoconf.h (components\external\lzo):    ((p) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(p),(lzo_uint)(size)))
Main.c (components\external\sqlite-3.8.1\src):        /* cap min request size at 2^12 */
Main.c (components\external\sqlite-3.8.1\src):  /* The size of a lookaside slot after ROUNDDOWN8 needs to be larger
Main.c (components\external\sqlite-3.8.1\src):    **  sqlite3_test_control(BITVEC_TEST, size, program)
Main.c (components\external\sqlite-3.8.1\src):    ** Run a test against a Bitvec object of size.  The program argument
Main.c (components\external\sqlite-3.8.1\src):    ** Set the nReserve size to N for the main database on the database
Main.html (components\net\uip\doc\html):The uIP TCP/IP stack is intended to make it possible to communicate using the TCP/IP protocol suite even on small 8-bit micro-controllers. Despite being small and simple, uIP do not require their peers to have complex, full-size stacks, but can communicate with peers running a similarly light-weight stack. The code size is on the order of a few kilobytes and RAM usage can be configured to be as low as a few hundred bytes.<p>
Main.html (components\net\uip\doc\html):Traditional TCP/IP implementations have required far too much resources both in terms of code size and memory usage to be useful in small 8 or 16-bit systems. Code size of a few hundred kilobytes and RAM requirements of several hundreds of kilobytes have made it impossible to fit the full TCP/IP stack into systems with a few tens of kilobytes of RAM and room for less than 100 kilobytes of code.<p>
Main.html (components\net\uip\doc\html):TCP provides a reliable byte stream to the upper layer protocols. It breaks the byte stream into appropriately sized segments and each segment is sent in its own IP packet. The IP packets are sent out on the network by the network device driver. If the destination is not on the physically connected network, the IP packet is forwarded onto another network by a router that is situated between the two networks. If the maximum packet size of the other network is smaller than the size of the IP packet, the packet is fragmented into smaller packets by the router. If possible, the size of the TCP segments are chosen so that fragmentation is minimized. The final recipient of the packet will have to reassemble any fragmented IP packets before they can be passed to higher layers.<p>
Main.html (components\net\uip\doc\html):In uIP, all RFC requirements that affect host-to-host communication are implemented. However, in order to reduce code size, we have removed certain mechanisms in the interface between the application and the stack, such as the soft error reporting mechanism and dynamically configurable type-of-service bits for TCP connections. Since there are only very few applications that make use of those features they can be removed without loss of generality.<h2><a class="anchor" name="mainloop">
Main.html (components\net\uip\doc\html):The uIP stack does not use explicit dynamic memory allocation. Instead, it uses a single global buffer for holding packets and has a fixed table for holding connection state. The global packet buffer is large enough to contain one packet of maximum size. When a packet arrives from the network, the device driver places it in the global buffer and calls the TCP/IP stack. If the packet contains data, the TCP/IP stack will notify the corresponding application. Because the data in the buffer will be overwritten by the next incoming packet, the application will either have to act immediately on the data or copy the data into a secondary buffer for later processing. The packet buffer will not be overwritten by new packets before the application has processed the data. Packets that arrive when the application is processing the data must be queued, either by the network device or by the device driver. Most single-chip Ethernet controllers have on-chip buffers that are large enough to contain at least 4 maximum sized Ethernet frames. Devices that are handled by the processor, such as RS-232 ports, can copy incoming bytes to a separate buffer during application processing. If the buffers are full, the incoming packet is dropped. This will cause performance degradation, but only when multiple connections are running in parallel. This is because uIP advertises a very small receiver window, which means that only a single TCP segment will be in the network per connection.<p>
Main.html (components\net\uip\doc\html):If the uIP test function <a class="el" href="a00147.html#g26a14b8dae3f861830af9e7cf1e03725">uip_newdata()</a> is non-zero, the remote host of the connection has sent new data. The uip_appdata pointer point to the actual data. The size of the data is obtained through the uIP function <a class="el" href="a00147.html#g1a1bc437c09ddef238abab41d77c3177">uip_datalen()</a>. The data is not buffered by uIP, but will be overwritten after the application function returns, and the application will therefor have to either act directly on the incoming data, or by itself copy the incoming data into a buffer for later processing.<h4><a class="anchor" name="senddata">
Main.html (components\net\uip\doc\html):The application state consists of a pointer to the data that should be sent and the size of the data that is left to send. When a remote host connects to the application, the local port number is used to determine which file to send. The first chunk of data is sent using <a class="el" href="a00147.html#g04b053a623aac7cd4195157d470661b3">uip_send()</a>. uIP makes sure that no more than MSS bytes of data is actually sent, even though s-&gt;dataleft may be larger than the MSS.<p>
Main.html (components\net\uip\doc\html):Thus the maximum throughput equation when sending data from uIP will be $p = s / (t + t_d)$ where $s$ is the segment size and $t_d$ is the delayed acknowledgment timeout, which typically is between 200 and 500 ms. With a segment size of 1000 bytes, a round-trip time of 40 ms and a delayed acknowledgment timeout of 200 ms, the maximum throughput will be 4166 bytes per second. With the delayed acknowledgment algorithm disabled at the receiver, the maximum throughput would be 25000 bytes per second.<p>
Main.html (components\net\uip\doc\html):The maximum throughput when uIP acts as a receiver is not affected by the delayed acknowledgment throughput degradation. <hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:01 2006 for uIP 1.0 by&nbsp;
MainTask.c (components\emwin\emwintask):  // Get display size
MakeMovie.bat (components\emwin1\software\jpeg2moviescripts):*              with a size postfix and the extension '.emf' (emWin movie file).
Malloc.c (components\external\sqlite-3.8.1\src):** Set the soft heap-size limit for the library. Passing a zero or 
Malloc.c (components\external\sqlite-3.8.1\src):    ** xMalloc().  Hence we limit the maximum size to 0x7fffff00, giving
Malloc.c (components\external\sqlite-3.8.1\src):** Return the size of a memory allocation previously obtained from
Malloc.c (components\external\sqlite-3.8.1\src):** Change the size of an existing memory allocation
Mbascii.c (components\net\freemodbus\modbus\ascii):#define MB_SER_PDU_SIZE_MIN     3       /*!< Minimum size of a Modbus ASCII frame. */
Mbascii.c (components\net\freemodbus\modbus\ascii):#define MB_SER_PDU_SIZE_MAX     256     /*!< Maximum size of a Modbus ASCII frame. */
Mbascii.c (components\net\freemodbus\modbus\ascii):         * size of address field and CRC checksum.
Mbconfig.h (components\net\freemodbus\modbus\include): * This number limits the maximum size of the additional segment in the
Mbframe.h (components\net\freemodbus\modbus\include):#define MB_PDU_SIZE_MAX     253 /*!< Maximum size of a PDU. */
Mbrtu.c (components\net\freemodbus\modbus\rtu):#define MB_SER_PDU_SIZE_MIN     4       /*!< Minimum size of a Modbus RTU frame. */
Mbrtu.c (components\net\freemodbus\modbus\rtu):#define MB_SER_PDU_SIZE_MAX     256     /*!< Maximum size of a Modbus RTU frame. */
Mbrtu.c (components\net\freemodbus\modbus\rtu):         * size of address field and CRC checksum.
Mbrtu_m.c (components\net\freemodbus\modbus\rtu):#define MB_SER_PDU_SIZE_MIN     4       /*!< Minimum size of a Modbus RTU frame. */
Mbrtu_m.c (components\net\freemodbus\modbus\rtu):#define MB_SER_PDU_SIZE_MAX     256     /*!< Maximum size of a Modbus RTU frame. */
Mbrtu_m.c (components\net\freemodbus\modbus\rtu):         * size of address field and CRC checksum.
Mbtcp.c (components\net\freemodbus\modbus\tcp):     * header includes the size of the Modbus PDU and the UID Byte. Therefore 
Mbutils.h (components\net\freemodbus\modbus\include): *   usBitOffset / 8 is greater than the size of the buffer memory contents
Md5.c (components\external\freetype\src\base): * optimizations are not included to reduce source code size and avoid
Md5.c (components\external\freetype\src\base):static const void *body(MD5_CTX *ctx, const void *data, unsigned long size)
Md5.c (components\external\freetype\src\base):	} while (size -= 64);
Md5.c (components\external\freetype\src\base):void MD5_Update(MD5_CTX *ctx, const void *data, unsigned long size)
Md5.c (components\external\freetype\src\base):	if ((ctx->lo = (saved_lo + size) & 0x1fffffff) < saved_lo)
Md5.c (components\external\freetype\src\base):	ctx->hi += size >> 29;
Md5.c (components\external\freetype\src\base):		if (size < available) {
Md5.c (components\external\freetype\src\base):			memcpy(&ctx->buffer[used], data, size);
Md5.c (components\external\freetype\src\base):		size -= available;
Md5.c (components\external\freetype\src\base):	if (size >= 64) {
Md5.c (components\external\freetype\src\base):		data = body(ctx, data, size & ~(unsigned long)0x3f);
Md5.c (components\external\freetype\src\base):		size &= 0x3f;
Md5.c (components\external\freetype\src\base):	memcpy(ctx->buffer, data, size);
Md5.h (components\external\freetype\src\base):extern void MD5_Update(MD5_CTX *ctx, const void *data, unsigned long size);
Mem.c (components\net\lwip-1.3.2\src\core): * to contain an element of 'size' and get an element from that pool.
Mem.c (components\net\lwip-1.3.2\src\core): * @param size the size in bytes of the memory needed
Mem.c (components\net\lwip-1.3.2\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip-1.3.2\src\core):  mem_size_t required_size = size + sizeof(struct memp_malloc_helper);
Mem.c (components\net\lwip-1.3.2\src\core):    /* is this pool big enough to hold an element of the required size
Mem.c (components\net\lwip-1.3.2\src\core): * This does not have to be aligned since for getting its size,
Mem.c (components\net\lwip-1.3.2\src\core): * @param newsize required size after shrinking (needs to be smaller than or
Mem.c (components\net\lwip-1.3.2\src\core): *                equal to the previous size)
Mem.c (components\net\lwip-1.3.2\src\core): *         or NULL if newsize is > old size, in which case rmem is NOT touched
Mem.c (components\net\lwip-1.3.2\src\core):  mem_size_t size;
Mem.c (components\net\lwip-1.3.2\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip-1.3.2\src\core):  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
Mem.c (components\net\lwip-1.3.2\src\core):  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
Mem.c (components\net\lwip-1.3.2\src\core):  if (newsize > size) {
Mem.c (components\net\lwip-1.3.2\src\core):  if (newsize == size) {
Mem.c (components\net\lwip-1.3.2\src\core):    /* No change in size, simply return */
Mem.c (components\net\lwip-1.3.2\src\core):  MEM_STATS_DEC_USED(used, (size - newsize));
Mem.c (components\net\lwip-1.3.2\src\core):  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
Mem.c (components\net\lwip-1.3.2\src\core):     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
Mem.c (components\net\lwip-1.3.2\src\core):    next struct mem is used but size between mem and mem2 is not big enough
Mem.c (components\net\lwip-1.3.2\src\core): * Allocate a block of memory with a minimum of 'size' bytes.
Mem.c (components\net\lwip-1.3.2\src\core): * @param size is the minimum size of the requested block in bytes.
Mem.c (components\net\lwip-1.3.2\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip-1.3.2\src\core):  if (size == 0) {
Mem.c (components\net\lwip-1.3.2\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip-1.3.2\src\core):  size = LWIP_MEM_ALIGN_SIZE(size);
Mem.c (components\net\lwip-1.3.2\src\core):  if(size < MIN_SIZE_ALIGNED) {
Mem.c (components\net\lwip-1.3.2\src\core):    size = MIN_SIZE_ALIGNED;
Mem.c (components\net\lwip-1.3.2\src\core):  if (size > MEM_SIZE_ALIGNED) {
Mem.c (components\net\lwip-1.3.2\src\core):    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
Mem.c (components\net\lwip-1.3.2\src\core):          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
Mem.c (components\net\lwip-1.3.2\src\core):         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
Mem.c (components\net\lwip-1.3.2\src\core):        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
Mem.c (components\net\lwip-1.3.2\src\core):           * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
Mem.c (components\net\lwip-1.3.2\src\core):          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
Mem.c (components\net\lwip-1.3.2\src\core):          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
Mem.c (components\net\lwip-1.3.2\src\core):         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
Mem.c (components\net\lwip-1.3.2\src\core):  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
Mem.c (components\net\lwip-1.3.2\src\core): * Contiguously allocates enough space for count objects that are size bytes
Mem.c (components\net\lwip-1.3.2\src\core): * @param size size of the objects to allocate
Mem.c (components\net\lwip-1.3.2\src\core):void *mem_calloc(mem_size_t count, mem_size_t size)
Mem.c (components\net\lwip-1.3.2\src\core):  /* allocate 'count' objects of size 'size' */
Mem.c (components\net\lwip-1.3.2\src\core):  p = mem_malloc(count * size);
Mem.c (components\net\lwip-1.3.2\src\core):    memset(p, 0, count * size);
Mem.c (components\net\lwip-1.4.1\src\core): * to contain an element of 'size' and get an element from that pool.
Mem.c (components\net\lwip-1.4.1\src\core): * @param size the size in bytes of the memory needed
Mem.c (components\net\lwip-1.4.1\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip-1.4.1\src\core):  mem_size_t required_size = size + LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_malloc_helper));
Mem.c (components\net\lwip-1.4.1\src\core):    /* is this pool big enough to hold an element of the required size
Mem.c (components\net\lwip-1.4.1\src\core): * This does not have to be aligned since for getting its size,
Mem.c (components\net\lwip-1.4.1\src\core): * @param newsize required size after shrinking (needs to be smaller than or
Mem.c (components\net\lwip-1.4.1\src\core): *                equal to the previous size)
Mem.c (components\net\lwip-1.4.1\src\core): *         or NULL if newsize is > old size, in which case rmem is NOT touched
Mem.c (components\net\lwip-1.4.1\src\core):  mem_size_t size;
Mem.c (components\net\lwip-1.4.1\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip-1.4.1\src\core):  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
Mem.c (components\net\lwip-1.4.1\src\core):  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
Mem.c (components\net\lwip-1.4.1\src\core):  if (newsize > size) {
Mem.c (components\net\lwip-1.4.1\src\core):  if (newsize == size) {
Mem.c (components\net\lwip-1.4.1\src\core):    /* No change in size, simply return */
Mem.c (components\net\lwip-1.4.1\src\core):    MEM_STATS_DEC_USED(used, (size - newsize));
Mem.c (components\net\lwip-1.4.1\src\core):  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
Mem.c (components\net\lwip-1.4.1\src\core):     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
Mem.c (components\net\lwip-1.4.1\src\core):    MEM_STATS_DEC_USED(used, (size - newsize));
Mem.c (components\net\lwip-1.4.1\src\core):    next struct mem is used but size between mem and mem2 is not big enough
Mem.c (components\net\lwip-1.4.1\src\core): * Allocate a block of memory with a minimum of 'size' bytes.
Mem.c (components\net\lwip-1.4.1\src\core): * @param size is the minimum size of the requested block in bytes.
Mem.c (components\net\lwip-1.4.1\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip-1.4.1\src\core):  if (size == 0) {
Mem.c (components\net\lwip-1.4.1\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip-1.4.1\src\core):  size = LWIP_MEM_ALIGN_SIZE(size);
Mem.c (components\net\lwip-1.4.1\src\core):  if(size < MIN_SIZE_ALIGNED) {
Mem.c (components\net\lwip-1.4.1\src\core):    size = MIN_SIZE_ALIGNED;
Mem.c (components\net\lwip-1.4.1\src\core):  if (size > MEM_SIZE_ALIGNED) {
Mem.c (components\net\lwip-1.4.1\src\core):    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
Mem.c (components\net\lwip-1.4.1\src\core):          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
Mem.c (components\net\lwip-1.4.1\src\core):         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
Mem.c (components\net\lwip-1.4.1\src\core):        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
Mem.c (components\net\lwip-1.4.1\src\core):           * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
Mem.c (components\net\lwip-1.4.1\src\core):          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
Mem.c (components\net\lwip-1.4.1\src\core):          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
Mem.c (components\net\lwip-1.4.1\src\core):         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
Mem.c (components\net\lwip-1.4.1\src\core):  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
Mem.c (components\net\lwip-1.4.1\src\core): * Contiguously allocates enough space for count objects that are size bytes
Mem.c (components\net\lwip-1.4.1\src\core): * @param size size of the objects to allocate
Mem.c (components\net\lwip-1.4.1\src\core):void *mem_calloc(mem_size_t count, mem_size_t size)
Mem.c (components\net\lwip-1.4.1\src\core):  /* allocate 'count' objects of size 'size' */
Mem.c (components\net\lwip-1.4.1\src\core):  p = mem_malloc(count * size);
Mem.c (components\net\lwip-1.4.1\src\core):    memset(p, 0, count * size);
Mem.c (components\net\lwip-head\src\core): * to contain an element of 'size' and get an element from that pool.
Mem.c (components\net\lwip-head\src\core): * @param size the size in bytes of the memory needed
Mem.c (components\net\lwip-head\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip-head\src\core):  mem_size_t required_size = size + LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_malloc_helper));
Mem.c (components\net\lwip-head\src\core):    /* is this pool big enough to hold an element of the required size
Mem.c (components\net\lwip-head\src\core): * This does not have to be aligned since for getting its size,
Mem.c (components\net\lwip-head\src\core): * @param newsize required size after shrinking (needs to be smaller than or
Mem.c (components\net\lwip-head\src\core): *                equal to the previous size)
Mem.c (components\net\lwip-head\src\core): *         or NULL if newsize is > old size, in which case rmem is NOT touched
Mem.c (components\net\lwip-head\src\core):  mem_size_t size;
Mem.c (components\net\lwip-head\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip-head\src\core):  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
Mem.c (components\net\lwip-head\src\core):  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
Mem.c (components\net\lwip-head\src\core):  if (newsize > size) {
Mem.c (components\net\lwip-head\src\core):  if (newsize == size) {
Mem.c (components\net\lwip-head\src\core):    /* No change in size, simply return */
Mem.c (components\net\lwip-head\src\core):    MEM_STATS_DEC_USED(used, (size - newsize));
Mem.c (components\net\lwip-head\src\core):  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
Mem.c (components\net\lwip-head\src\core):     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
Mem.c (components\net\lwip-head\src\core):    MEM_STATS_DEC_USED(used, (size - newsize));
Mem.c (components\net\lwip-head\src\core):    next struct mem is used but size between mem and mem2 is not big enough
Mem.c (components\net\lwip-head\src\core): * Allocate a block of memory with a minimum of 'size' bytes.
Mem.c (components\net\lwip-head\src\core): * @param size is the minimum size of the requested block in bytes.
Mem.c (components\net\lwip-head\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip-head\src\core):  if (size == 0) {
Mem.c (components\net\lwip-head\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip-head\src\core):  size = LWIP_MEM_ALIGN_SIZE(size);
Mem.c (components\net\lwip-head\src\core):  if(size < MIN_SIZE_ALIGNED) {
Mem.c (components\net\lwip-head\src\core):    size = MIN_SIZE_ALIGNED;
Mem.c (components\net\lwip-head\src\core):  if (size > MEM_SIZE_ALIGNED) {
Mem.c (components\net\lwip-head\src\core):    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
Mem.c (components\net\lwip-head\src\core):          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
Mem.c (components\net\lwip-head\src\core):         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
Mem.c (components\net\lwip-head\src\core):        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
Mem.c (components\net\lwip-head\src\core):           * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
Mem.c (components\net\lwip-head\src\core):          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
Mem.c (components\net\lwip-head\src\core):          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
Mem.c (components\net\lwip-head\src\core):         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
Mem.c (components\net\lwip-head\src\core):  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
Mem.c (components\net\lwip-head\src\core): * Contiguously allocates enough space for count objects that are size bytes
Mem.c (components\net\lwip-head\src\core): * @param size size of the objects to allocate
Mem.c (components\net\lwip-head\src\core):void *mem_calloc(mem_size_t count, mem_size_t size)
Mem.c (components\net\lwip-head\src\core):  /* allocate 'count' objects of size 'size' */
Mem.c (components\net\lwip-head\src\core):  p = mem_malloc(count * size);
Mem.c (components\net\lwip-head\src\core):    memset(p, 0, count * size);
Mem.c (components\net\lwip\src\core): * to contain an element of 'size' and get an element from that pool.
Mem.c (components\net\lwip\src\core): * @param size the size in bytes of the memory needed
Mem.c (components\net\lwip\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip\src\core):  mem_size_t required_size = size + sizeof(struct memp_malloc_helper);
Mem.c (components\net\lwip\src\core):    /* is this pool big enough to hold an element of the required size
Mem.c (components\net\lwip\src\core): * This does not have to be aligned since for getting its size,
Mem.c (components\net\lwip\src\core): * @param newsize required size after shrinking (needs to be smaller than or
Mem.c (components\net\lwip\src\core): *                equal to the previous size)
Mem.c (components\net\lwip\src\core): *         or NULL if newsize is > old size, in which case rmem is NOT touched
Mem.c (components\net\lwip\src\core):  mem_size_t size;
Mem.c (components\net\lwip\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip\src\core):  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
Mem.c (components\net\lwip\src\core):  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
Mem.c (components\net\lwip\src\core):  if (newsize > size) {
Mem.c (components\net\lwip\src\core):  if (newsize == size) {
Mem.c (components\net\lwip\src\core):    /* No change in size, simply return */
Mem.c (components\net\lwip\src\core):    MEM_STATS_DEC_USED(used, (size - newsize));
Mem.c (components\net\lwip\src\core):  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
Mem.c (components\net\lwip\src\core):     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
Mem.c (components\net\lwip\src\core):    MEM_STATS_DEC_USED(used, (size - newsize));
Mem.c (components\net\lwip\src\core):    next struct mem is used but size between mem and mem2 is not big enough
Mem.c (components\net\lwip\src\core): * Allocate a block of memory with a minimum of 'size' bytes.
Mem.c (components\net\lwip\src\core): * @param size is the minimum size of the requested block in bytes.
Mem.c (components\net\lwip\src\core):mem_malloc(mem_size_t size)
Mem.c (components\net\lwip\src\core):  if (size == 0) {
Mem.c (components\net\lwip\src\core):  /* Expand the size of the allocated memory region so that we can
Mem.c (components\net\lwip\src\core):  size = LWIP_MEM_ALIGN_SIZE(size);
Mem.c (components\net\lwip\src\core):  if(size < MIN_SIZE_ALIGNED) {
Mem.c (components\net\lwip\src\core):    size = MIN_SIZE_ALIGNED;
Mem.c (components\net\lwip\src\core):  if (size > MEM_SIZE_ALIGNED) {
Mem.c (components\net\lwip\src\core):    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
Mem.c (components\net\lwip\src\core):          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
Mem.c (components\net\lwip\src\core):         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
Mem.c (components\net\lwip\src\core):        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
Mem.c (components\net\lwip\src\core):           * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
Mem.c (components\net\lwip\src\core):          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
Mem.c (components\net\lwip\src\core):          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
Mem.c (components\net\lwip\src\core):         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
Mem.c (components\net\lwip\src\core):  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
Mem.c (components\net\lwip\src\core): * Contiguously allocates enough space for count objects that are size bytes
Mem.c (components\net\lwip\src\core): * @param size size of the objects to allocate
Mem.c (components\net\lwip\src\core):void *mem_calloc(mem_size_t count, mem_size_t size)
Mem.c (components\net\lwip\src\core):  /* allocate 'count' objects of size 'size' */
Mem.c (components\net\lwip\src\core):  p = mem_malloc(count * size);
Mem.c (components\net\lwip\src\core):    memset(p, 0, count * size);
Mem.c (src):static void (*rt_malloc_hook)(void *ptr, rt_size_t size);
Mem.c (src):void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
Mem.c (src):        /* calculate the aligned memory size */
Mem.c (src):    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
Mem.c (src): * Allocate a block of memory with a minimum of 'size' bytes.
Mem.c (src): * @param size is the minimum size of the requested block in bytes.
Mem.c (src):void *rt_malloc(rt_size_t size)
Mem.c (src):    if (size == 0)
Mem.c (src):    if (size != RT_ALIGN(size, RT_ALIGN_SIZE))
Mem.c (src):        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d, but align to %d\n",
Mem.c (src):                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
Mem.c (src):        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));
Mem.c (src):    /* alignment size */
Mem.c (src):    size = RT_ALIGN(size, RT_ALIGN_SIZE);
Mem.c (src):    if (size > mem_size_aligned)
Mem.c (src):    if (size < MIN_SIZE_ALIGNED)
Mem.c (src):        size = MIN_SIZE_ALIGNED;
Mem.c (src):         ptr < mem_size_aligned - size;
Mem.c (src):        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
Mem.c (src):             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
Mem.c (src):                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
Mem.c (src):                 * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
Mem.c (src):                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
Mem.c (src):                used_mem += (size + SIZEOF_STRUCT_MEM);
Mem.c (src):            RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
Mem.c (src):                         ("allocate memory at 0x%x, size: %d\n",
Mem.c (src):                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));
Mem.c (src): * @param newsize the required new size
Mem.c (src):    rt_size_t size;
Mem.c (src):    /* alignment size */
Mem.c (src):    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
Mem.c (src):    if (size == newsize)
Mem.c (src):        /* the size is the same as */
Mem.c (src):    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
Mem.c (src):        used_mem -= (size - newsize);
Mem.c (src):        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
Mem.c (src): * that are size bytes of memory each and returns a pointer to the allocated
Mem.c (src): * @param size size of the objects to allocate
Mem.c (src):void *rt_calloc(rt_size_t count, rt_size_t size)
Mem.c (src):    /* allocate 'count' objects of size 'size' */
Mem.c (src):    p = rt_malloc(count * size);
Mem.c (src):        rt_memset(p, 0, count * size);
Mem.c (src):                 ("release memory 0x%x, size: %d\n",
Mem.h (components\net\lwip-1.3.2\src\include\lwip):static void *mem_realloc(void *mem, mem_size_t size)
Mem.h (components\net\lwip-1.3.2\src\include\lwip):  LWIP_UNUSED_ARG(size);
Mem.h (components\net\lwip-1.3.2\src\include\lwip):#define mem_realloc(mem, size) (mem)
Mem.h (components\net\lwip-1.3.2\src\include\lwip):void *mem_realloc(void *mem, mem_size_t size);
Mem.h (components\net\lwip-1.3.2\src\include\lwip):void *mem_malloc(mem_size_t size);
Mem.h (components\net\lwip-1.3.2\src\include\lwip):void *mem_calloc(mem_size_t count, mem_size_t size);
Mem.h (components\net\lwip-1.3.2\src\include\lwip):#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
Mem.h (components\net\lwip-1.4.1\src\include\lwip):#define mem_trim(mem, size) (mem)
Mem.h (components\net\lwip-1.4.1\src\include\lwip):#define mem_trim(mem, size) (mem)
Mem.h (components\net\lwip-1.4.1\src\include\lwip):void *mem_trim(void *mem, mem_size_t size);
Mem.h (components\net\lwip-1.4.1\src\include\lwip):void *mem_malloc(mem_size_t size);
Mem.h (components\net\lwip-1.4.1\src\include\lwip):void *mem_calloc(mem_size_t count, mem_size_t size);
Mem.h (components\net\lwip-1.4.1\src\include\lwip):/** Calculate memory size for an aligned buffer - returns the next highest
Mem.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
Mem.h (components\net\lwip-1.4.1\src\include\lwip):/** Calculate safe memory size for an aligned buffer when using an unaligned
Mem.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MEM_ALIGN_BUFFER(size) (((size) + MEM_ALIGNMENT - 1))
Mem.h (components\net\lwip-head\src\include\lwip):#define mem_trim(mem, size) (mem)
Mem.h (components\net\lwip-head\src\include\lwip):#define mem_trim(mem, size) (mem)
Mem.h (components\net\lwip-head\src\include\lwip):void *mem_trim(void *mem, mem_size_t size);
Mem.h (components\net\lwip-head\src\include\lwip):void *mem_malloc(mem_size_t size);
Mem.h (components\net\lwip-head\src\include\lwip):void *mem_calloc(mem_size_t count, mem_size_t size);
Mem.h (components\net\lwip-head\src\include\lwip):/** Calculate memory size for an aligned buffer - returns the next highest
Mem.h (components\net\lwip-head\src\include\lwip):#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
Mem.h (components\net\lwip-head\src\include\lwip):/** Calculate safe memory size for an aligned buffer when using an unaligned
Mem.h (components\net\lwip-head\src\include\lwip):#define LWIP_MEM_ALIGN_BUFFER(size) (((size) + MEM_ALIGNMENT - 1))
Mem.h (components\net\lwip\src\include\lwip):#define mem_trim(mem, size) (mem)
Mem.h (components\net\lwip\src\include\lwip):#define mem_trim(mem, size) (mem)
Mem.h (components\net\lwip\src\include\lwip):void *mem_trim(void *mem, mem_size_t size);
Mem.h (components\net\lwip\src\include\lwip):void *mem_malloc(mem_size_t size);
Mem.h (components\net\lwip\src\include\lwip):void *mem_calloc(mem_size_t count, mem_size_t size);
Mem.h (components\net\lwip\src\include\lwip):/** Calculate memory size for an aligned buffer - returns the next highest
Mem.h (components\net\lwip\src\include\lwip):#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
Mem.h (components\net\lwip\src\include\lwip):/** Calculate safe memory size for an aligned buffer when using an unaligned
Mem.h (components\net\lwip\src\include\lwip):#define LWIP_MEM_ALIGN_BUFFER(size) (((size) + MEM_ALIGNMENT - 1))
Mem1.c (components\external\sqlite-3.8.1\src):        (_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,x) : malloc_size(x))
Mem1.c (components\external\sqlite-3.8.1\src):** Like malloc(), but remember the size of the allocation
Mem1.c (components\external\sqlite-3.8.1\src):** Report the allocated size of a prior return from xMalloc()
Mem1.c (components\external\sqlite-3.8.1\src):** Round up a request size to the next valid allocation size.
Mem2.c (components\external\sqlite-3.8.1\src):** MemBlockHdr tells us the size of the allocation and the number of
Mem2.c (components\external\sqlite-3.8.1\src):** Number of malloc size increments to track.
Mem2.c (components\external\sqlite-3.8.1\src):** Round up a request size to the next valid allocation size.
Mem2.c (components\external\sqlite-3.8.1\src):** Change the size of an existing memory allocation.
Mem3.c (components\external\sqlite-3.8.1\src):** Maximum size (in Mem3Blocks) of a "small" chunk.
Mem3.c (components\external\sqlite-3.8.1\src):** size of the allocation in blocks if the allocation is free.
Mem3.c (components\external\sqlite-3.8.1\src):** previous chunk is free.  The u.hdr.prevSize field is the size of
Mem3.c (components\external\sqlite-3.8.1\src):      u32 size4x;     /* 4x the size of current chunk in Mem3Block elements */
Mem3.c (components\external\sqlite-3.8.1\src):  ** Memory available for allocation. nPool is the size of the array
Mem3.c (components\external\sqlite-3.8.1\src):  ** occur off of this chunk.  szMaster is the size (in Mem3Blocks)
Mem3.c (components\external\sqlite-3.8.1\src):  ** Array of lists of free blocks according to the block size 
Mem3.c (components\external\sqlite-3.8.1\src):  ** for smaller chunks, or a hash on the block size for larger
Mem3.c (components\external\sqlite-3.8.1\src):  u32 size, hash;
Mem3.c (components\external\sqlite-3.8.1\src):  size = mem3.aPool[i-1].u.hdr.size4x/4;
Mem3.c (components\external\sqlite-3.8.1\src):  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );
Mem3.c (components\external\sqlite-3.8.1\src):  assert( size>=2 );
Mem3.c (components\external\sqlite-3.8.1\src):  if( size <= MX_SMALL ){
Mem3.c (components\external\sqlite-3.8.1\src):    memsys3UnlinkFromList(i, &mem3.aiSmall[size-2]);
Mem3.c (components\external\sqlite-3.8.1\src):    hash = size % N_HASH;
Mem3.c (components\external\sqlite-3.8.1\src):  u32 size, hash;
Mem3.c (components\external\sqlite-3.8.1\src):  size = mem3.aPool[i-1].u.hdr.size4x/4;
Mem3.c (components\external\sqlite-3.8.1\src):  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );
Mem3.c (components\external\sqlite-3.8.1\src):  assert( size>=2 );
Mem3.c (components\external\sqlite-3.8.1\src):  if( size <= MX_SMALL ){
Mem3.c (components\external\sqlite-3.8.1\src):    memsys3LinkIntoList(i, &mem3.aiSmall[size-2]);
Mem3.c (components\external\sqlite-3.8.1\src):    hash = size % N_HASH;
Mem3.c (components\external\sqlite-3.8.1\src):** size parameters for check-out and return a pointer to the 
Mem3.c (components\external\sqlite-3.8.1\src):** *pRoot is the head of a list of free chunks of the same size
Mem3.c (components\external\sqlite-3.8.1\src):** or same size hash.  In other words, *pRoot is an entry in either
Mem3.c (components\external\sqlite-3.8.1\src):  u32 iNext, prev, size, i, x;
Mem3.c (components\external\sqlite-3.8.1\src):    size = mem3.aPool[i-1].u.hdr.size4x;
Mem3.c (components\external\sqlite-3.8.1\src):    assert( (size&1)==0 );
Mem3.c (components\external\sqlite-3.8.1\src):    if( (size&2)==0 ){
Mem3.c (components\external\sqlite-3.8.1\src):      size = i + size/4 - prev;
Mem3.c (components\external\sqlite-3.8.1\src):      mem3.aPool[prev-1].u.hdr.size4x = size*4 | x;
Mem3.c (components\external\sqlite-3.8.1\src):      mem3.aPool[prev+size-1].u.hdr.prevSize = size;
Mem3.c (components\external\sqlite-3.8.1\src):      size /= 4;
Mem3.c (components\external\sqlite-3.8.1\src):    if( size>mem3.szMaster ){
Mem3.c (components\external\sqlite-3.8.1\src):      mem3.szMaster = size;
Mem3.c (components\external\sqlite-3.8.1\src):** Return a block of memory of at least nBytes in size.
Mem3.c (components\external\sqlite-3.8.1\src):  ** Look for an entry of the correct size in either the small
Mem3.c (components\external\sqlite-3.8.1\src):  u32 size, x;
Mem3.c (components\external\sqlite-3.8.1\src):  size = mem3.aPool[i-1].u.hdr.size4x/4;
Mem3.c (components\external\sqlite-3.8.1\src):  assert( i+size<=mem3.nPool+1 );
Mem3.c (components\external\sqlite-3.8.1\src):  mem3.aPool[i+size-1].u.hdr.prevSize = size;
Mem3.c (components\external\sqlite-3.8.1\src):  mem3.aPool[i+size-1].u.hdr.size4x &= ~2;
Mem3.c (components\external\sqlite-3.8.1\src):      size = mem3.aPool[mem3.iMaster-1].u.hdr.prevSize;
Mem3.c (components\external\sqlite-3.8.1\src):      mem3.iMaster -= size;
Mem3.c (components\external\sqlite-3.8.1\src):      mem3.szMaster += size;
Mem3.c (components\external\sqlite-3.8.1\src):** Return the size of an outstanding allocation, in bytes.  The
Mem3.c (components\external\sqlite-3.8.1\src):** size returned omits the 8-byte header overhead.  This only
Mem3.c (components\external\sqlite-3.8.1\src):** Round up a request size to the next valid allocation size.
Mem3.c (components\external\sqlite-3.8.1\src):** Change the size of an existing memory allocation
Mem3.c (components\external\sqlite-3.8.1\src):  u32 size;
Mem3.c (components\external\sqlite-3.8.1\src):  for(i=1; i<=mem3.nPool; i+=size/4){
Mem3.c (components\external\sqlite-3.8.1\src):    size = mem3.aPool[i-1].u.hdr.size4x;
Mem3.c (components\external\sqlite-3.8.1\src):    if( size/4<=1 ){
Mem3.c (components\external\sqlite-3.8.1\src):      fprintf(out, "%p size error\n", &mem3.aPool[i]);
Mem3.c (components\external\sqlite-3.8.1\src):    if( (size&1)==0 && mem3.aPool[i+size/4-1].u.hdr.prevSize!=size/4 ){
Mem3.c (components\external\sqlite-3.8.1\src):      fprintf(out, "%p tail size does not match\n", &mem3.aPool[i]);
Mem3.c (components\external\sqlite-3.8.1\src):    if( ((mem3.aPool[i+size/4-1].u.hdr.size4x&2)>>1)!=(size&1) ){
Mem3.c (components\external\sqlite-3.8.1\src):    if( size&1 ){
Mem3.c (components\external\sqlite-3.8.1\src):      fprintf(out, "%p %6d bytes checked out\n", &mem3.aPool[i], (size/4)*8-8);
Mem3.c (components\external\sqlite-3.8.1\src):      fprintf(out, "%p %6d bytes free%s\n", &mem3.aPool[i], (size/4)*8-8,
Mem5.c (components\external\sqlite-3.8.1\src):** Let n be the size of the largest allocation divided by the minimum
Mem5.c (components\external\sqlite-3.8.1\src):** allocation size (after rounding all sizes up to a power of 2.)  Let M
Mem5.c (components\external\sqlite-3.8.1\src):** size of the array is a power of 2.
Mem5.c (components\external\sqlite-3.8.1\src):** The size of this object must be a power of two.  That fact is
Mem5.c (components\external\sqlite-3.8.1\src):** Maximum size of any allocation is ((1<<LOGMAX)*mem5.szAtom). Since
Mem5.c (components\external\sqlite-3.8.1\src):  ** size mem5.szAtom.  aiFreelist[1] holds blocks of size szAtom*2.
Mem5.c (components\external\sqlite-3.8.1\src):  ** Space for tracking which blocks are checked out and the size
Mem5.c (components\external\sqlite-3.8.1\src):** Return the size of an outstanding allocation, in bytes.  The
Mem5.c (components\external\sqlite-3.8.1\src):** size returned omits the 8-byte header overhead.  This only
Mem5.c (components\external\sqlite-3.8.1\src):** Return a block of memory of at least nBytes in size.
Mem5.c (components\external\sqlite-3.8.1\src):  /* Abort if the requested allocation size is larger than the largest
Mem5.c (components\external\sqlite-3.8.1\src):  ** two in order to create a new free block of size iLogsize.
Mem5.c (components\external\sqlite-3.8.1\src):  u32 size, iLogsize;
Mem5.c (components\external\sqlite-3.8.1\src):  size = 1<<iLogsize;
Mem5.c (components\external\sqlite-3.8.1\src):  assert( iBlock+size-1<(u32)mem5.nBlock );
Mem5.c (components\external\sqlite-3.8.1\src):  mem5.aCtrl[iBlock+size-1] |= CTRL_FREE;
Mem5.c (components\external\sqlite-3.8.1\src):  assert( mem5.currentOut>=(size*mem5.szAtom) );
Mem5.c (components\external\sqlite-3.8.1\src):  mem5.currentOut -= size*mem5.szAtom;
Mem5.c (components\external\sqlite-3.8.1\src):      iBuddy = iBlock - size;
Mem5.c (components\external\sqlite-3.8.1\src):      iBuddy = iBlock + size;
Mem5.c (components\external\sqlite-3.8.1\src):    size *= 2;
Mem5.c (components\external\sqlite-3.8.1\src):** Change the size of an existing memory allocation.
Mem5.c (components\external\sqlite-3.8.1\src):** Round up a request size to the next valid allocation size.  If
Mem5.c (components\external\sqlite-3.8.1\src):  int nMinLog;       /* Log base 2 of minimum allocation size in bytes */
Mem5.c (components\external\sqlite-3.8.1\src):  /* The size of a Mem5Link object must be a power of two.  Verify that
Mem5.c (components\external\sqlite-3.8.1\src):    fprintf(out, "freelist items of size %d: %d\n", mem5.szAtom << i, n);
Memb.c (components\net\uip\lib):  memset(m->mem, 0, m->size * m->num);
Memb.c (components\net\uip\lib):      return (void *)((char *)m->mem + (i * m->size));
Memb.c (components\net\uip\lib):    ptr2 += m->size;
Memb.h (components\net\uip\lib): * size. A set of memory blocks is statically declared with the
Memb.h (components\net\uip\lib): * declares a C array with a size that matches the specified number of
Memb.h (components\net\uip\lib): * \param size The size of each memory chunk, in bytes.
Memb.h (components\net\uip\lib):  unsigned short size;
Memheap.c (src):                         rt_uint32_t        size)
Memheap.c (src):    memheap->pool_size      = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
Memheap.c (src):                 ("memory heap: start addr 0x%08x, size %d, free list header 0x%08x\n",
Memheap.c (src):                  start_addr, size, &(memheap->free_header)));
Memheap.c (src):void *rt_memheap_alloc(struct rt_memheap *heap, rt_uint32_t size)
Memheap.c (src):    /* align allocated size */
Memheap.c (src):    size = RT_ALIGN(size, RT_ALIGN_SIZE);
Memheap.c (src):    if (size < RT_MEMHEAP_MINIALLOC)
Memheap.c (src):        size = RT_MEMHEAP_MINIALLOC;
Memheap.c (src):                                    size, RT_NAME_MAX, heap->parent.name));
Memheap.c (src):    if (size < heap->available_size)
Memheap.c (src):        while (header_ptr != heap->free_list && free_size < size)
Memheap.c (src):            /* get current freed memory block size */
Memheap.c (src):            if (free_size < size)
Memheap.c (src):        if (free_size >= size)
Memheap.c (src):            if (free_size >= (size + RT_MEMHEAP_SIZE + RT_MEMHEAP_MINIALLOC))
Memheap.c (src):                          (((rt_uint8_t *)header_ptr) + size + RT_MEMHEAP_SIZE);
Memheap.c (src):                                       size -
Memheap.c (src):                /* decrement the entire free size from the available bytes count. */
Memheap.c (src):                         ("alloc mem: memory[0x%08x], heap[0x%08x], size: %d\n",
Memheap.c (src):                          size));
Memheap.c (src):    /* align allocated size */
Memheap.c (src):    /* get memory block header and get the size of memory block */
Memheap.c (src):                /* decrement the entire free size from the available bytes count. */
Memheap.c (src):void *rt_malloc(rt_size_t size)
Memheap.c (src):    ptr = rt_memheap_alloc(&_heap, size);
Memheap.c (src):            ptr = rt_memheap_alloc(heap, size);
Memheap.c (src):            /* get the size of old memory block */
Memheap.c (src):void *rt_calloc(rt_size_t count, rt_size_t size)
Memheap.c (src):    total_size = count * size;
Memjournal.c (components\external\sqlite-3.8.1\src):** The size chosen is a little less than a power of two.  That way,
Memjournal.c (components\external\sqlite-3.8.1\src):** the FileChunk object will have a size that almost exactly fills
Memjournal.c (components\external\sqlite-3.8.1\src):static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){
Memjournal.c (components\external\sqlite-3.8.1\src):  assert(size==0);
Memjournal.c (components\external\sqlite-3.8.1\src):  UNUSED_PARAMETER(size);
Memjournal.c (components\external\sqlite-3.8.1\src):** Query the size of the file in bytes.
Memp.c (components\net\lwip-1.3.2\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  LWIP_MEM_ALIGN_SIZE(size),
Memp.c (components\net\lwip-1.3.2\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (desc),
Memp.c (components\net\lwip-1.3.2\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (num),
Memp.c (components\net\lwip-1.3.2\src\core):#define LWIP_MEMPOOL(name,num,size,desc) + ( (num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size) ) )
Memp.c (components\net\lwip-1.3.2\src\core): * @param memp_size the element size of the pool p comes from
Memp.c (components\net\lwip-1.3.2\src\core):  rt_uint32_t size;
Memp.c (components\net\lwip-1.3.2\src\core):  size = memp_sizes[type];
Memp.c (components\net\lwip-1.3.2\src\core):  LWIP_DEBUGF(MEMP_DEBUG, ("memp malloc %s, size %d, ", memp_desc[type], memp_sizes[type]));
Memp.c (components\net\lwip-1.3.2\src\core):  ptr = mem_malloc(size);
Memp.c (components\net\lwip-1.4.1\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  LWIP_MEM_ALIGN_SIZE(size),
Memp.c (components\net\lwip-1.4.1\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (num),
Memp.c (components\net\lwip-1.4.1\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (desc),
Memp.c (components\net\lwip-1.4.1\src\core):#define LWIP_MEMPOOL(name,num,size,desc) u8_t memp_memory_ ## name ## _base \
Memp.c (components\net\lwip-1.4.1\src\core):  [((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))];   
Memp.c (components\net\lwip-1.4.1\src\core):#define LWIP_MEMPOOL(name,num,size,desc) memp_memory_ ## name ## _base,   
Memp.c (components\net\lwip-1.4.1\src\core):#define LWIP_MEMPOOL(name,num,size,desc) + ( (num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size) ) )
Memp.c (components\net\lwip-1.4.1\src\core):#define LWIP_MEMPOOL(name,num,size,desc) "/"desc,
Memp.c (components\net\lwip-head\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  LWIP_MEM_ALIGN_SIZE(size),
Memp.c (components\net\lwip-head\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (num),
Memp.c (components\net\lwip-head\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (desc),
Memp.c (components\net\lwip-head\src\core):#define LWIP_MEMPOOL(name,num,size,desc) u8_t memp_memory_ ## name ## _base \
Memp.c (components\net\lwip-head\src\core):  [((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))];   
Memp.c (components\net\lwip-head\src\core):#define LWIP_MEMPOOL(name,num,size,desc) memp_memory_ ## name ## _base,   
Memp.c (components\net\lwip-head\src\core):#define LWIP_MEMPOOL(name,num,size,desc) + ( (num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size) ) )
Memp.c (components\net\lwip-head\src\core):#define LWIP_MEMPOOL(name,num,size,desc) "/"desc,
Memp.c (components\net\lwip\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  LWIP_MEM_ALIGN_SIZE(size),
Memp.c (components\net\lwip\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (num),
Memp.c (components\net\lwip\src\core):#define LWIP_MEMPOOL(name,num,size,desc)  (desc),
Memp.c (components\net\lwip\src\core):#define LWIP_MEMPOOL(name,num,size,desc) u8_t memp_memory_ ## name ## _base \
Memp.c (components\net\lwip\src\core):  [((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))];   
Memp.c (components\net\lwip\src\core):#define LWIP_MEMPOOL(name,num,size,desc) memp_memory_ ## name ## _base,   
Memp.c (components\net\lwip\src\core):#define LWIP_MEMPOOL(name,num,size,desc) + ( (num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size) ) )
Memp.c (components\net\lwip\src\core):#define LWIP_MEMPOOL(name,num,size,desc) "/"desc,
Memp.h (components\net\lwip-1.3.2\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
Memp.h (components\net\lwip-1.3.2\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip-1.3.2\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
Memp.h (components\net\lwip-1.3.2\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip-1.3.2\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
Memp.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
Memp.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
Memp.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
Memp.h (components\net\lwip-head\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
Memp.h (components\net\lwip-head\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip-head\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
Memp.h (components\net\lwip-head\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip-head\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
Memp.h (components\net\lwip\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
Memp.h (components\net\lwip\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
Memp.h (components\net\lwip\src\include\lwip):#define LWIP_MEMPOOL(name,num,size,desc)
Memp.h (components\net\lwip\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
Mempool.c (src): * @param size the total size of memory pool
Mempool.c (src): * @param block_size the size for each block
Mempool.c (src):                    rt_size_t          size,
Mempool.c (src):    mp->size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
Mempool.c (src):    /* align the block size */
Mempool.c (src):    /* align to align size byte */
Mempool.c (src):    mp->block_total_count = mp->size / (mp->block_size + sizeof(rt_uint8_t *));
Mempool.c (src): * @param block_size the size for each block
Mempool.c (src):    mp->size       = (block_size + sizeof(rt_uint8_t *)) * block_count;
Memp_std.h (components\net\lwip-1.3.2\src\include\lwip):   The pools are a little bigger to provide 'size' as the amount of user data. */
Memp_std.h (components\net\lwip-1.3.2\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
Memp_std.h (components\net\lwip-1.3.2\src\include\lwip): * Allocates buffers for a pbuf struct AND a payload size */
Memp_std.h (components\net\lwip-1.3.2\src\include\lwip): *     (Example: pbuf_payload_size=0 allocates only size for the struct)
Memp_std.h (components\net\lwip-1.4.1\src\include\lwip):   The pools are a little bigger to provide 'size' as the amount of user data. */
Memp_std.h (components\net\lwip-1.4.1\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
Memp_std.h (components\net\lwip-1.4.1\src\include\lwip): * Allocates buffers for a pbuf struct AND a payload size */
Memp_std.h (components\net\lwip-1.4.1\src\include\lwip): *     (Example: pbuf_payload_size=0 allocates only size for the struct)
Memp_std.h (components\net\lwip-head\src\include\lwip):   The pools are a little bigger to provide 'size' as the amount of user data. */
Memp_std.h (components\net\lwip-head\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_malloc_helper))), "MALLOC_"#size)
Memp_std.h (components\net\lwip-head\src\include\lwip): * Allocates buffers for a pbuf struct AND a payload size */
Memp_std.h (components\net\lwip-head\src\include\lwip): *     (Example: pbuf_payload_size=0 allocates only size for the struct)
Memp_std.h (components\net\lwip\src\include\lwip):   The pools are a little bigger to provide 'size' as the amount of user data. */
Memp_std.h (components\net\lwip\src\include\lwip):#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
Memp_std.h (components\net\lwip\src\include\lwip): * Allocates buffers for a pbuf struct AND a payload size */
Memp_std.h (components\net\lwip\src\include\lwip): *     (Example: pbuf_payload_size=0 allocates only size for the struct)
Mib2.c (components\net\lwip-1.3.2\src\core\snmp):          /* @todo The theoretical maximum is IP_REASS_MAX_PBUFS * size of the pbufs,
Mib2.c (components\net\lwip-1.4.1\src\core\snmp):          /* @todo The theoretical maximum is IP_REASS_MAX_PBUFS * size of the pbufs,
Mib2.c (components\net\lwip-head\src\core\snmp):          /* @todo The theoretical maximum is IP_REASS_MAX_PBUFS * size of the pbufs,
Mib2.c (components\net\lwip\src\core\snmp):          /* @todo The theoretical maximum is IP_REASS_MAX_PBUFS * size of the pbufs,
Mib_structs.c (components\net\lwip-1.3.2\src\core\snmp):            /* leaf node (e.g. in a fixed size table) */
Mib_structs.c (components\net\lwip-1.4.1\src\core\snmp):            /* leaf node (e.g. in a fixed size table) */
Mib_structs.c (components\net\lwip-head\src\core\snmp):            /* leaf node (e.g. in a fixed size table) */
Mib_structs.c (components\net\lwip\src\core\snmp):            /* leaf node (e.g. in a fixed size table) */
Minigzip.c (components\dfs\filesystems\jffs2\cyg\compress\src):   /* Needed for systems with limitation on stack size. */
Minigzip.c (components\dfs\filesystems\jffs2\cyg\compress\src):    /* Determine the size of the file, needed for mmap: */
Minilzo.c (components\external\lzo):__lzo_align_gap(const lzo_voidp ptr, lzo_uint size)
Minilzo.c (components\external\lzo):    n = (((n + size - 1) / size) * size) - n;
Minilzo.c (components\external\lzo):    n = (((p + size - 1) / size) * size) - p;
Minilzo.c (components\external\lzo):    assert(size > 0);
Minilzo.c (components\external\lzo):    assert(n <= size);
Minilzo.h (components\external\lzo): * When the required size is 0, you can also pass a NULL pointer.
Mipscfg.c (libcpu\mips\xburst):    /* [30:25] MMU size */
Mkkeywordhash.c (components\external\sqlite-3.8.1\tool):  "** But by using this automatically generated code, the size of the code\n"
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):static int conf_ecc_size = 0; // 0 - Let UFFS choose the size
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):	attr->page_data_size = conf_page_data_size;			/* page data size */
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):	attr->spare_size = conf_page_spare_size;			/* page spare size */
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):	attr->ecc_size = conf_ecc_size;						/* ECC size */
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):            else if (!strcmp(arg, "-p") || !strcmp(arg, "--page-size")) {
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):					MSGLN("ERROR: Invalid page data size");
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):            else if (!strcmp(arg, "-s") || !strcmp(arg, "--spare-size")) {
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):					MSGLN("ERROR: Invalid spare size");
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):			else if (!strcmp(arg, "-z") || !strcmp(arg, "--ecc-size")) {
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):					MSGLN("ERROR: Invalid ecc size");
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):        MSGLN("  -p  --page-size      <n>                  page data size, default=%d", PAGE_DATA_SIZE_DEFAULT);
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):        MSGLN("  -s  --spare-size     <n>                  page spare size, default=%d", PAGE_SPARE_SIZE_DEFAULT);
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):		MSGLN("  -z  --ecc-size       <n>                  ECC size, default=0 (auto)");
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):	MSGLN("  page size: %d", conf_page_data_size);
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):	MSGLN("  page spare size: %d", conf_page_spare_size);
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):	MSGLN("  ecc size: %d%s", conf_ecc_size, conf_ecc_size == 0 ? " (auto)" : "");
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):  size_t size;
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):  size = backtrace(array, 10);
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):  backtrace_symbols_fd(array, size, 2);
Mkuffs.c (components\dfs\filesystems\uffs\src\utils):		MSGLN("Internal data structure size:");
Mmc.c (components\drivers\sdio):                               rt_uint32_t  size)
Mmc.c (components\drivers\sdio):        const rt_int32_t __size = size;
Mmcsd_card.h (components\drivers\include\drivers):	rt_uint8_t		c_size_mult;	/* CSD 1.0 , device size multiplier */
Mmcsd_card.h (components\drivers\include\drivers):	rt_uint32_t		c_size;		/* device size */
Mmcsd_card.h (components\drivers\include\drivers):	rt_uint8_t size;
Mmcsd_card.h (components\drivers\include\drivers):	rt_uint32_t		max_blk_size;	/* maximum block size */
Mmcsd_card.h (components\drivers\include\drivers):	rt_uint32_t		cur_blk_size;	/* current block size */
Mmcsd_card.h (components\drivers\include\drivers):	rt_uint32_t	card_blksize;	/* card block size */
Mmcsd_card.h (components\drivers\include\drivers):	rt_uint32_t	erase_size;	/* erase size in sectors */
Mmcsd_host.h (components\drivers\include\drivers):	rt_uint32_t	max_seg_size;	/* maximum size of one dma segment */
Mmcsd_host.h (components\drivers\include\drivers):	rt_uint32_t	max_blk_size;   /* maximum block size */
Mmu.c (libcpu\arm\am335x):void mmu_clean_invalidated_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\am335x):    while(ptr < buffer + size)
Mmu.c (libcpu\arm\am335x):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\am335x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\am335x):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\am335x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\am335x):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\am335x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\am335x):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\am335x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\arm926):void mmu_clean_invalidated_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\arm926):    while(ptr < buffer + size)
Mmu.c (libcpu\arm\arm926):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\arm926):    while (ptr < buffer + size)
Mmu.c (libcpu\arm\arm926):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\arm926):    while (ptr < buffer + size)
Mmu.c (libcpu\arm\arm926):void mmu_clean_invalidated_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\arm926):    while(ptr < buffer + size)
Mmu.c (libcpu\arm\arm926):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\arm926):    while (ptr < buffer + size)
Mmu.c (libcpu\arm\arm926):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\arm926):    while (ptr < buffer + size)
Mmu.c (libcpu\arm\arm926):void rt_hw_mmu_init(struct mem_desc *mdesc, rt_uint32_t size)
Mmu.c (libcpu\arm\arm926):    for (; size > 0; size--)
Mmu.c (libcpu\arm\armv6):void mmu_clean_invalidated_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	while(ptr < buffer + size)
Mmu.c (libcpu\arm\armv6):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\armv6):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\armv6):void mmu_clean_invalidated_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	while(ptr < buffer + size)
Mmu.c (libcpu\arm\armv6):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\armv6):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\armv6):static void build_pte_mem_desc(struct mem_desc *mdesc, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	for (; size > 0; size--)
Mmu.c (libcpu\arm\armv6):			rt_kprintf("PTE table size too little\n");
Mmu.c (libcpu\arm\armv6):void rt_hw_mmu_init(struct mem_desc *mdesc, rt_uint32_t size)
Mmu.c (libcpu\arm\armv6):	build_pte_mem_desc(mdesc, size);
Mmu.c (libcpu\arm\armv6):	for (; size > 0; size--)
Mmu.c (libcpu\arm\dm36x):void mmu_clean_invalidated_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):    while(ptr < buffer + size)
Mmu.c (libcpu\arm\dm36x):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\dm36x):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\dm36x):void mmu_clean_invalidated_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):    while(ptr < buffer + size)
Mmu.c (libcpu\arm\dm36x):void mmu_clean_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\dm36x):void mmu_invalidate_dcache(rt_uint32_t buffer, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):	while (ptr < buffer + size)
Mmu.c (libcpu\arm\dm36x):static void build_pte_mem_desc(struct mem_desc *mdesc, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):    for (; size > 0; size--)
Mmu.c (libcpu\arm\dm36x):            rt_kprintf("PTE table size too little\n");
Mmu.c (libcpu\arm\dm36x):void rt_hw_mmu_init(struct mem_desc *mdesc, rt_uint32_t size)
Mmu.c (libcpu\arm\dm36x):    build_pte_mem_desc(mdesc, size);
Mmu.c (libcpu\arm\dm36x):    for (; size > 0; size--)
Mmu.c (libcpu\arm\zynq7000):     * entry is 1MB in size. */
Mmu.h (libcpu\arm\arm926):void rt_hw_mmu_init(struct mem_desc *mdesc, rt_uint32_t size);
Mmu.h (libcpu\arm\armv6):void rt_hw_mmu_init(struct mem_desc *mdesc, rt_uint32_t size);
Mmu.h (libcpu\arm\dm36x):void rt_hw_mmu_init(struct mem_desc *mdesc, rt_uint32_t size);
Module.c (src):    rt_size_t size;                /* size of memory block */
Module.c (src):    /* get the ELF image size */
Module.c (src):    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("module size: %d, vstart_addr: 0x%p\n",
Module.c (src):        rt_kprintf("Module: size error\n");
Module.c (src):    /* get the ELF image size */
Module.c (src):            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("load text 0x%x, size %d\n",
Module.c (src):                         ("load rodata 0x%x, size %d, rodata 0x%x\n",
Module.c (src):                         ("load data 0x%x, size %d, data 0x%x\n",
Module.c (src):            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("load bss 0x%x, size %d,\n",
Module.c (src):    int size;
Module.c (src):    size = end - first + 1;
Module.c (src):    name = rt_malloc(size);
Module.c (src):    rt_strncpy(name, first, size);
Module.c (src):    name[size] = '\0';
Module.c (src): * @param size the size of command line of program
Module.c (src):rt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size)
Module.c (src):    /* get file size */
Module.c (src):    module = rt_module_do_main(name, (void *)buffer, cmd_line, size);
Module.c (src): * This function will allocate the numbers page with specified size
Module.c (src): * @param size the size of memory to be allocated.
Module.c (src):void *rt_module_malloc(rt_size_t size)
Module.c (src):    nunits = (size + sizeof(struct rt_mem_head) - 1) /
Module.c (src):    RT_ASSERT(size != 0);
Module.c (src):        if (b->size > nunits)
Module.c (src):            n->size = b->size - nunits;
Module.c (src):            b->size = nunits;
Module.c (src):                                           b + 1, size));
Module.c (src):        if (b->size == nunits)
Module.c (src):                                           b + 1, size));
Module.c (src):    npage = (size + sizeof(struct rt_mem_head) + RT_MM_PAGE_SIZE - 1) /
Module.c (src):    up->size = npage * RT_MM_PAGE_SIZE / sizeof(struct rt_mem_head);
Module.c (src):        if (b > up + up->size)
Module.c (src):    return rt_module_malloc(size);
Module.c (src):        RT_ASSERT(b->size > 0);
Module.c (src):        RT_ASSERT(b > n || b + b->size <= n);
Module.c (src):        if (b + b->size == n && ((rt_uint32_t)n % RT_MM_PAGE_SIZE != 0))
Module.c (src):            if (b + (b->size + n->size) == b->next)
Module.c (src):                b->size += b->next->size + n->size;
Module.c (src):                b->size += n->size;
Module.c (src):                    b->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
Module.c (src):                    if ((b->size * sizeof(struct rt_page_info) % RT_MM_PAGE_SIZE) != 0)
Module.c (src):                        r->size = b->size - nunits;
Module.c (src):        if (b == n + n->size)
Module.c (src):            n->size = b->size + n->size;
Module.c (src):                    n->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
Module.c (src):                    if ((n->size * sizeof(struct rt_page_info) % RT_MM_PAGE_SIZE) != 0)
Module.c (src):                        r->size = n->size - nunits;
Module.c (src):        if (b > n + n->size)
Module.c (src):        int npage = n->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
Module.c (src):            if (n->size % RT_MM_PAGE_SIZE != 0)
Module.c (src):                r->size = n->size - nunits;
Module.c (src):void *rt_module_realloc(void *ptr, rt_size_t size)
Module.c (src):        return rt_module_malloc(size);
Module.c (src):    if (size == 0)
Module.c (src):    nunits = (size + sizeof(struct rt_mem_head) - 1) /
Module.c (src):    if (nunits <= b->size)
Module.c (src):        /* new size is smaller or equal then before */
Module.c (src):        if (nunits == b->size)
Module.c (src):            p->size = b->size - nunits;
Module.c (src):            b->size = nunits;
Module.c (src):             p != (b->size + b) && p != RT_NULL;
Module.c (src):            (p->size >= (nunits - (b->size))) &&
Module.c (src):            p == (b + b->size))
Module.c (src):            if (p->size == (nunits - (b->size)))
Module.c (src):                b->size    = nunits;
Module.c (src):                /* new size for p */
Module.c (src):                p->size    = tmpp->size + b->size - nunits;
Module.c (src):                b->size    = nunits;
Module.c (src):            if ((p = rt_module_malloc(size)) == RT_NULL)
Module.c (src):            rt_memmove(p, (b+1), ((b->size) * sizeof(struct rt_mem_head)));
Module.c (src):        rt_kprintf("0x%x--%d\n", b, b->size * sizeof(struct rt_mem_head));
Module.h (src):#define SELFMAG                 4              /* size of magic */
Module.h (src):    Elf32_Half    e_ehsize;                    /* ELF header size */
Module.h (src):    Elf32_Half    e_phentsize;                 /* program header entry size */
Module.h (src):    Elf32_Half    e_shentsize;                 /* section header entry size */
Module.h (src):    Elf32_Word sh_size;                        /* section size */
Module.h (src):    Elf32_Word sh_entsize;                     /* section entry size */
Module.h (src):    Elf32_Word    st_size;                     /* symbol size */
Modules.html (components\net\uip\doc\html):<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 12 10:23:02 2006 for uIP 1.0 by&nbsp;
Mpu6050_sensor.cpp (components\drivers\sensors):int MPU6050::read_buffer(rt_uint8_t reg, rt_uint8_t* value, rt_size_t size)
Mpu6050_sensor.cpp (components\drivers\sensors):    msgs[1].len   = size;
Mpu6050_sensor.h (components\drivers\sensors):    int read_buffer(rt_uint8_t reg, rt_uint8_t* value, rt_size_t size);
Mqueue.h (components\pthreads):    long mq_msgsize;    /* Maximum message size. */
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_write (rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size);
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size);
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_sdhc_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size);
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_sdhc_write (rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size);
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size)
Msd.c (bsp\stm32f407vgt6\drivers):    if(size == 1)
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):    else if(size > 1)
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):        for(i=0; i<size; i++)
Msd.c (bsp\stm32f407vgt6\drivers):                size = i;
Msd.c (bsp\stm32f407vgt6\drivers):    return size;
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_sdhc_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size)
Msd.c (bsp\stm32f407vgt6\drivers):    if(size == 1)
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):    else if(size > 1)
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):        for(i=0; i<size; i++)
Msd.c (bsp\stm32f407vgt6\drivers):                size = i;
Msd.c (bsp\stm32f407vgt6\drivers):    return size;
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_write (rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size)
Msd.c (bsp\stm32f407vgt6\drivers):    if(size == 1)
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):    else if(size > 1)
Msd.c (bsp\stm32f407vgt6\drivers):                size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):            result = _send_cmd(msd->spi_device, SET_WR_BLK_ERASE_COUNT, size, 0x00, response_r1, response);
Msd.c (bsp\stm32f407vgt6\drivers):                size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):        for(i=0; i<size; i++)
Msd.c (bsp\stm32f407vgt6\drivers):                size = i;
Msd.c (bsp\stm32f407vgt6\drivers):    } /* size > 1 */
Msd.c (bsp\stm32f407vgt6\drivers):    return size;
Msd.c (bsp\stm32f407vgt6\drivers):static rt_size_t rt_msd_sdhc_write (rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size)
Msd.c (bsp\stm32f407vgt6\drivers):    if(size == 1)
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):    else if(size > 1)
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):        result = _send_cmd(msd->spi_device, SET_WR_BLK_ERASE_COUNT, size, 0x00, response_r1, response);
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):            size = 0;
Msd.c (bsp\stm32f407vgt6\drivers):        for(i=0; i<size; i++)
Msd.c (bsp\stm32f407vgt6\drivers):                size = i;
Msd.c (bsp\stm32f407vgt6\drivers):    } /* size > 1 */
Msd.c (bsp\stm32f407vgt6\drivers):    return size;
Msd.h (bsp\stm32f407vgt6\drivers):#define SECTOR_SIZE                         512         /**< sector size, default 512byte */
Msd.h (bsp\stm32f407vgt6\drivers):    struct rt_device_blk_geometry   geometry;    /**< sector size, sector count */
Msg_out.c (components\net\lwip-1.3.2\src\core\snmp):    /* pass 1, size error, encode packet ino the pbuf(s) */
Msg_out.c (components\net\lwip-1.4.1\src\core\snmp):    /* pass 1, size error, encode packet ino the pbuf(s) */
Msg_out.c (components\net\lwip-head\src\core\snmp):    /* pass 1, size error, encode packet ino the pbuf(s) */
Msg_out.c (components\net\lwip\src\core\snmp):    /* pass 1, size error, encode packet ino the pbuf(s) */
Msh.c (components\finsh):static cmd_function_t msh_get_cmd(char *cmd, int size)
Msh.c (components\finsh):        if (strncmp(&index->name[6], cmd, size) == 0 &&
Msh.c (components\finsh):                index->name[6 + size] == '\0')
Msh.c (components\finsh):int msh_exec_module(const char *cmd_line, int size)
Msh.c (components\finsh):    if (size == 0)
Msh.c (components\finsh):    while ((cmd_line[cmd_length] != ' ' && cmd_line[cmd_length] != '\t') && cmd_length < size)
Msh.c (components\finsh):        rt_module_exec_cmd(pg_name, cmd_line, size);
Msh.c (components\finsh):    /* find the size of first command */
Msh.h (components\finsh):int msh_exec_module(const char *cmd_line, int size);
Msh.h (components\finsh):int msh_exec_script(const char *cmd_line, int size);
Msh_file.c (components\finsh):static int msh_readline(int fd, char *line_buf, int size)
Msh_file.c (components\finsh):    while (index < size)
Msh_file.c (components\finsh):int msh_exec_script(const char *cmd_line, int size)
Msh_file.c (components\finsh):    if (size == 0) return -RT_ERROR;
Msh_file.c (components\finsh):    while ((cmd_line[cmd_length] != ' ' && cmd_line[cmd_length] != '\t') && cmd_length < size)
Mstorage.c (components\drivers\usb\usbdevice\class):    rt_int32_t size;
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_in->request.size = SIZEOF_CSW;    
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_in->request.size = data->cb_data_size;
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_in->request.size = data->cb_data_size;
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_in->request.size = data->cb_data_size;
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_in->request.size = data->cb_data_size;
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_in->request.size = data->cb_data_size;
Mstorage.c (components\drivers\usb\usbdevice\class):    rt_size_t size;
Mstorage.c (components\drivers\usb\usbdevice\class):    size = rt_device_read(data->disk, data->block, data->ep_in->buffer, 1);
Mstorage.c (components\drivers\usb\usbdevice\class):    if(size == 0)
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_in->request.size = data->geometry.bytes_per_sector;    
Mstorage.c (components\drivers\usb\usbdevice\class):    data->size = data->count * data->geometry.bytes_per_sector;
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_out->request.size = data->geometry.bytes_per_sector;    
Mstorage.c (components\drivers\usb\usbdevice\class):static rt_err_t _ep_in_handler(ufunction_t func, rt_size_t size)
Mstorage.c (components\drivers\usb\usbdevice\class):        if(data->ep_in->request.size != SIZEOF_CSW)
Mstorage.c (components\drivers\usb\usbdevice\class):            data->ep_out->request.size = SIZEOF_CBW;
Mstorage.c (components\drivers\usb\usbdevice\class):            data->csw_response.data_reside -= data->ep_in->request.size;
Mstorage.c (components\drivers\usb\usbdevice\class):                    data->csw_response.data_reside, data->ep_in->request.size));
Mstorage.c (components\drivers\usb\usbdevice\class):        data->csw_response.data_reside -= data->ep_in->request.size;
Mstorage.c (components\drivers\usb\usbdevice\class):            data->ep_in->request.size = data->geometry.bytes_per_sector;    
Mstorage.c (components\drivers\usb\usbdevice\class): * @param size request size.
Mstorage.c (components\drivers\usb\usbdevice\class):static rt_err_t _ep_out_handler(ufunction_t func, rt_size_t size)
Mstorage.c (components\drivers\usb\usbdevice\class):    RT_DEBUG_LOG(RT_DEBUG_USB, ("_ep_out_handler %d\n", size));
Mstorage.c (components\drivers\usb\usbdevice\class):        if(cbw->signature != CBW_SIGNATURE || size != SIZEOF_CBW)
Mstorage.c (components\drivers\usb\usbdevice\class):        RT_DEBUG_LOG(RT_DEBUG_USB, ("\nwrite size %d block 0x%x oount 0x%x\n",
Mstorage.c (components\drivers\usb\usbdevice\class):                                    size, data->block, data->size));
Mstorage.c (components\drivers\usb\usbdevice\class):        data->size -= size;
Mstorage.c (components\drivers\usb\usbdevice\class):        data->csw_response.data_reside -= size;
Mstorage.c (components\drivers\usb\usbdevice\class):            data->ep_out->request.size = data->geometry.bytes_per_sector;    
Mstorage.c (components\drivers\usb\usbdevice\class):    data->ep_out->request.size = SIZEOF_CBW;    
Mtd_nand.c (components\drivers\mtd):                           rt_size_t   size)
Mtd_nand.c (components\drivers\mtd):    return size;
Mtd_nand.c (components\drivers\mtd):                            rt_size_t   size)
Mtd_nand.c (components\drivers\mtd):    return size;
Mtd_nand.h (components\drivers\include\drivers):    rt_uint16_t page_size;          /* The Page size in the flash */
Mtd_nand.h (components\drivers\include\drivers):    rt_uint16_t oob_size;           /* Out of bank size */
Mtd_nor.c (components\drivers\mtd):                           rt_size_t   size)
Mtd_nor.c (components\drivers\mtd):    return size;
Mtd_nor.c (components\drivers\mtd):                            rt_size_t   size)
Mtd_nor.c (components\drivers\mtd):    return size;
Mtd_nor.h (components\drivers\include\drivers):	rt_uint32_t block_size;			/* The Block size in the flash */
Nd6.c (components\net\lwip-head\src\core\ipv6):/* Static buffer to parse RA packet options (size of a prefix option, biggest option) */
Netbuf.c (components\net\lwip-1.3.2\src\api): * @param size the size of the packet buffer to allocate
Netbuf.c (components\net\lwip-1.3.2\src\api):netbuf_alloc(struct netbuf *buf, u16_t size)
Netbuf.c (components\net\lwip-1.3.2\src\api):  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
Netbuf.c (components\net\lwip-1.3.2\src\api):  LWIP_ASSERT("check that first pbuf can hold size",
Netbuf.c (components\net\lwip-1.3.2\src\api):             (buf->p->len >= size));
Netbuf.c (components\net\lwip-1.3.2\src\api): * @param size size of the data
Netbuf.c (components\net\lwip-1.3.2\src\api):netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
Netbuf.c (components\net\lwip-1.3.2\src\api):  buf->p->len = buf->p->tot_len = size;
Netbuf.c (components\net\lwip-1.4.1\src\api): * @param size the size of the packet buffer to allocate
Netbuf.c (components\net\lwip-1.4.1\src\api):netbuf_alloc(struct netbuf *buf, u16_t size)
Netbuf.c (components\net\lwip-1.4.1\src\api):  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
Netbuf.c (components\net\lwip-1.4.1\src\api):  LWIP_ASSERT("check that first pbuf can hold size",
Netbuf.c (components\net\lwip-1.4.1\src\api):             (buf->p->len >= size));
Netbuf.c (components\net\lwip-1.4.1\src\api): * @param size size of the data
Netbuf.c (components\net\lwip-1.4.1\src\api):netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
Netbuf.c (components\net\lwip-1.4.1\src\api):  buf->p->len = buf->p->tot_len = size;
Netbuf.c (components\net\lwip-head\src\api): * @param size the size of the packet buffer to allocate
Netbuf.c (components\net\lwip-head\src\api):netbuf_alloc(struct netbuf *buf, u16_t size)
Netbuf.c (components\net\lwip-head\src\api):  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
Netbuf.c (components\net\lwip-head\src\api):  LWIP_ASSERT("check that first pbuf can hold size",
Netbuf.c (components\net\lwip-head\src\api):             (buf->p->len >= size));
Netbuf.c (components\net\lwip-head\src\api): * @param size size of the data
Netbuf.c (components\net\lwip-head\src\api):netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
Netbuf.c (components\net\lwip-head\src\api):  buf->p->len = buf->p->tot_len = size;
Netbuf.c (components\net\lwip\src\api): * @param size the size of the packet buffer to allocate
Netbuf.c (components\net\lwip\src\api):netbuf_alloc(struct netbuf *buf, u16_t size)
Netbuf.c (components\net\lwip\src\api):  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
Netbuf.c (components\net\lwip\src\api):  LWIP_ASSERT("check that first pbuf can hold size",
Netbuf.c (components\net\lwip\src\api):             (buf->p->len >= size));
Netbuf.c (components\net\lwip\src\api): * @param size size of the data
Netbuf.c (components\net\lwip\src\api):netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
Netbuf.c (components\net\lwip\src\api):  buf->p->len = buf->p->tot_len = size;
Netbuf.h (components\net\lwip-1.3.2\src\include\lwip):void *            netbuf_alloc    (struct netbuf *buf, u16_t size);
Netbuf.h (components\net\lwip-1.3.2\src\include\lwip):           const void *dataptr, u16_t size);
Netbuf.h (components\net\lwip-1.4.1\src\include\lwip):void *            netbuf_alloc    (struct netbuf *buf, u16_t size);
Netbuf.h (components\net\lwip-1.4.1\src\include\lwip):                                   const void *dataptr, u16_t size);
Netbuf.h (components\net\lwip-head\src\include\lwip):void *            netbuf_alloc    (struct netbuf *buf, u16_t size);
Netbuf.h (components\net\lwip-head\src\include\lwip):                                   const void *dataptr, u16_t size);
Netbuf.h (components\net\lwip\src\include\lwip):void *            netbuf_alloc    (struct netbuf *buf, u16_t size);
Netbuf.h (components\net\lwip\src\include\lwip):                                   const void *dataptr, u16_t size);
Netdb.c (components\net\lwip-1.3.2\src\api): * @param buflen the size of buf
Netdb.c (components\net\lwip-1.4.1\src\api): * @param buflen the size of buf
Netdb.c (components\net\lwip-head\src\api): * @param buflen the size of buf
Netdb.c (components\net\lwip\src\api): * @param buflen the size of buf
Nfs.h (components\dfs\filesystems\nfs):	size3 size;
Nfs.h (components\dfs\filesystems\nfs):	size3 size;
Nfs.h (components\dfs\filesystems\nfs):		size3 size;
Nfs.h (components\dfs\filesystems\nfs):	set_size3 size;
Nfs_xdr.c (components\dfs\filesystems\nfs):	if (!xdr_size3(xdrs, &objp->size))
Nfs_xdr.c (components\dfs\filesystems\nfs):	if (!xdr_size3(xdrs, &objp->size))
Nfs_xdr.c (components\dfs\filesystems\nfs):		if (!xdr_size3(xdrs, &objp->set_size3_u.size))
Nfs_xdr.c (components\dfs\filesystems\nfs):	if (!xdr_set_size3(xdrs, &objp->size))
Nodelist.c (components\dfs\filesystems\jffs2\src):				ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):				ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);
Nodelist.c (components\dfs\filesystems\jffs2\src):	JFFS2_DBG_FRAGTREE2("insert frag (0x%04x-0x%04x)\n", newfrag->ofs, newfrag->ofs + newfrag->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):			  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);
Nodelist.c (components\dfs\filesystems\jffs2\src):		lastend = this->ofs + this->size;
Nodelist.c (components\dfs\filesystems\jffs2\src):			holefrag->size = newfrag->node->ofs - lastend;
Nodelist.c (components\dfs\filesystems\jffs2\src):		  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);
Nodelist.c (components\dfs\filesystems\jffs2\src):	 * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs  
Nodelist.c (components\dfs\filesystems\jffs2\src):		if (this->ofs + this->size > newfrag->ofs + newfrag->size) {
Nodelist.c (components\dfs\filesystems\jffs2\src):					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
Nodelist.c (components\dfs\filesystems\jffs2\src):					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
Nodelist.c (components\dfs\filesystems\jffs2\src):			newfrag2->ofs = newfrag->ofs + newfrag->size;
Nodelist.c (components\dfs\filesystems\jffs2\src):			newfrag2->size = (this->ofs+this->size) - newfrag2->ofs;
Nodelist.c (components\dfs\filesystems\jffs2\src):			/* Adjust size of original 'this' */
Nodelist.c (components\dfs\filesystems\jffs2\src):			this->size = newfrag->ofs - this->ofs;
Nodelist.c (components\dfs\filesystems\jffs2\src):		/* New node just reduces 'this' frag in size, doesn't split it */
Nodelist.c (components\dfs\filesystems\jffs2\src):		this->size = newfrag->ofs - this->ofs;
Nodelist.c (components\dfs\filesystems\jffs2\src):			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):		if (newfrag->ofs + newfrag->size >= this->ofs+this->size) {
Nodelist.c (components\dfs\filesystems\jffs2\src):			JFFS2_DBG_FRAGTREE2("obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):			this->ofs += newfrag->size;
Nodelist.c (components\dfs\filesystems\jffs2\src):			this->size -= newfrag->size;
Nodelist.c (components\dfs\filesystems\jffs2\src):	while ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
Nodelist.c (components\dfs\filesystems\jffs2\src):			this, this->ofs, this->ofs+this->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):	if (!this || newfrag->ofs + newfrag->size == this->ofs) {
Nodelist.c (components\dfs\filesystems\jffs2\src):	this->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):	this->ofs = newfrag->ofs + newfrag->size;
Nodelist.c (components\dfs\filesystems\jffs2\src):	if (unlikely(!fn->size))
Nodelist.c (components\dfs\filesystems\jffs2\src):		  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);
Nodelist.c (components\dfs\filesystems\jffs2\src):	newfrag->size = fn->size;
Nodelist.c (components\dfs\filesystems\jffs2\src):	if ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {
Nodelist.c (components\dfs\filesystems\jffs2\src):			  frag->ofs, frag->ofs+frag->size, frag, frag->rb.rb_left, frag->rb.rb_right);
Nodelist.c (components\dfs\filesystems\jffs2\src):		if (frag->ofs + frag->size <= offset) {
Nodelist.c (components\dfs\filesystems\jffs2\src):				  frag->ofs, frag->ofs+frag->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):				  frag->ofs, frag->ofs+frag->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):				  frag->ofs, frag->ofs+frag->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):			  prev->ofs, prev->ofs+prev->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):				frag, frag->ofs, frag->ofs+frag->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):				  frag, frag->ofs, frag->ofs+frag->size);
Nodelist.c (components\dfs\filesystems\jffs2\src):			  frag->ofs, frag->ofs+frag->size, frag->node, frag->node?frag->node->frags:0);
Nodelist.h (components\dfs\filesystems\jffs2\src):	uint32_t size;
Nodelist.h (components\dfs\filesystems\jffs2\src):	uint32_t size;
Nodelist.h (components\dfs\filesystems\jffs2\src):#define VERYDIRTY(c, size) ((size) >= ((c)->sector_size / 2))
Nodelist.h (components\dfs\filesystems\jffs2\src):#define ISDIRTY(size) ((size) >  sizeof (struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN) 
Nodelist.h (components\dfs\filesystems\jffs2\src):void jffs2_truncate_fragtree (struct jffs2_sb_info *c, struct rb_root *list, uint32_t size);
Nodemgmt.c (components\dfs\filesystems\jffs2\src): *	@minsize: Minimum acceptable size of allocation
Nodemgmt.c (components\dfs\filesystems\jffs2\src):			/* calculate real dirty size
Nodemgmt.c (components\dfs\filesystems\jffs2\src):				D1(printk(KERN_DEBUG "dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\n",
Nodemgmt.c (components\dfs\filesystems\jffs2\src):			 * don't know, if unchecked size contains obsoleted nodes, which could give us some
Nodemgmt.c (components\dfs\filesystems\jffs2\src):				D1(printk(KERN_DEBUG "max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\n",
Nodemgmt.c (components\dfs\filesystems\jffs2\src):	D1(printk(KERN_DEBUG "jffs2_add_physical_node_ref(): Node at 0x%x(%d), size 0x%x\n", ref_offset(new), ref_flags(new), len));
Nodemgmt.c (components\dfs\filesystems\jffs2\src):			printk(KERN_NOTICE "raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\n",
Nodemgmt.c (components\dfs\filesystems\jffs2\src):			printk(KERN_NOTICE "raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\n",
Nodemgmt.c (components\dfs\filesystems\jffs2\src):	// Take care, that wasted size is taken into concern
Offsets.c (components\external\sqlite-3.8.1\tool):** particular table.  The rowid, size and offset for the column are
Offsets.c (components\external\sqlite-3.8.1\tool):  int szPg;             /* Page size for the database file */
Offsets.c (components\external\sqlite-3.8.1\tool):    ofstError(p, "cannot find page size");
Offsets.c (components\external\sqlite-3.8.1\tool):/* Return the size (in bytes) of the data corresponding to the
Offsets.c (components\external\sqlite-3.8.1\tool):         "rowid %12lld size %5d offset %8d",
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * instead of the lwip internal allocator. Can save code size if you
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * MEM_SIZE: the size of the heap memory. If the application will send
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
Opt.h (components\net\lwip-1.3.2\src\include\lwip):    The buffer will be of size DNS_MSG_SIZE */
Opt.h (components\net\lwip-1.3.2\src\include\lwip):/** DNS message max. size. Default value is RFC compliant. */
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * TCP_WND: The size of a TCP window.  This must be at least 
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * when opening a connection. For the transmit size, this MSS sets
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * reflects the available reassembly buffer size at the remote host) and the
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * largest size permitted by the IP layer" (RFC 1122)
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * designed to accomodate single full size TCP frame in one pbuf, including
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * PPP_THREAD_STACKSIZE: The stack size used by the pppMain thread.
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
Opt.h (components\net\lwip-1.3.2\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.3.2\src\include\lwip):#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * instead of the lwip internal allocator. Can save code size if you
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * MEM_SIZE: the size of the heap memory. If the application will send
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The maximum length of strings used. This affects the size of
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * This affects the size of MEMP_SNMP_VALUE elements.
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The size of the MEMP_SNMP_VALUE elements, normally calculated from
Opt.h (components\net\lwip-1.4.1\src\include\lwip):/** DNS message max. size. Default value is RFC compliant. */
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * TCP_WND: The size of a TCP window.  This must be at least 
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * when opening a connection. For the transmit size, this MSS sets
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * reflects the available reassembly buffer size at the remote host) and the
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * largest size permitted by the IP layer" (RFC 1122)
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * designed to accomodate single full size TCP frame in one pbuf, including
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
Opt.h (components\net\lwip-1.4.1\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-1.4.1\src\include\lwip):#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
Opt.h (components\net\lwip-head\src\include\lwip): * instead of the lwip internal allocator. Can save code size if you
Opt.h (components\net\lwip-head\src\include\lwip): * MEM_SIZE: the size of the heap memory. If the application will send
Opt.h (components\net\lwip-head\src\include\lwip): * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
Opt.h (components\net\lwip-head\src\include\lwip): * The maximum length of strings used. This affects the size of
Opt.h (components\net\lwip-head\src\include\lwip): * This affects the size of MEMP_SNMP_VALUE elements.
Opt.h (components\net\lwip-head\src\include\lwip): * The size of the MEMP_SNMP_VALUE elements, normally calculated from
Opt.h (components\net\lwip-head\src\include\lwip):/** DNS message max. size. Default value is RFC compliant. */
Opt.h (components\net\lwip-head\src\include\lwip): * TCP_WND: The size of a TCP window.  This must be at least 
Opt.h (components\net\lwip-head\src\include\lwip): * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
Opt.h (components\net\lwip-head\src\include\lwip): * when opening a connection. For the transmit size, this MSS sets
Opt.h (components\net\lwip-head\src\include\lwip): * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
Opt.h (components\net\lwip-head\src\include\lwip): * reflects the available reassembly buffer size at the remote host) and the
Opt.h (components\net\lwip-head\src\include\lwip): * largest size permitted by the IP layer" (RFC 1122)
Opt.h (components\net\lwip-head\src\include\lwip): * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
Opt.h (components\net\lwip-head\src\include\lwip): * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
Opt.h (components\net\lwip-head\src\include\lwip): * designed to accomodate single full size TCP frame in one pbuf, including
Opt.h (components\net\lwip-head\src\include\lwip): * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
Opt.h (components\net\lwip-head\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-head\src\include\lwip): * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
Opt.h (components\net\lwip-head\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-head\src\include\lwip): * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
Opt.h (components\net\lwip-head\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-head\src\include\lwip): * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
Opt.h (components\net\lwip-head\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-head\src\include\lwip): * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-head\src\include\lwip): * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-head\src\include\lwip): * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-head\src\include\lwip): * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-head\src\include\lwip): * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip-head\src\include\lwip): * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip-head\src\include\lwip): * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
Opt.h (components\net\lwip-head\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip-head\src\include\lwip): * LWIP_FIONREAD_LINUXMODE==1: ioctl/FIONREAD returns the size of the next
Opt.h (components\net\lwip-head\src\include\lwip):#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
Opt.h (components\net\lwip\src\include\lwip): * instead of the lwip internal allocator. Can save code size if you
Opt.h (components\net\lwip\src\include\lwip): * MEM_SIZE: the size of the heap memory. If the application will send
Opt.h (components\net\lwip\src\include\lwip): * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
Opt.h (components\net\lwip\src\include\lwip): * The maximum length of strings used. This affects the size of
Opt.h (components\net\lwip\src\include\lwip): * This affects the size of MEMP_SNMP_VALUE elements.
Opt.h (components\net\lwip\src\include\lwip): * The size of the MEMP_SNMP_VALUE elements, normally calculated from
Opt.h (components\net\lwip\src\include\lwip):/** DNS message max. size. Default value is RFC compliant. */
Opt.h (components\net\lwip\src\include\lwip): * TCP_WND: The size of a TCP window.  This must be at least 
Opt.h (components\net\lwip\src\include\lwip): * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
Opt.h (components\net\lwip\src\include\lwip): * when opening a connection. For the transmit size, this MSS sets
Opt.h (components\net\lwip\src\include\lwip): * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
Opt.h (components\net\lwip\src\include\lwip): * reflects the available reassembly buffer size at the remote host) and the
Opt.h (components\net\lwip\src\include\lwip): * largest size permitted by the IP layer" (RFC 1122)
Opt.h (components\net\lwip\src\include\lwip): * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
Opt.h (components\net\lwip\src\include\lwip): * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
Opt.h (components\net\lwip\src\include\lwip): * designed to accomodate single full size TCP frame in one pbuf, including
Opt.h (components\net\lwip\src\include\lwip): * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
Opt.h (components\net\lwip\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip\src\include\lwip): * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
Opt.h (components\net\lwip\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip\src\include\lwip): * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
Opt.h (components\net\lwip\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip\src\include\lwip): * PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
Opt.h (components\net\lwip\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip\src\include\lwip): * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
Opt.h (components\net\lwip\src\include\lwip): * The stack size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip\src\include\lwip): * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip\src\include\lwip): * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip\src\include\lwip): * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip\src\include\lwip): * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip\src\include\lwip): * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
Opt.h (components\net\lwip\src\include\lwip): * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
Opt.h (components\net\lwip\src\include\lwip): * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
Opt.h (components\net\lwip\src\include\lwip): * The queue size value itself is platform-dependent, but is passed to
Opt.h (components\net\lwip\src\include\lwip):#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
Os-ecos.h (components\dfs\filesystems\jffs2\src):			  const size_t size, size_t * return_size, unsigned char * write_buffer);
Os-ecos.h (components\dfs\filesystems\jffs2\src):			   const size_t size, size_t * return_size, unsigned char * read_buffer);
Os-rtthread.h (components\dfs\filesystems\jffs2\src):			  const size_t size, size_t * return_size, unsigned char * write_buffer);
Os-rtthread.h (components\dfs\filesystems\jffs2\src):			   const size_t size, size_t * return_size, unsigned char * read_buffer);
Os.c (components\external\sqlite-3.8.1\src):int sqlite3OsTruncate(sqlite3_file *id, i64 size){
Os.c (components\external\sqlite-3.8.1\src):  return id->pMethods->xTruncate(id, size);
Os.h (components\external\sqlite-3.8.1\src):** The default size of a disk sector
Os.h (components\external\sqlite-3.8.1\src):** that all locks will fit on a single page even at the minimum page size.
Os.h (components\external\sqlite-3.8.1\src):int sqlite3OsTruncate(sqlite3_file*, i64 size);
Os_rtthread.c (components\external\sqlite-3.8.1\src):  /* In test mode, increase the size of this structure a bit so that
Os_rtthread.c (components\external\sqlite-3.8.1\src):** SQLite sets the dataOnly flag if the size of the file is unchanged.
Os_rtthread.c (components\external\sqlite-3.8.1\src):** to disk, not the inode.  We only set dataOnly if the file size is
Os_rtthread.c (components\external\sqlite-3.8.1\src):** unchanged since the file size is part of the inode.  However,
Os_rtthread.c (components\external\sqlite-3.8.1\src):** file size has changed.  The only real difference between fdatasync()
Os_rtthread.c (components\external\sqlite-3.8.1\src):** We only care about the file size, not the other file attributes, so
Os_rtthread.c (components\external\sqlite-3.8.1\src):** size, access time, etc) are synced.  If dataOnly!=0 then only the
Os_rtthread.c (components\external\sqlite-3.8.1\src):** Truncate an open file to a specified size
Os_rtthread.c (components\external\sqlite-3.8.1\src):  /* If the user has configured a chunk-size for this file, truncate the
Os_rtthread.c (components\external\sqlite-3.8.1\src):  ** actual file size after the operation may be larger than the requested
Os_rtthread.c (components\external\sqlite-3.8.1\src):  ** size).
Os_rtthread.c (components\external\sqlite-3.8.1\src):** Determine the current size of a file in bytes
Os_rtthread.c (components\external\sqlite-3.8.1\src):  /* When opening a zero-size database, the findInodeInfo() procedure
Os_rtthread.c (components\external\sqlite-3.8.1\src):  ** layers, we need to report this file size as zero even though it is
Os_rtthread.c (components\external\sqlite-3.8.1\src):** file-control operation.  Enlarge the database to nBytes in size
Os_rtthread.c (components\external\sqlite-3.8.1\src):** (rounded up to the next chunk-size).  If the database is already
Os_rtthread.c (components\external\sqlite-3.8.1\src):    i64 nSize;                    /* Required file size */
Os_rtthread.c (components\external\sqlite-3.8.1\src):      ** ftruncate() to set the file size, then write a single byte to
Os_rtthread.c (components\external\sqlite-3.8.1\src):      int nBlk = 4096; // no blksize in RT-Thread, use 4096. /* File-system block size */
Os_rtthread.c (components\external\sqlite-3.8.1\src):** Return the sector size in bytes of the underlying block device for
Os_rtthread.c (components\external\sqlite-3.8.1\src):** a database and its journal file) that the sector size will be the
Os_unix.c (components\external\sqlite-3.8.1\src):  sqlite3_int64 mmapSize;             /* Usable size of mapping at pMapRegion */
Os_unix.c (components\external\sqlite-3.8.1\src):  sqlite3_int64 mmapSizeActual;       /* Actual size of mapping at pMapRegion */
Os_unix.c (components\external\sqlite-3.8.1\src):  int sectorSize;                     /* Device sector size */
Os_unix.c (components\external\sqlite-3.8.1\src):  /* In test mode, increase the size of this structure a bit so that 
Os_unix.c (components\external\sqlite-3.8.1\src):  ** incorrectly for zero-size files.  See ticket #3260.  To work
Os_unix.c (components\external\sqlite-3.8.1\src):  ** we always increase the file size to 1 by writing a single byte
Os_unix.c (components\external\sqlite-3.8.1\src):** SQLite sets the dataOnly flag if the size of the file is unchanged.
Os_unix.c (components\external\sqlite-3.8.1\src):** to disk, not the inode.  We only set dataOnly if the file size is 
Os_unix.c (components\external\sqlite-3.8.1\src):** unchanged since the file size is part of the inode.  However, 
Os_unix.c (components\external\sqlite-3.8.1\src):** file size has changed.  The only real difference between fdatasync()
Os_unix.c (components\external\sqlite-3.8.1\src):** We only care about the file size, not the other file attributes, so
Os_unix.c (components\external\sqlite-3.8.1\src):  /* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctly
Os_unix.c (components\external\sqlite-3.8.1\src):** size, access time, etc) are synced.  If dataOnly!=0 then only the
Os_unix.c (components\external\sqlite-3.8.1\src):** Truncate an open file to a specified size
Os_unix.c (components\external\sqlite-3.8.1\src):  /* If the user has configured a chunk-size for this file, truncate the
Os_unix.c (components\external\sqlite-3.8.1\src):  ** actual file size after the operation may be larger than the requested
Os_unix.c (components\external\sqlite-3.8.1\src):  ** size).
Os_unix.c (components\external\sqlite-3.8.1\src):    /* If the file was just truncated to a size smaller than the currently
Os_unix.c (components\external\sqlite-3.8.1\src):    ** mapped region, reduce the effective mapping size as well. SQLite will
Os_unix.c (components\external\sqlite-3.8.1\src):** Determine the current size of a file in bytes
Os_unix.c (components\external\sqlite-3.8.1\src):  /* When opening a zero-size database, the findInodeInfo() procedure
Os_unix.c (components\external\sqlite-3.8.1\src):  ** layers, we need to report this file size as zero even though it is
Os_unix.c (components\external\sqlite-3.8.1\src):** file-control operation.  Enlarge the database to nBytes in size
Os_unix.c (components\external\sqlite-3.8.1\src):** (rounded up to the next chunk-size).  If the database is already
Os_unix.c (components\external\sqlite-3.8.1\src):    i64 nSize;                    /* Required file size */
Os_unix.c (components\external\sqlite-3.8.1\src):      ** ftruncate() to set the file size, then write a single byte to
Os_unix.c (components\external\sqlite-3.8.1\src):      int nBlk = buf.st_blksize;  /* File-system block size */
Os_unix.c (components\external\sqlite-3.8.1\src):** Return the sector size in bytes of the underlying block device for
Os_unix.c (components\external\sqlite-3.8.1\src):** a database and its journal file) that the sector size will be the
Os_unix.c (components\external\sqlite-3.8.1\src):        /* etfs cluster size writes are atomic */
Os_unix.c (components\external\sqlite-3.8.1\src):        /* full bitset of atomics from max sector size and smaller */
Os_unix.c (components\external\sqlite-3.8.1\src):        /* full bitset of atomics from max sector size and smaller */
Os_unix.c (components\external\sqlite-3.8.1\src):  /* Last chance verification.  If the sector size isn't a multiple of 512
Os_unix.c (components\external\sqlite-3.8.1\src):** bytes in size.
Os_unix.c (components\external\sqlite-3.8.1\src):    int nByte = (iRegion+1)*szRegion;  /* Minimum required file size */
Os_unix.c (components\external\sqlite-3.8.1\src):** Return the system page size.
Os_unix.c (components\external\sqlite-3.8.1\src):** Attempt to set the size of the memory mapping maintained by file 
Os_unix.c (components\external\sqlite-3.8.1\src):  i64 nNew                        /* Required mapping size */
Os_unix.c (components\external\sqlite-3.8.1\src):** If parameter nByte is non-negative, then it is the requested size of 
Os_unix.c (components\external\sqlite-3.8.1\src):** requested size is the size of the file on disk. The actual size of the
Os_unix.c (components\external\sqlite-3.8.1\src):** created mapping is either the requested size or the value configured 
Os_unix.c (components\external\sqlite-3.8.1\src):** is a string buffer at least MAXPATHLEN+1 characters in size.
Os_win.c (components\external\sqlite-3.8.1\src):  int szChunk;            /* Chunk size configured by FCNTL_CHUNK_SIZE */
Os_win.c (components\external\sqlite-3.8.1\src):  sqlite3_int64 mmapSize;       /* Usable size of mapped region */
Os_win.c (components\external\sqlite-3.8.1\src):  sqlite3_int64 mmapSizeActual; /* Actual size of mapped region */
Os_win.c (components\external\sqlite-3.8.1\src): * The size of the buffer used by sqlite3_win32_write_debug().
Os_win.c (components\external\sqlite-3.8.1\src): * The initial size of the Win32-specific heap.  This value may be zero.
Os_win.c (components\external\sqlite-3.8.1\src): * The maximum size of the Win32-specific heap.  This value may be zero.
Os_win.c (components\external\sqlite-3.8.1\src):** Change the size of an existing memory allocation
Os_win.c (components\external\sqlite-3.8.1\src):** Return the size of an outstanding allocation, in bytes.
Os_win.c (components\external\sqlite-3.8.1\src):** Round up a request size to the next valid allocation size.
Os_win.c (components\external\sqlite-3.8.1\src):** Truncate an open file to a specified size
Os_win.c (components\external\sqlite-3.8.1\src):  OSTRACE(("TRUNCATE file=%p, size=%lld, lock=%d\n",
Os_win.c (components\external\sqlite-3.8.1\src):  /* If the user has configured a chunk-size for this file, truncate the
Os_win.c (components\external\sqlite-3.8.1\src):  ** actual file size after the operation may be larger than the requested
Os_win.c (components\external\sqlite-3.8.1\src):  ** size).
Os_win.c (components\external\sqlite-3.8.1\src):  /* If the file was truncated to a size smaller than the currently
Os_win.c (components\external\sqlite-3.8.1\src):  ** mapped region, reduce the effective mapping size as well. SQLite will
Os_win.c (components\external\sqlite-3.8.1\src):** Determine the current size of a file in bytes
Os_win.c (components\external\sqlite-3.8.1\src):** Return the sector size in bytes of the underlying block device for
Os_win.c (components\external\sqlite-3.8.1\src):** a database and its journal file) that the sector size will be the
Os_win.c (components\external\sqlite-3.8.1\src):** on allocation size granularity boundaries.
Os_win.c (components\external\sqlite-3.8.1\src):** to get the granularity size.
Os_win.c (components\external\sqlite-3.8.1\src):  OSTRACE(("SHM-LOCK file=%p, lock=%d, offset=%d, size=%d\n",
Os_win.c (components\external\sqlite-3.8.1\src):** bytes in size.
Os_win.c (components\external\sqlite-3.8.1\src):    int nByte = (iRegion+1)*szRegion;  /* Minimum required file size */
Os_win.c (components\external\sqlite-3.8.1\src):    sqlite3_int64 sz;                  /* Current size of wal-index file */
Os_win.c (components\external\sqlite-3.8.1\src):      OSTRACE(("SHM-MAP-CREATE pid=%lu, region=%d, size=%d, rc=%s\n",
Os_win.c (components\external\sqlite-3.8.1\src):        OSTRACE(("SHM-MAP-MAP pid=%lu, region=%d, offset=%d, size=%d, rc=%s\n",
Os_win.c (components\external\sqlite-3.8.1\src):** If parameter nByte is non-negative, then it is the requested size of 
Os_win.c (components\external\sqlite-3.8.1\src):** requested size is the size of the file on disk. The actual size of the
Os_win.c (components\external\sqlite-3.8.1\src):** created mapping is either the requested size or the value configured 
Os_win.c (components\external\sqlite-3.8.1\src):  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, size=%lld\n",
Os_win.c (components\external\sqlite-3.8.1\src):** bytes in size.
Otvgpos.c (components\external\freetype\src\otvalid):        /* size is probably not worth the trouble                          */
Otvmath.c (components\external\freetype\src\otvalid):      p += 2;                          /* skip the size */
Pager-invariants.txt (components\external\sqlite-3.8.1\doc): (3) Writes to the database file are an integer multiple of the page size
Pager-invariants.txt (components\external\sqlite-3.8.1\doc):     an integer multiple of the page size in length or are taken from the
Pager-invariants.txt (components\external\sqlite-3.8.1\doc):     is called to restore the database file to the same size it was at
Pager.c (components\external\sqlite-3.8.1\src):** (3) Writes to the database file are an integer multiple of the page size
Pager.c (components\external\sqlite-3.8.1\src):**     an integer multiple of the page size in length or are taken from the
Pager.c (components\external\sqlite-3.8.1\src):**     is called to restore the database file to the same size it was at
Pager.c (components\external\sqlite-3.8.1\src):**    state - the file may or may not be locked and the database size is
Pager.c (components\external\sqlite-3.8.1\src):**    open. The database size is known in this state.
Pager.c (components\external\sqlite-3.8.1\src):**    db size etc.) are consistent with the contents of the file-system.
Pager.c (components\external\sqlite-3.8.1\src):** The maximum allowed sector size. 64KiB. If the xSectorsize() method 
Pager.c (components\external\sqlite-3.8.1\src):**   by sqlite3PagerWrite() when the file-system sector-size is larger than
Pager.c (components\external\sqlite-3.8.1\src):**   the database page-size in order to prevent a journal sync from happening 
Pager.c (components\external\sqlite-3.8.1\src):**   dbSize is set based on the size of the database file, which may be 
Pager.c (components\external\sqlite-3.8.1\src):**   larger than the size of the database (the value stored at offset
Pager.c (components\external\sqlite-3.8.1\src):**   28 of the database header by the btree). If the size of the file
Pager.c (components\external\sqlite-3.8.1\src):**   is not an integer multiple of the page-size, the value stored in
Pager.c (components\external\sqlite-3.8.1\src):**   dbSize is rounded down (i.e. a 5KB file with 2K page-size has dbSize==2).
Pager.c (components\external\sqlite-3.8.1\src):**   Except, any file that is greater than 0 bytes in size is considered
Pager.c (components\external\sqlite-3.8.1\src):**   to have at least one page. (i.e. a 1KB file with 2K page-size leads
Pager.c (components\external\sqlite-3.8.1\src):**   Throughout a write-transaction, dbFileSize contains the size of
Pager.c (components\external\sqlite-3.8.1\src):**   size-hint passed to the method call. See pager_write_pagelist() for 
Pager.c (components\external\sqlite-3.8.1\src):  sqlite3_int64 szMmap;       /* Desired maximum mmap size */
Pager.c (components\external\sqlite-3.8.1\src):  u32 sectorSize;             /* Assumed sector size during rollback */
Pager.c (components\external\sqlite-3.8.1\src):  Pgno mxPgno;                /* Maximum allowed size of the database */
Pager.c (components\external\sqlite-3.8.1\src):  void (*xCodecSizeChng)(void*,int,int); /* Notify of page size changes */
Pager.c (components\external\sqlite-3.8.1\src):** The size of the of each page record in the journal is given by
Pager.c (components\external\sqlite-3.8.1\src):** The journal header size for this pager. This is usually the same 
Pager.c (components\external\sqlite-3.8.1\src):** size as a single disk sector. See also setSectorSize().
Pager.c (components\external\sqlite-3.8.1\src):**      to the page size.
Pager.c (components\external\sqlite-3.8.1\src):** then the value returned is the size of the journal file when it
Pager.c (components\external\sqlite-3.8.1\src):    int nSector;                      /* Sector size */
Pager.c (components\external\sqlite-3.8.1\src):    int szPage;                       /* Page size */
Pager.c (components\external\sqlite-3.8.1\src):  i64 szJ;                   /* Total size in bytes of journal file pJrnl */
Pager.c (components\external\sqlite-3.8.1\src):** size of pPager->sectorSize bytes.
Pager.c (components\external\sqlite-3.8.1\src):** i.e for a sector size of 512:
Pager.c (components\external\sqlite-3.8.1\src):** set to 0, then truncate the journal file to zero bytes in size. Otherwise,
Pager.c (components\external\sqlite-3.8.1\src):** following the truncation or zeroing described above the size of the 
Pager.c (components\external\sqlite-3.8.1\src):    ** is still held on the file. If there is a size limit configured for 
Pager.c (components\external\sqlite-3.8.1\src):** - 4 bytes: Sector size used by the process that wrote this journal.
Pager.c (components\external\sqlite-3.8.1\src):** - 4 bytes: Database page size.
Pager.c (components\external\sqlite-3.8.1\src):  /* The initial database size */
Pager.c (components\external\sqlite-3.8.1\src):  /* The assumed sector size for this process */
Pager.c (components\external\sqlite-3.8.1\src):  /* The page size */
Pager.c (components\external\sqlite-3.8.1\src):  ** The loop is required here in case the sector-size is larger than the 
Pager.c (components\external\sqlite-3.8.1\src):  ** database page size. Since the zHeader buffer is only Pager.pageSize
Pager.c (components\external\sqlite-3.8.1\src):  ** bytes in size, more than one call to sqlite3OsWrite() may be required
Pager.c (components\external\sqlite-3.8.1\src):** page records following this header and *pDbSize is set to the size of the
Pager.c (components\external\sqlite-3.8.1\src):  u32 *pDbSize                 /* OUT: Value of original database size field */
Pager.c (components\external\sqlite-3.8.1\src):  ** field, the checksum-initializer and the database size at the start
Pager.c (components\external\sqlite-3.8.1\src):    u32 iPageSize;               /* Page-size field of journal header */
Pager.c (components\external\sqlite-3.8.1\src):    u32 iSectorSize;             /* Sector-size field of journal header */
Pager.c (components\external\sqlite-3.8.1\src):    /* Read the page-size and sector-size journal header fields. */
Pager.c (components\external\sqlite-3.8.1\src):    /* Versions of SQLite prior to 3.5.8 set the page-size field of the
Pager.c (components\external\sqlite-3.8.1\src):    ** variable is already set to the correct page size.
Pager.c (components\external\sqlite-3.8.1\src):    /* Check that the values read from the page-size and sector-size fields
Pager.c (components\external\sqlite-3.8.1\src):      /* If the either the page-size or sector-size in the journal-header is 
Pager.c (components\external\sqlite-3.8.1\src):    /* Update the page-size to match the value read from the journal. 
Pager.c (components\external\sqlite-3.8.1\src):    /* Update the assumed sector-size to match the value used by 
Pager.c (components\external\sqlite-3.8.1\src):  ** file to the required size.
Pager.c (components\external\sqlite-3.8.1\src):**     Journal file is truncated to zero bytes in size.
Pager.c (components\external\sqlite-3.8.1\src):    ** required size.  */
Pager.c (components\external\sqlite-3.8.1\src):** Report the current page size and number of reserved bytes back
Pager.c (components\external\sqlite-3.8.1\src):** size.
Pager.c (components\external\sqlite-3.8.1\src):** This function is used to change the actual size of the database 
Pager.c (components\external\sqlite-3.8.1\src):** DBMOD or OPEN state, this function is a no-op. Otherwise, the size 
Pager.c (components\external\sqlite-3.8.1\src):** you try to truncate a file to some size that is larger than it 
Pager.c (components\external\sqlite-3.8.1\src):** Return a sanitized version of the sector-size of OS file pFile. The
Pager.c (components\external\sqlite-3.8.1\src):** of the open database file. The sector size will be used used 
Pager.c (components\external\sqlite-3.8.1\src):** to determine the size and alignment of journal header and 
Pager.c (components\external\sqlite-3.8.1\src):** For temporary files the effective sector size is always 512 bytes.
Pager.c (components\external\sqlite-3.8.1\src):** Otherwise, for non-temporary files, the effective sector size is
Pager.c (components\external\sqlite-3.8.1\src):** the effective sector size to its minimum value (512).  The purpose of
Pager.c (components\external\sqlite-3.8.1\src):** size.  For backwards compatibility of the rollback journal file format,
Pager.c (components\external\sqlite-3.8.1\src):** we cannot reduce the effective sector size below 512.
Pager.c (components\external\sqlite-3.8.1\src):    /* Sector size doesn't matter for temporary files. Also, the file
Pager.c (components\external\sqlite-3.8.1\src):**       number of page records from the journal size.
Pager.c (components\external\sqlite-3.8.1\src):**  (5)  4 byte big-endian integer which is the sector size.  The header
Pager.c (components\external\sqlite-3.8.1\src):**       is this many bytes in size.
Pager.c (components\external\sqlite-3.8.1\src):**  (6)  4 byte big-endian integer which is the page size.
Pager.c (components\external\sqlite-3.8.1\src):**  (7)  zero padding out to the next sector size.
Pager.c (components\external\sqlite-3.8.1\src):** value of nRec from the size of the journal file.  But if a power
Pager.c (components\external\sqlite-3.8.1\src):** case that the size of the journal file had already been increased but
Pager.c (components\external\sqlite-3.8.1\src):** the value of nRec computed from the file size would be too large.  For
Pager.c (components\external\sqlite-3.8.1\src):** from the file size.  This value is used when the user selects the
Pager.c (components\external\sqlite-3.8.1\src):    ** size of the file.
Pager.c (components\external\sqlite-3.8.1\src):    ** should be computed based on the journal file size.
Pager.c (components\external\sqlite-3.8.1\src):    ** database file back to its original size.
Pager.c (components\external\sqlite-3.8.1\src):  ** back a journal created by a process with a different sector size
Pager.c (components\external\sqlite-3.8.1\src):      ** zero or the size of the database in page. Bytes 32..35 and 35..39
Pager.c (components\external\sqlite-3.8.1\src):  Pgno nTruncate,                 /* Database size after this commit */
Pager.c (components\external\sqlite-3.8.1\src):** to PAGER_READER state to determine the size of the database file
Pager.c (components\external\sqlite-3.8.1\src):** in pages (assuming the page size currently stored in Pager.pageSize).
Pager.c (components\external\sqlite-3.8.1\src):** If no error occurs, SQLITE_OK is returned and the size of the database
Pager.c (components\external\sqlite-3.8.1\src):  /* Query the WAL sub-system for the database size. The WalDbsize()
Pager.c (components\external\sqlite-3.8.1\src):  ** if the database size is not available. The database size is not
Pager.c (components\external\sqlite-3.8.1\src):  /* If the database size was not available from the WAL sub-system,
Pager.c (components\external\sqlite-3.8.1\src):  ** determine it based on the size of the database file. If the size
Pager.c (components\external\sqlite-3.8.1\src):  ** of the database file is not an integer multiple of the page-size,
Pager.c (components\external\sqlite-3.8.1\src):  ** bytes in size is considered to contain at least one page.
Pager.c (components\external\sqlite-3.8.1\src):  i64 szJ;                 /* Effective size of the main journal */
Pager.c (components\external\sqlite-3.8.1\src):  /* Set the database size back to the value it was before the savepoint 
Pager.c (components\external\sqlite-3.8.1\src):  /* Use pPager->journalOff as the effective size of the main rollback
Pager.c (components\external\sqlite-3.8.1\src):  ** greater than the current database size (pPager->dbSize) but those
Pager.c (components\external\sqlite-3.8.1\src):** Change the maximum size of any memory mapping made of the database file.
Pager.c (components\external\sqlite-3.8.1\src):** Change the page size used by the Pager object. The new page size 
Pager.c (components\external\sqlite-3.8.1\src):**   * the new page size (value of *pPageSize) is valid (a power 
Pager.c (components\external\sqlite-3.8.1\src):** then the pager object page size is set to *pPageSize.
Pager.c (components\external\sqlite-3.8.1\src):** If the page size is changed, then this function uses sqlite3PagerMalloc() 
Pager.c (components\external\sqlite-3.8.1\src):** fails, SQLITE_NOMEM is returned and the page size remains unchanged. 
Pager.c (components\external\sqlite-3.8.1\src):** If the page size is not changed, either because one of the enumerated
Pager.c (components\external\sqlite-3.8.1\src):** then *pPageSize is set to the old, retained page size before returning.
Pager.c (components\external\sqlite-3.8.1\src):** maximum page count below the current size of the database.
Pager.c (components\external\sqlite-3.8.1\src):** opened on a file less than N bytes in size, the output buffer is
Pager.c (components\external\sqlite-3.8.1\src):** However, if the file is between 1 and <page-size> bytes in size, then 
Pager.c (components\external\sqlite-3.8.1\src):**   a) The page number is less than or equal to the size of the 
Pager.c (components\external\sqlite-3.8.1\src):** size of the journal file so that the pager_playback() routine knows
Pager.c (components\external\sqlite-3.8.1\src):  ** file size will be.
Pager.c (components\external\sqlite-3.8.1\src):    /* If the page number of this page is larger than the current size of
Pager.c (components\external\sqlite-3.8.1\src):  u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  /* Default page size */
Pager.c (components\external\sqlite-3.8.1\src):    ** choose a default page size in case we have to create the
Pager.c (components\external\sqlite-3.8.1\src):    ** database file. The default page size is the maximum of:
Pager.c (components\external\sqlite-3.8.1\src):    **    + The largest page size that can be written atomically.
Pager.c (components\external\sqlite-3.8.1\src):    ** In this case we accept the default page size and delay actually
Pager.c (components\external\sqlite-3.8.1\src):**   * The database file itself is greater than 0 bytes in size, and
Pager.c (components\external\sqlite-3.8.1\src):** If the current size of the database file is 0 but a journal file
Pager.c (components\external\sqlite-3.8.1\src):      /* Check the size of the database file. If it consists of 0 pages,
Pager.c (components\external\sqlite-3.8.1\src):        ** to its original size while this process was not holding a lock.
Pager.c (components\external\sqlite-3.8.1\src):        ** to be the right size but is not actually valid. Avoid this
Pager.c (components\external\sqlite-3.8.1\src):  /* Update the database size and return.
Pager.c (components\external\sqlite-3.8.1\src):    /* This trick assumes that both the page-size and sector-size are
Pager.c (components\external\sqlite-3.8.1\src):      **      blocks of size page-size, and 
Pager.c (components\external\sqlite-3.8.1\src):    ** the sub-journal to zero bytes in size. */
Pager.c (components\external\sqlite-3.8.1\src):** Get/set the size-limit used for persistent journal files.
Pager.c (components\external\sqlite-3.8.1\src):** Setting the size limit to -1 means no limit is enforced.
Pager.c (components\external\sqlite-3.8.1\src):** frames, return the size in bytes of the page images stored within the
Pager.h (components\external\sqlite-3.8.1\src):** Default maximum size for persistent journal files. A negative 
Pagesig.c (components\external\sqlite-3.8.1\tool):** Open a file.  Find its page size.  Read each page, and compute and
Pagesig.c (components\external\sqlite-3.8.1\tool):    fprintf(stderr, "invalid page size: %02x%02x\n", aBuf[16], aBuf[17]);
Pb.h (components\external\nanopb):    pb_ssize_t size_offset; /* Offset of array size or has-boolean, relative to data */
Pb.h (components\external\nanopb):    pb_size_t data_size; /* Data size in bytes for a single item */
Pb.h (components\external\nanopb):#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; uint8_t bytes[n]; }
Pb.h (components\external\nanopb):    pb_size_t size;
Pb.h (components\external\nanopb):#       define pb_realloc(ptr, size) realloc(ptr, size)
Pb.h (components\external\nanopb): * previous field end, and the size of the field. Pointer is used for
Pb.h (components\external\nanopb):/* Allocated fields carry the size of the actual data, not the pointer */
Pbuf.c (components\net\lwip-1.3.2\src\core): * layer at which the pbuf is allocated and the requested size
Pbuf.c (components\net\lwip-1.3.2\src\core): * (from the size parameter).
Pbuf.c (components\net\lwip-1.3.2\src\core): * @param layer flag to define header size
Pbuf.c (components\net\lwip-1.3.2\src\core): * @param length size of the pbuf's payload
Pbuf.c (components\net\lwip-1.3.2\src\core):    /* the total length of the pbuf chain is the requested size */
Pbuf.c (components\net\lwip-1.3.2\src\core):      /* this pbuf length is pool size, unless smaller sized tail */
Pbuf.c (components\net\lwip-1.3.2\src\core): * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
Pbuf.c (components\net\lwip-1.3.2\src\core): * @param p pbuf to change the header size.
Pbuf.c (components\net\lwip-1.3.2\src\core): * @param header_size_increment Number of bytes to increment header size which
Pbuf.c (components\net\lwip-1.3.2\src\core): * increases the size of the pbuf. New space is on the front.
Pbuf.c (components\net\lwip-1.3.2\src\core): * (Using a negative value decreases the header size.)
Pbuf.c (components\net\lwip-1.3.2\src\core): * the call will fail. A check is made that the increase in header size does
Pbuf.c (components\net\lwip-1.3.2\src\core):        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
